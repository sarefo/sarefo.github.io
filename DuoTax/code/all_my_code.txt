
==> ./api.js <==
// iNat API

const api = (() => {
    return {

        // fetch from JSON file
        fetchTaxonPairs: async function () {
            try {
                const response = await fetch('./data/taxonPairs.json');
                if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); }
                return await response.json();
            } catch (error) { console.error("Could not fetch taxon pairs:", error); return []; }
        },

        // for user input of new taxon pairs
        validateTaxon: async function (taxonName) {
            try {
                const response = await fetch(`https://api.inaturalist.org/v1/taxa?q=${encodeURIComponent(taxonName)}`);
                const data = await response.json();
                return data.results.length > 0 ? data.results[0] : null;
            } catch (error) {
                console.error('Error validating taxon:', error);
                return null;
            }
        },

        // fetch random image of taxon from iNat
        fetchRandomImage: async function (taxonName) {
            const images = await this.fetchMultipleImages(taxonName, 1);
            return images.length > 0 ? images[0] : null;
        },

        fetchMultipleImages: async function (taxonName, count = 12) {
            try {
                const searchResponse = await fetch(`https://api.inaturalist.org/v1/taxa?q=${taxonName}`);
                const searchData = await searchResponse.json();
                if (searchData.results.length === 0) { throw new Error('Taxon not found'); }
                const taxonId = searchData.results[0].id;
                
                const taxonResponse = await fetch(`https://api.inaturalist.org/v1/taxa/${taxonId}`);
                const taxonData = await taxonResponse.json();
                if (taxonData.results.length === 0) { throw new Error('No details found for the taxon'); }
                const taxon = taxonData.results[0];
                
                let images = taxon.taxon_photos.map(photo => photo.photo.url.replace('square', 'medium'));
                
                // If we don't have enough images, we'll just return what we have
                return images.slice(0, Math.min(count, images.length));
            } catch (error) {
                console.error(error);
                return [];
            }
        },

        // fetch vernacular name of taxon from iNat
        fetchVernacular: async function (taxonName) {
            const baseUrl = 'https://api.inaturalist.org/v1/taxa';
            try {
                const response = await fetch(`${baseUrl}?q=${encodeURIComponent(taxonName)}`);
                const data = await response.json();
                if (data.results && data.results.length > 0) {
                    const taxon = data.results[0];
                    if (taxon && taxon.preferred_common_name) {
                        return taxon.preferred_common_name;
                    } else { return 'No vernacular name'; }
                } else { return 'Taxon not found'; }
            } catch (error) { console.error('Error fetching vernacular name:', error); return ""; }
        },

        // function to check if iNaturalist API is reachable
        isINaturalistReachable: async function () {
          try {
            const response = await fetch('https://api.inaturalist.org/v1/taxa?q=test');
            return response.ok;
          } catch (error) {
            console.error('Error pinging iNaturalist API:', error);
            return false;
          }
        },

    }; 

})();

export default api;

==> ./config.js <==
// Configuration

const config = {

    // overlay colors
    overlayColors: {
        green: "rgba(116,172,0,1.0)", /* iNat green */
        red: "rgba(172, 0, 40, 1.0)",
        gray: "rgba(100, 100, 100, 0.8"
    },
    debug: false,
    enablePreloading: false // Set to false to disable preloading
    };

export default config;

==> ./dragAndDrop.js <==
// Drag and drop functionality

import game from './game.js';

const dragAndDrop = {

    // tile dragging stuff
    draggedElement: null,
    touchOffset: { x: 0, y: 0 },

    initialize() {
        this.addEventListeners();
    },

    addEventListeners() {
        document.querySelectorAll('.draggable').forEach(element => {
            element.addEventListener('dragstart', this.dragStart.bind(this));
            element.addEventListener('touchstart', this.touchStart.bind(this), { passive: false });
            element.addEventListener('touchmove', this.touchMove.bind(this), { passive: false });
            element.addEventListener('touchend', this.touchEnd.bind(this), { passive: false });
        });

        document.querySelectorAll('.image-container').forEach(element => {
            element.addEventListener('dragover', this.dragOver.bind(this));
            element.addEventListener('dragleave', this.dragLeave.bind(this));
            element.addEventListener('drop', this.drop.bind(this));
        });
    },

    dragStart(e) {
        e.dataTransfer.setData('text/plain', e.target.id);
    },

    touchStart(e) {
        e.preventDefault();
        this.draggedElement = e.target.closest('.draggable');
        if (!this.draggedElement) return;
        
        const touch = e.touches[0];
        const rect = this.draggedElement.getBoundingClientRect();
        this.touchOffset.x = touch.clientX - rect.left;
        this.touchOffset.y = touch.clientY - rect.top;
        
        this.draggedElement.style.zIndex = '1000';
        this.draggedElement.style.position = 'fixed';
        this.updateElementPosition(touch);
    },

    touchMove(e) {
        e.preventDefault();
        if (this.draggedElement) {
            const touch = e.touches[0];
            this.updateElementPosition(touch);
        }
    },

    touchEnd(e) {
        e.preventDefault();
        if (this.draggedElement) {
            const dropZone = this.getDropZone(e);
            if (dropZone) {
                this.handleDrop(dropZone);
            } else {
                this.resetDraggedElement();
            }
            this.draggedElement.style.zIndex = '';
            this.draggedElement.style.position = '';
            this.draggedElement = null;
        }
    },

    updateElementPosition(touch) {
        this.draggedElement.style.left = `${touch.clientX - this.touchOffset.x}px`;
        this.draggedElement.style.top = `${touch.clientY - this.touchOffset.y}px`;
    },

    dragOver(e) {
        e.preventDefault();
        if (e.target.classList.contains('image-container')) {
            e.target.classList.add('drag-over');
        }
    },

    dragLeave(e) {
        if (e.target.classList.contains('image-container')) {
            e.target.classList.remove('drag-over');
        }
    },

    drop(e) {
        e.preventDefault();
        const data = e.dataTransfer.getData('text');
        const draggedElement = document.getElementById(data);
        
        let dropZone;
        if (e.target.classList.contains('image-container')) {
            e.target.classList.remove('drag-over');
            dropZone = e.target.querySelector('div[id^="drop-"]');
        } else if (e.target.tagName === 'IMG') {
            e.target.parentElement.classList.remove('drag-over');
            dropZone = e.target.nextElementSibling;
        } else { 
            return; // Drop on an invalid target
        }

        this.handleDrop(dropZone, draggedElement);
    },

    handleDrop(dropZone, draggedElement = this.draggedElement) {
        if (!draggedElement) return;
        
        dropZone.innerHTML = '';
        dropZone.appendChild(draggedElement);
        draggedElement.style.position = 'static'; // Reset position to static
        draggedElement.style.left = '';
        draggedElement.style.top = '';
        draggedElement.style.width = '100%'; // Ensure the dragged element fills the drop zone width
        
        const otherNameId = draggedElement.id === 'left-name' ? 'right-name' : 'left-name';
        const otherName = document.getElementById(otherNameId);
        const otherDropZone = document.getElementById(dropZone.id === 'drop-1' ? 'drop-2' : 'drop-1');
        otherDropZone.innerHTML = '';
        otherDropZone.appendChild(otherName);
        
        game.checkAnswer(dropZone.id);
    },

    getDropZone(e) {
        const touch = e.changedTouches ? e.changedTouches[0] : e;
        const imageContainers = document.querySelectorAll('.image-container');
        for (let container of imageContainers) {
            const rect = container.getBoundingClientRect();
            if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
                touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
                return container.querySelector('div[id^="drop-"]');
            }
        }
        return null;
    },

    resetDraggedElement() {
        const originalContainer = this.draggedElement.id === 'left-name' ? 'left-name-container' : 'right-name-container';
        document.getElementById(originalContainer).appendChild(this.draggedElement);
        this.draggedElement.style.position = '';
        this.draggedElement.style.left = '';
        this.draggedElement.style.top = '';
    }
};

export default dragAndDrop;

==> ./eventHandlers.js <==
// Event handlers

import api from './api.js';
import game from './game.js';
import ui from './ui.js';
import utils from './utils.js';
import dragAndDrop from './dragAndDrop.js';
import { elements, gameState } from './state.js';

const eventHandlers = {

    // global variables for swiping left
    startX: 0,
    endX: 0,
    isDragging: false,
    gameContainer: null,
    touchStartX: 0,
    touchStartY: 0,
    touchEndX: 0,
    touchEndY: 0,

    swipeThreshold: 50, // minimum distance to trigger a swipe
    swipeRestraint: 100, // maximum vertical distance allowed during a swipe

    initialize() {
        this.initializeSwipeFunctionality();
        this.initializeAllEventListeners();
    },

    initializeSwipeFunctionality() {
        this.gameContainer = document.querySelector('.game-container');
        if (!this.gameContainer) {
            console.error('Game container not found');
            return;
        }
        
        const namePairElement = document.querySelector('.name-pair');

        // Add event listeners only to image containers
        [elements.imageOneContainer, elements.imageTwoContainer].forEach(container => {
            container.addEventListener('mousedown', this.handleMouseDown.bind(this));
            container.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: true });
            container.addEventListener('mousemove', this.handleDragMove.bind(this));
            container.addEventListener('touchmove', this.handleDragMove.bind(this), { passive: true });
            container.addEventListener('mouseup', this.handleSwipeOrDrag.bind(this));
            container.addEventListener('touchend', this.handleSwipeOrDrag.bind(this));
        });
    },

    initializeAllEventListeners() {
        dragAndDrop.initialize();
        
        // button listeners
        document.getElementById('share-button').addEventListener('click', this.shareCurrentPair);
        document.getElementById('random-pair-button').addEventListener('click', async () => { await game.setupGame(true); });
        document.getElementById('select-pair-button').addEventListener('click', this.showTaxonPairList);
    
        // touch events
        [elements.imageOneContainer, elements.imageTwoContainer].forEach(container => {
            container.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: true });
            container.addEventListener('touchend', this.handleImageInteraction.bind(this));
            container.addEventListener('mousedown', this.handleMouseDown.bind(this));
            container.addEventListener('mouseup', this.handleImageInteraction.bind(this));
        });

        // dialog events
        document.getElementById('enter-pair-button').addEventListener('click', () => {
            ui.clearDialogInputs();
            document.getElementById('enter-pair-dialog').showModal();
        });
        document.getElementById('close-dialog').addEventListener('click', () => {
            document.getElementById('enter-pair-dialog').close();
        });
        document.querySelector('#enter-pair-dialog form').addEventListener('submit', this.handleNewPairSubmit);
        document.getElementById('surprise-button').addEventListener('click', () => {
            ui.clearDialogInputs();
            utils.surprise();
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', this.handleKeyboardShortcuts.bind(this));

        // Help button functionality
        document.getElementById('help-button').addEventListener('click', () => {
            document.getElementById('help-dialog').showModal();
        });
        document.getElementById('discord-help-dialog').addEventListener('click', () => {
            window.open('https://discord.gg/DcWrhYHmeM', '_blank');
        });
        document.getElementById('close-help-dialog').addEventListener('click', () => {
            document.getElementById('help-dialog').close();
        });

        // Prevent scrolling in the name-pair area
        elements.namePair.addEventListener('touchmove', (event) => { event.preventDefault(); }, { passive: false });
        elements.namePair.addEventListener('wheel', (event) => { event.preventDefault(); }, { passive: false });

        // Scroll to top when a button is clicked
        elements.buttons.forEach(button => { button.addEventListener('click', () => { ui.scrollToTop(); }); });
    },

    handleMouseDown(e) {
        if (!e.target.closest('.image-container')) return;
        if (e.target.closest('.draggable')) return; // Ignore draggable elements
        this.startX = e.clientX;
        this.startY = e.clientY;
        this.isDragging = true;
    },

    handleTouchStart(e) {
        if (!e.target.closest('.image-container')) return;
        this.startX = e.touches[0].clientX;
        this.startY = e.touches[0].clientY;
        this.isDragging = true;
    },

    handleSwipeOrDrag(e) {
        if (!this.isDragging) return;
        
        let endX, endY;
        if (e.type.includes('touch')) {
            endX = e.changedTouches[0].clientX;
            endY = e.changedTouches[0].clientY;
        } else {
            endX = e.clientX;
            endY = e.clientY;
        }
        
        const deltaX = this.startX - endX;
        const deltaY = Math.abs(this.startY - endY);
        
        if (deltaX > this.swipeThreshold && deltaY < this.swipeRestraint) {
            // Swipe left detected
            document.querySelector('.game-container').classList.add('swipe-out-left');
            
            setTimeout(() => {
                document.querySelector('.game-container').classList.remove('swiping-left', 'swipe-out-left');
                ui.resetGameContainerStyle();
                game.setupGame(true);
            }, 500); // Match this with the animation duration
        } else {
            // Reset if not swiped far enough or swiped vertically
            ui.resetGameContainerStyle();
        }
        
        this.isDragging = false;
    },

    handleDragMove(e) {
        if (!this.isDragging) return;
        
        let currentX, currentY;
        if (e.type.includes('touch')) {
            currentX = e.touches[0].clientX;
            currentY = e.touches[0].clientY;
        } else {
            currentX = e.clientX;
            currentY = e.clientY;
        }
        
        const deltaX = this.startX - currentX;
        const deltaY = Math.abs(this.startY - currentY);
        
        if (deltaX > 0 && deltaY < this.swipeRestraint) {
            const progress = Math.min(deltaX / 100, 1);
            const rotation = progress * -5;
            const opacity = 1 - progress * 0.5;
            
            this.gameContainer.style.transform = `rotate(${rotation}deg) translateX(${-deltaX}px)`;
            this.gameContainer.style.opacity = opacity;
        }
    },

    handleImageInteraction(event) {
        if (!event) return;  // handle cases where event is undefined
        const diffX = Math.abs(this.touchStartX - (event.clientX || event.changedTouches[0].clientX));
        const diffY = Math.abs(this.touchStartY - (event.clientY || event.changedTouches[0].clientY));
        // Add any specific image interaction logic here
    },

    async handleNewPairSubmit(event) {
        event.preventDefault();
        const taxon1 = document.getElementById('taxon1').value;
        const taxon2 = document.getElementById('taxon2').value;
        const dialogMessage = document.getElementById('dialog-message');
        
        dialogMessage.textContent = 'Validating taxa...';
        
        const [validatedTaxon1, validatedTaxon2] = await Promise.all([
            api.validateTaxon(taxon1),
            api.validateTaxon(taxon2)
        ]);
        
        if (validatedTaxon1 && validatedTaxon2) {
            const newPair = {
                taxon1: validatedTaxon1.name,
                taxon2: validatedTaxon2.name
            };
        
            try {
                const response = await fetch('./data/taxonPairs.json');
                const taxonPairs = await response.json();
                taxonPairs.push(newPair);
        
                // Set the new pair as the next pair to be used
                game.nextSelectedPair = newPair;
                
                // Close the dialog
                document.getElementById('enter-pair-dialog').close();
                
                // Set up the game with the new pair
                game.setupGame(true);
            } catch (error) {
                console.error('Error updating taxonPairs.json:', error);
                dialogMessage.textContent = 'Error saving new pair. Please try again.';
            }
        } else {
            dialogMessage.textContent = 'One or both taxa are invalid. Please check and try again.';
        }
    },

    showTaxonPairList() {
        api.fetchTaxonPairs().then(taxonPairs => {
            ui.showTaxonPairList(taxonPairs, (selectedPair) => {
                game.nextSelectedPair = selectedPair;
                game.setupGame(true);
            });
        });
    },

    // move to other module, utils?
    shareCurrentPair() {
        let currentUrl = new URL(window.location.href);
        currentUrl.searchParams.delete('taxon1');
        currentUrl.searchParams.delete('taxon2');
        currentUrl.searchParams.set('taxon1', gameState.taxonImageOne);
        currentUrl.searchParams.set('taxon2', gameState.taxonImageTwo);
        let shareUrl = currentUrl.toString();
        
        navigator.clipboard.writeText(shareUrl).then(() => { }).catch(err => {
            console.error('Failed to copy: ', err);
            alert('Failed to copy link. Please try again.');
        });
    },

    handleKeyboardShortcuts(event) {
        const isDialogOpen = document.getElementById('enter-pair-dialog').open;
        
        if (!isDialogOpen) {
            if (event.key === 'r' || event.key === 'R' || event.key === 'ArrowLeft') {
                document.getElementById('random-pair-button').click();
            }
            if (event.key === 's' || event.key === 'S') {
                document.getElementById('select-pair-button').click();
            }
            if (event.key === 'h' || event.key === 'H') {
                document.getElementById('help-button').click();
            }
            if (event.key === 'e' || event.key === 'E') {
                document.getElementById('enter-pair-button').click();
                setTimeout(() => {
                    document.getElementById('taxon1').value = '';
                    document.getElementById('taxon1').focus();
                }, 0);
            }
            if (event.key === 'p' || event.key === 'P' || event.key === 'f' || event.key === 'F') {
                document.getElementById('surprise-button').click();
            }
        }
    }
};

export default eventHandlers;

==> ./functions.js <==
// snapshot 20240712 2247 > stable, but tooo many preload requests
import api from './api.js';
import config from './config.js';
import dragAndDrop from './dragAndDrop.js';
import {elements, gameState} from './state.js';
import eventHandlers from './eventHandlers.js';
import game from './game.js';
import ui from './ui.js';
import utils from './utils.js';

(function() {

    document.getElementById('version-id').textContent = `Modified: ${document.lastModified}`;

    function initializeApp() {
        console.log("Initializing app");
        
        // Check for URL parameters
        const urlParams = utils.getURLParameters();
        if (urlParams) {
            console.log("URL parameters found:", urlParams);
            game.nextSelectedPair = urlParams;
        }
        
        game.setupGame(true);
        eventHandlers.initialize();
        console.log("App initialization complete");
    }

    // Expose initializeApp to the global scope
    window.initializeApp = initializeApp;

    // Call initialization function
    window.addEventListener('DOMContentLoaded', (event) => {
        window.initializeApp();
    });
})();

==> ./game.js <==
// this snapshot is rather stable, but will take quite long at startup because it loads the whole image set.
// Game functions

import api from './api.js';
import config from './config.js';
import {elements, gameState} from './state.js';
import ui from './ui.js';
import utils from './utils.js';

const game = {
    nextSelectedPair: null,
    currentRound: {
        pair: null,
        imageOneURLs: [],
        imageTwoURLs: [],
        imageOneVernacular: null,
        imageTwoVernacular: null,
        randomized: false
    },
    preloadedPair: null,
    isPreloadingPair: false,
    isInitialLoad: true,
    hasLoadedFullSet: false,

    setupGame: async function (newPair = false) {
        if (!await this.checkINaturalistReachability()) {
            return;
        }

        this.prepareUIForLoading();

        try {
            if (this.nextSelectedPair) {
                await this.loadSelectedPair();
                this.hasLoadedFullSet = false;
            } else if (newPair && this.preloadedPair) {
                this.currentRound = this.preloadedPair;
                this.preloadedPair = null;
                this.hasLoadedFullSet = true;
            } else if (newPair || !this.currentRound.pair) {
                await this.fetchNewPair();
                this.hasLoadedFullSet = false;
            } else {
                this.currentRound.randomized = Math.random() < 0.5;
            }
            
            if (this.isInitialLoad || !this.hasLoadedFullSet) {
                await this.fetchInitialImages();
                this.isInitialLoad = false;
            }

            await this.renderCurrentRound();
            this.finishSetup();

            if (!this.hasLoadedFullSet) {
                this.loadFullImageSet();
            }

            if (!this.preloadedPair && !this.isPreloadingPair) {
                this.preloadNextPair();
            }
        } catch (error) {
            console.error("Error setting up game:", error);
            ui.showOverlay("Error loading game. Please try again.", config.overlayColors.red);
        }
    },

    loadFullImageSet: async function() {
        console.log("Loading full image set for current pair");
        const { taxon1, taxon2 } = this.currentRound.pair;
        const [imageOneURLs, imageTwoURLs] = await Promise.all([
            api.fetchMultipleImages(taxon1),
            api.fetchMultipleImages(taxon2)
        ]);

        this.currentRound.imageOneURLs = imageOneURLs;
        this.currentRound.imageTwoURLs = imageTwoURLs;

        await this.preloadImages(imageOneURLs.concat(imageTwoURLs));
        this.hasLoadedFullSet = true;
        console.log("Finished loading full image set");
    },

    fetchInitialImages: async function() {
        const { taxon1, taxon2 } = this.currentRound.pair;
        const [imageOne, imageTwo, imageOneVernacular, imageTwoVernacular] = await Promise.all([
            api.fetchRandomImage(taxon1),
            api.fetchRandomImage(taxon2),
            api.fetchVernacular(taxon1),
            api.fetchVernacular(taxon2)
        ]);

        this.currentRound.imageOneURLs = [imageOne];
        this.currentRound.imageTwoURLs = [imageTwo];
        this.currentRound.imageOneVernacular = imageOneVernacular;
        this.currentRound.imageTwoVernacular = imageTwoVernacular;

        await this.preloadImages([imageOne, imageTwo]);
    },

    loadSelectedPair: async function() {
        this.currentRound = {
            pair: this.nextSelectedPair,
            imageOneURLs: [],
            imageTwoURLs: [],
            imageOneVernacular: null,
            imageTwoVernacular: null,
            randomized: Math.random() < 0.5
        };
        this.nextSelectedPair = null; // Clear the selected pair
        await this.fetchRoundData();
        [this.currentRound.imageOneVernacular, this.currentRound.imageTwoVernacular] = await Promise.all([
            api.fetchVernacular(this.currentRound.pair.taxon1),
            api.fetchVernacular(this.currentRound.pair.taxon2)
        ]);
    },

    prepareRound: async function(newPair) {
        console.log("Preparing new round, newPair:", newPair);
        if (newPair || !this.currentRound.pair) {
            if (gameState.preloadedPair) {
                console.log("Using preloaded pair");
                this.currentRound = gameState.preloadedPair;
                this.currentRound.randomized = Math.random() < 0.5;
            } else {
                console.log("No preloaded pair available, fetching new pair");
                await this.fetchNewPair();
            }

            // Fetch vernacular names if they're not already preloaded
            if (!this.currentRound.imageOneVernacular || !this.currentRound.imageTwoVernacular) {
                console.log("Fetching vernacular names for current pair");
                [this.currentRound.imageOneVernacular, this.currentRound.imageTwoVernacular] = await Promise.all([
                    api.fetchVernacular(this.currentRound.pair.taxon1),
                    api.fetchVernacular(this.currentRound.pair.taxon2)
                ]);
            }
        } else {
            console.log("Reusing current pair with new randomization");
            this.currentRound.randomized = Math.random() < 0.5;
        }
        console.log("Round preparation complete", this.currentRound);
    },

    fetchNewPair: async function() {
        const newPair = await this.selectTaxonPair();
        this.currentRound = {
            pair: newPair,
            imageOneURLs: [],
            imageTwoURLs: [],
            imageOneVernacular: null,
            imageTwoVernacular: null,
            randomized: Math.random() < 0.5
        };
        
        console.log("Fetching images for new pair");
        await this.fetchRoundData();
    },

    fetchRoundData: async function () {
        if (this.currentRound.imageOneURLs.length === 0 || this.currentRound.imageTwoURLs.length === 0) {
            const { taxon1, taxon2 } = this.currentRound.pair;
            const [imageOneURLs, imageTwoURLs, imageOneVernacular, imageTwoVernacular] = await Promise.all([
                api.fetchMultipleImages(taxon1),
                api.fetchMultipleImages(taxon2),
                api.fetchVernacular(taxon1),
                api.fetchVernacular(taxon2)
            ]);

            this.currentRound.imageOneURLs = imageOneURLs;
            this.currentRound.imageTwoURLs = imageTwoURLs;
            this.currentRound.imageOneVernacular = imageOneVernacular;
            this.currentRound.imageTwoVernacular = imageTwoVernacular;

            await this.preloadImages(imageOneURLs.concat(imageTwoURLs));
        }
    },


    preloadImages: async function(urls) {
        console.log(`Starting to preload ${urls.length} images`);
        const preloadPromises = urls.map(url => {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    console.log(`Preloaded image: ${url}`);
                    resolve();
                };
                img.onerror = () => {
                    console.error(`Failed to preload image: ${url}`);
                    reject();
                };
                img.src = url;
            });
        });
        await Promise.all(preloadPromises);
        console.log("Finished preloading all images");
    },

    renderCurrentRound: async function () {
        console.log("Rendering current round");
        const { pair, imageOneURLs, imageTwoURLs, imageOneVernacular, imageTwoVernacular, randomized } = this.currentRound;

        // Select random images from preloaded arrays
        let leftImageSrc = randomized ? 
            imageOneURLs[Math.floor(Math.random() * imageOneURLs.length)] :
            imageTwoURLs[Math.floor(Math.random() * imageTwoURLs.length)];
        let rightImageSrc = randomized ?
            imageTwoURLs[Math.floor(Math.random() * imageTwoURLs.length)] :
            imageOneURLs[Math.floor(Math.random() * imageOneURLs.length)];

        console.log("Selected images:", { leftImageSrc, rightImageSrc });

        // Set image sources without displaying them yet
        elements.imageOne.src = '';
        elements.imageTwo.src = '';

        const leftName = randomized ? pair.taxon1 : pair.taxon2;
        const rightName = randomized ? pair.taxon2 : pair.taxon1;
        const leftVernacular = randomized ? imageOneVernacular : imageTwoVernacular;
        const rightVernacular = randomized ? imageTwoVernacular : imageOneVernacular;

        this.setupNameTilesUI(leftName, rightName, leftVernacular, rightVernacular);

        gameState.taxonImageOne = randomized ? pair.taxon1 : pair.taxon2;
        gameState.taxonImageTwo = randomized ? pair.taxon2 : pair.taxon1;
        gameState.taxonLeftName = leftName;
        gameState.taxonRightName = rightName;

        // Load images without changing their positions
        await this.loadImages(leftImageSrc, rightImageSrc);
        console.log("Finished rendering current round");
    },

    preloadNextPair: async function() {
        if (this.isPreloadingPair) return;
        
        this.isPreloadingPair = true;
        console.log("Starting to preload next pair in the background");
        try {
            this.preloadedPair = await this.preloadPair();
            console.log("Finished preloading next pair");
        } catch (error) {
            console.error("Error preloading next pair:", error);
        } finally {
            this.isPreloadingPair = false;
        }
    },

    preloadPair: async function () {
        console.log("Preloading next pair...");
        const pair = await this.selectTaxonPair();
        console.log("Selected pair for preloading:", pair);
        const [imageOneURLs, imageTwoURLs, imageOneVernacular, imageTwoVernacular] = await Promise.all([
            api.fetchMultipleImages(pair.taxon1),
            api.fetchMultipleImages(pair.taxon2),
            api.fetchVernacular(pair.taxon1),
            api.fetchVernacular(pair.taxon2)
        ]);
        console.log(`Fetched ${imageOneURLs.length} images for ${pair.taxon1} and ${imageTwoURLs.length} images for ${pair.taxon2}`);

        // Preload all fetched images
        await this.preloadImages(imageOneURLs.concat(imageTwoURLs));
        console.log("Finished preloading images for next pair");

        return { pair, imageOneURLs, imageTwoURLs, imageOneVernacular, imageTwoVernacular, randomized: Math.random() < 0.5 };
    },

    loadNewRound: async function () {
        if (gameState.preloadedPair) {
            this.currentRound = {
                pair: gameState.preloadedPair.pair,
                imageOneURL: gameState.preloadedPair.imageOneURL,
                imageTwoURL: gameState.preloadedPair.imageTwoURL,
                imageOneVernacular: null,
                imageTwoVernacular: null,
                randomized: Math.random() < 0.5
            };
        } else {
            const newPair = await this.selectTaxonPair();
            this.currentRound = {
                pair: newPair,
                imageOneURL: null,
                imageTwoURL: null,
                imageOneVernacular: null,
                imageTwoVernacular: null,
                randomized: Math.random() < 0.5
            };
            await this.fetchRoundData();
        }

        // Fetch vernacular names
        [this.currentRound.imageOneVernacular, this.currentRound.imageTwoVernacular] = await Promise.all([
            api.fetchVernacular(this.currentRound.pair.taxon1),
            api.fetchVernacular(this.currentRound.pair.taxon2)
        ]);

        // Start preloading the next pair
        gameState.preloadedPair = await this.preloadPair();
    },

    refreshCurrentRound: async function () {
        this.currentRound.randomized = Math.random() < 0.5;
        await this.fetchRoundData();
    },

loadImages: async function(leftImageSrc, rightImageSrc) {
    console.log("Loading images:", { leftImageSrc, rightImageSrc });
    await Promise.all([
        this.loadImageAndRemoveLoadingClass(elements.imageOne, leftImageSrc),
        this.loadImageAndRemoveLoadingClass(elements.imageTwo, rightImageSrc)
    ]);
    console.log("Finished loading images");
},

    loadImageAndRemoveLoadingClass: function(imgElement, src) {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
                imgElement.src = src;
                imgElement.classList.remove('loading');
                resolve();
            };
            img.src = src;
        });
    },

    checkINaturalistReachability: async function() {
        if (!await api.isINaturalistReachable()) {
            ui.showINatDownDialog();
            return false;
        }
        return true;
    },

    prepareUIForLoading: function() {
        utils.resetDraggables();
        ui.scrollToTop();
        elements.imageOne.classList.add('loading');
        elements.imageTwo.classList.add('loading');
        var startMessage = gameState.isFirstLoad ? "Drag the names!" : "Loading...";
        ui.showOverlay(startMessage, config.overlayColors.green);
        gameState.isFirstLoad = false;
    },

    loadNewTaxonPair: async function(newPair) {
        if (newPair || !gameState.currentPair) {
            if (gameState.isFirstLoad) {
                const urlParams = utils.getURLParameters();
                gameState.currentPair = urlParams || await this.selectTaxonPair();
            } else if (gameState.preloadedPair) {
                gameState.currentPair = gameState.preloadedPair.pair;
            } else {
                gameState.currentPair = await this.selectTaxonPair();
            }
            gameState.preloadedPair = await this.preloadPair();
        }
    },

    // Core gameplay functions
    setupImages: async function() {
        let randomizeImages = Math.random() < 0.5;
        gameState.taxonImageOne = randomizeImages ? gameState.currentPair.taxon1 : gameState.currentPair.taxon2;
        gameState.taxonImageTwo = randomizeImages ? gameState.currentPair.taxon2 : gameState.currentPair.taxon1;

        const [imageOneVernacular, imageTwoVernacular] = await Promise.all([
            api.fetchVernacular(gameState.taxonImageOne),
            api.fetchVernacular(gameState.taxonImageTwo)
        ]);

        const [imageOneURL, imageTwoURL] = await Promise.all([
            api.fetchRandomImage(gameState.taxonImageOne),
            api.fetchRandomImage(gameState.taxonImageTwo)
        ]);

        await this.loadImages(imageOneURL, imageTwoURL);

        return {
            imageData: {
                imageOneVernacular,
                imageTwoVernacular,
                imageOneURL,
                imageTwoURL
            },
            randomizeImages
        };
    },

    setupNameTiles: function(imageData, randomizeImages) {
        const { taxon1, taxon2 } = gameState.currentPair;
        
        gameState.taxonImageOne = randomizeImages ? taxon1 : taxon2;
        gameState.taxonImageTwo = randomizeImages ? taxon2 : taxon1;
        
        gameState.taxonLeftName = randomizeImages ? taxon1 : taxon2;
        gameState.taxonRightName = randomizeImages ? taxon2 : taxon1;

        let leftNameVernacular = randomizeImages ? imageData.imageOneVernacular : imageData.imageTwoVernacular;
        let rightNameVernacular = randomizeImages ? imageData.imageTwoVernacular : imageData.imageOneVernacular;

        this.setupNameTilesUI(gameState.taxonLeftName, gameState.taxonRightName, leftNameVernacular, rightNameVernacular);
    },

    checkAnswer: function(droppedZoneId) {
        const dropOne = document.getElementById('drop-1');
        const dropTwo = document.getElementById('drop-2');
        const colorCorrect = config.overlayColors.green;
        const colorWrong = config.overlayColors.red;

        const leftAnswer = dropOne.children[0]?.getAttribute('data-taxon');
        const rightAnswer = dropTwo.children[0]?.getAttribute('data-taxon');

        ui.scrollToTop();

        if (leftAnswer && rightAnswer) {
            let isCorrect = false;
            if (droppedZoneId === 'drop-1') {
                isCorrect = leftAnswer === gameState.taxonImageOne;
            } else {
                isCorrect = rightAnswer === gameState.taxonImageTwo;
            }

            if (isCorrect) {
                elements.imageOne.classList.add('loading');
                elements.imageTwo.classList.add('loading');
                ui.showOverlay('Correct!', colorCorrect);
                setTimeout(() => {
                    ui.hideOverlay();
                    game.setupGame(false);
                }, 2400);
            } else {
                utils.resetDraggables();
                ui.showOverlay('Try again!', colorWrong);
                setTimeout(() => {
                    ui.hideOverlay();
                }, 800);
            }
        }
    },

    setupNameTilesUI: function(leftName, rightName, leftNameVernacular, rightNameVernacular) {
        elements.leftName.setAttribute('data-taxon', leftName);
        elements.rightName.setAttribute('data-taxon', rightName);
        elements.leftName.style.zIndex = '10';
        elements.rightName.style.zIndex = '10';

        elements.leftName.innerHTML = `<i>${leftName}</i><br>(${leftNameVernacular})`;
        elements.rightName.innerHTML = `<i>${rightName}</i><br>(${rightNameVernacular})`;
    },

    finishSetup: function() {
        ui.hideOverlay();
        console.log('Setup complete:', {
            taxonImageOne: gameState.taxonImageOne,
            taxonImageTwo: gameState.taxonImageTwo,
            taxonLeftName: gameState.taxonLeftName,
            taxonRightName: gameState.taxonRightName
        });
    },

    selectTaxonPair: async function (index = null) {
        const taxonPairs = await api.fetchTaxonPairs();
        if (taxonPairs.length === 0) {
            console.error("No taxon pairs available");
            return null;
        }
        return !index ? taxonPairs[Math.floor(Math.random() * taxonPairs.length)] : taxonPairs[index];
    }

};

export default game;

==> ./state.js <==
// Elements and game state

// DOM elements
export const elements = {
    imageOne: document.getElementById('image-1'),
    imageTwo: document.getElementById('image-2'),
    imageOneContainer: document.getElementById('image-container-1'),
    imageTwoContainer: document.getElementById('image-container-2'),
    namePair: document.querySelector('.name-pair'),
    leftName: document.getElementById('left-name'),
    rightName: document.getElementById('right-name'),
    overlay: document.getElementById('overlay'),
    overlayMessage: document.getElementById('overlay-message'),
    buttons: document.querySelectorAll('.bottom-button')
};


// Game state
export const gameState = {
    isFirstLoad: true,
    currentPair: null,
    preloadedPair: null,
    taxonImageOne: null,
    taxonImageTwo: null,
    taxonLeftName: null,
    taxonRightName: null,
};

==> ./ui.js <==
// UI functions

import api from './api.js';
import {elements, gameState} from './state.js';
import game from './game.js';

const ui = {

    // Enter pair dialog 
    clearDialogInputs: function () {
            document.getElementById('taxon1').value = '';
            document.getElementById('taxon2').value = '';
            document.getElementById('dialog-message').textContent = '';
        },

    resetGameContainerStyle: function () {
        const gameContainer = document.querySelector('.game-container');
        if (gameContainer) {
            gameContainer.style.transform = '';
            gameContainer.style.opacity = '';
        }
        elements.imageOneContainer.style.transform = '';
        elements.imageOneContainer.style.opacity = '';
        elements.imageTwoContainer.style.transform = '';
        elements.imageTwoContainer.style.opacity = '';
    },

    // TODO move to "const ui" > eventhandler trouble?
    // display pair list for selection
    showTaxonPairList: function () {
        api.fetchTaxonPairs().then(taxonPairs => {
            if (taxonPairs.length === 0) {
                console.error("No taxon pairs available");
                return;
            }
            const modal = document.createElement('div');
            modal.className = 'taxon-pair-modal';
            
            const list = document.createElement('div');
            list.className = 'taxon-pair-list';
            
            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Cancel';
            cancelButton.className = 'taxon-pair-cancel-button';
            cancelButton.onclick = () => {
                document.body.removeChild(modal);
            };
            
            taxonPairs.forEach((pair, index) => {
                const button = document.createElement('button');
                button.innerHTML = `<i>${pair.taxon1}</i> <span class="taxon-pair-versus">vs</span> <i>${pair.taxon2}</i>`;
                button.className = 'taxon-pair-button';
                button.onclick = () => {
                    // Set the selected pair as the next pair to be used
                    game.nextSelectedPair = pair;
                    
                    // Close the modal
                    document.body.removeChild(modal);
                    
                    // Set up the game with the new pair
                    game.setupGame(true);
                };
                list.appendChild(button);
            });
            
            list.insertBefore(cancelButton, list.firstChild);
            
            modal.appendChild(list);
            document.body.appendChild(modal);
            
            modal.onclick = (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            };
        });
    },


    // overlay for result and loading
    showOverlay: function (message="", color) {
        elements.overlayMessage.innerHTML = message;
        elements.overlay.style.backgroundColor = color;
        elements.overlay.classList.add('show');
    },

    hideOverlay: function () {
        elements.overlay.classList.remove('show');
    },

    scrollToTop: function () {
        window.scrollTo({ top: 0, behavior: 'smooth' });
    },

    showINatDownDialog: function () {
        const dialog = document.getElementById('inat-down-dialog');
        dialog.showModal();
        
        document.getElementById('check-inat-status').addEventListener('click', () => {
            window.open('https://inaturalist.org', '_blank');
        });
        
        document.getElementById('retry-connection').addEventListener('click', async () => {
            dialog.close();
            if (await api.isINaturalistReachable()) {
                game.setupGame(true);
            } else {
                showINatDownDialog();
            }
        });
    }

}; // const ui

export default ui;

==> ./utils.js <==
// Utility functions

const utils = {

    // optionally get pair of taxa from URL
    getURLParameters: function () {
        const params = new URLSearchParams(window.location.search);
        const taxon1 = params.get('taxon1');
        const taxon2 = params.get('taxon2');
        if (taxon1 && taxon2) {
            return { taxon1, taxon2 };
        }
        return null;
    },

    surprise: function () {
        // placeholder
        const soundUrl = './sound/fart.mp3';
        // Create a new Audio object

    const audio = new Audio(soundUrl);
        audio.play({ playbackMode: 'background' })
          .then(() => { /* Audio started playing successfully*/ }).catch(error => { console.error('Error playing the fart:', error); });
    },


resetDraggables: function () {
        const leftNameContainer = document.getElementById('left-name-container');
        const rightNameContainer = document.getElementById('right-name-container');
        const dropOne = document.getElementById('drop-1');
        const dropTwo = document.getElementById('drop-2');
        
        // Move draggables back to the names container
        leftNameContainer.appendChild(document.getElementById('left-name'));
        rightNameContainer.appendChild(document.getElementById('right-name'));
        
        // Clear drop zones
        dropOne.innerHTML = ''; dropTwo.innerHTML = '';
    },

}; // const utils

export default utils;

==> ./version.js <==
// version.js
const version = '1.3.9';

function updateVersion() {
    const noCacheFiles = document.querySelectorAll('link[rel="stylesheet"], link[rel="preload"], script[src], link[rel="manifest"]');
    noCacheFiles.forEach(element => {
        const url = new URL(element.href || element.src);
        url.searchParams.set('v', version);
        if (element.href) {
            element.href = url.toString();
        } else {
            element.src = url.toString();
        }
    });
}

document.addEventListener('DOMContentLoaded', updateVersion);
