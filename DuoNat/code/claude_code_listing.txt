
# index.html

<!DOCTYPE html>
<html lang="en">
<head>
    <title>DuoNat • iNat Taxonomy Trainer</title>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta http-equiv="Cache-Control" content="no-cache">

    <!-- For iOS devices -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- For Android devices -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#74ac00">

    <!-- cache busting by appending version code. change code in script!-->
    <script src="./code/version.js" defer></script>

    <link rel="manifest" href="./manifest.json">

    <script type="module" src="./code/functions.js" defer></script>

    <link rel="stylesheet" href="./styles/main.css">

    <link rel="icon" href="./images/favicon.png" type="image/png">
  <!--  <link rel="preload" href="./images/icons.svg" as="image" type="image/svg+xml"> -->
</head>

<body>

<!-- Loading screen at app start -->
<div id="loading-screen" class="loading-screen">

    <div class="loading-screen__content">

        <img src="./images/icon-512x512.png" alt="DuoNat logo" class="loading-screen__logo">

        <h1 class="loading-screen__title">
            <span class="loading-screen__title-duo">Duo</span><span class="loading-screen__title-nat">Nat</span>
        </h1>

        <p class="loading-screen__message">Loading amazing creatures...</p>

        <div class="loading-screen__spinner"></div>

    </div>

</div>

<!-- App main screen -->
<div class="game-container">

<div class="image-container" id="image-container-1">
  <img class="image-container__image" src="" alt="Taxon 1 Image" id="image-1">

  <div class="image-container__world-map" id="world-map-1"></div>

  <div class="image-container__drop-zone" id="drop-1"></div>

        <div id="drop-1" class="droppable"></div>

        <div class="image-container__buttons" id="image-buttons-1">
            <!-- enable when functionality added -->
            <!--<button class="image-container__button image-container__button--thumbs-up" id="thumbs-up-1" title="Like this image" data-tooltip="Like this image">
                <svg class="icon"><use href="./images/icons.svg#icon-thumb-up"/></svg>
            </button>
            <button class="image-container__button image-container__button--thumbs-down" id="thumbs-down-1" title="Dislike this image" data-tooltip="Dislike this image">
                <svg class="icon"><use href="./images/icons.svg#icon-thumb-down"/></svg>
            </button>-->
            <button class="icon-button image-container__button image-container__button--info" id="info-button-1" title="Taxon info" aria-label="Taxon info">
                <svg class="icon image-container__button-icon"><use href="./images/icons.svg#icon-info"/></svg>
            </button>
        </div>

</div>

    <div class="name-pair">

        <div class="name-pair__container name-pair__container--left">
            <div id="left-name" class="name-pair__item name-pair__item--draggable" draggable="true"></div>
        </div>

        <div class="name-pair__container name-pair__container--right">
            <div id="right-name" class="name-pair__item name-pair__item--draggable" draggable="true"></div>
        </div>

        <div id="overlay" class="name-pair__overlay">
            <div id="overlay-message" class="name-pair__overlay-message"></div>
        </div>

    </div>

    <div class="image-container" id="image-container-2">
      <img class="image-container__image" src="" alt="Taxon 2 Image" id="image-2">

      <div class="image-container__world-map" id="world-map-2"></div>

      <div class="image-container__drop-zone" id="drop-2"></div>
            <div id="drop-2" class="droppable"></div>

            <div class="image-container__buttons" id="image-buttons-2">
                <!-- enable when functionality added -->
                <!--<button class="icon-button image-container__button image-container__button--thumbs-up" id="thumbs-up-2" title="Like this image" data-tooltip="Like this image">
                    <svg class="icon"><use href="./images/icons.svg#icon-thumb-up"/></svg>
                </button>
                <button class="icon-button image-container__button image-container__button--thumbs-down" id="thumbs-down-2" title="Dislike this image" data-tooltip="Dislike this image">
                    <svg class="icon"><use href="./images/icons.svg#icon-thumb-down"/></svg>
                </button>-->
                <button class="icon-button image-container__button image-container__button--info" id="info-button-2" title="Taxon info" aria-label="Taxon info">
                    <svg class="icon image-container__button-icon"><use href="./images/icons.svg#icon-info"/></svg>
                </button>
            </div>

    </div>

</div> <!-- game-container -->

<!-- overlay buttons on the main screen -->

<button class="icon-button" id="help-button" title="Help" aria-label="Open help dialog">
    <svg class="icon">
        <use href="./images/icons.svg#icon-help"/>
    </svg>
</button>

<!-- Main menu -->
<div class="main-menu">

    <button class="icon-button" id="menu-toggle" title="Menu" aria-label="Open menu">
      <svg class="icon"><use href="./images/icons.svg#icon-menu"/></svg>
    </button>

  <div class="main-menu__dropdown main-menu__dropdown--top">

    <div class="main-menu__item">
      <span class="main-menu__label">Share this pair</span>
      <button class="icon-button" id="share-button" aria-label="Share this pair">
        <svg class="icon"><use href="./images/icons.svg#icon-share"/></svg>
      </button>
    </div>

    <div class="main-menu__item">
      <span class="main-menu__label">Show phylogeny</span>
      <button class="icon-button" id="phylogeny-button" aria-label="Show phylogeny">
<!--      <svg class="icon"><use href="./images/icons.svg#icon-phylogeny"/></svg>-->
        <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z" transform="rotate(90 12 12)"/>
        </svg>
      </button>
    </div>

    <!-- enable when functionality added 
    <div class="main-menu__item">
      <span class="main-menu__label">Like this pair</span>
    <button class="icon-button" id="like-button" aria-label="Like this pair">
      <svg class="icon"><use href="./images/icons.svg#icon-heart"/></svg>
    </button>
    </div>

    <div class="main-menu__item">
      <span class="main-menu__label">Trash this pair</span>
    <button class="icon-button" id="trash-button" aria-label="Trash this pair">
      <svg class="icon"><use href="./images/icons.svg#icon-trash"/></svg>
    </button>
    </div> -->

  </div>

  <div class="main-menu__dropdown main-menu__dropdown--bottom">

    <div class="main-menu__item">
      <span class="main-menu__label">Select new pair</span>
      <button class="icon-button" id="select-pair-button" aria-label="Select new pair">
        <svg class="icon"><use href="./images/icons.svg#icon-list"/></svg>
      </button>
    </div>

    <div class="main-menu__item">
      <span class="main-menu__label">Enter new pair</span>
      <button class="icon-button" id="enter-pair-button" aria-label="Enter new pair">
        <svg class="icon"><use href="./images/icons.svg#icon-plus"/></svg>
      </button>
    </div>

    <div class="main-menu__item">
      <span class="main-menu__label">Random new pair</span>
      <button class="icon-button" id="random-pair-button" aria-label="Random new pair">
        <svg class="icon"><use href="./images/icons.svg#icon-random"/></svg>
      </button>
    </div> 

    <div class="main-menu__item">
      <span class="main-menu__label">Surprise!</span>
      <button class="icon-button" id="surprise-button" aria-label="Surprise!">
        <svg class="icon"><use href="./images/icons.svg#icon-star"/></svg>
      </button>
    </div>

  </div> <!-- bottom-group -->

</div> <!-- main menu -->


<!-- Dialogs, only visible when opened in app: -->
<!-- TODO: these should be in their own files -->

<!-- Help dialog -->
<dialog id="help-dialog">

<button class="dialog-close-button icon" aria-label="Close">×</button>
    <div class="help-dialog-content">
        <div class="help-dialog-header">
            <img src="./images/icon-512x512.png" alt="DuoNat logo" class="help-dialog-logo">
            <h2>
                <span class="duo">Duo</span><span class="nat">Nat</span>
                <br><span class="subtitle">iNat Taxonomy Trainer</span>
            </h2>
        </div>
        <div class="help-content">

            <div class="help-item">
                <svg class="icon"><use href="./images/icons.svg#icon-drag"/></svg>
                <p>Drag name to image</p>
            </div>

            <div class="help-item">
                <svg class="icon"> <use href="./images/icons.svg#icon-left"/></svg>
                <p>Swipe left for new pair</p>
            </div>

            <div class="help-item">
                <svg class="icon"> <use href="./images/icons.svg#icon-menu"/></svg>
                <p>Menu for more</p>
            </div>

            <div id="keyboard-shortcuts" style="display: none;">
                <h3>Keyboard Shortcuts</h3>
                <div class="help-item">
                    <svg class="icon"><use href="./images/icons.svg#icon-keyboard"/></svg>
                    <ul>
                        <li><strong>H</strong> Help</li>
                        <li><strong>G</strong> Show phylogeny graph</li>
                        <li><strong>I</strong> Info for left image</li>
                        <li><strong>O</strong> Info for right image</li>
                        <li><strong>R</strong> Random pair</li>
                        <li><strong>S</strong> Select pair</li>
                        <li><strong>E</strong> Enter pair</li>
                    </ul>
                </div>
            </div>

            <button id="start-tutorial-button">Start Tutorial</button>
            <button id="discord-help-dialog">Join us on Discord</button>
            <div id="version-id"></div>
        </div>
    </div>
</dialog>

<!-- Select pair dialog -->
    <dialog id="select-pair-dialog" class="standard-dialog">
        <div class="dialog-inner">
            <button class="dialog-close-button icon" aria-label="Close">×</button>
            <h3 class="dialog-title">Select Taxon Pair</h3>
            <div class="search-container">
                  <input type="text" id="taxon-search" placeholder="Search taxa..." aria-label="Search taxa">
                  <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                  <button id="clear-search" aria-label="Clear search" style="display: none;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                  </button>
            </div>
            <div id="taxon-pair-list" class="taxon-pair-list">
                <!-- Taxon pairs will be dynamically inserted here -->
            </div>
        </div>
    </dialog>

<!-- Enter pair dialog -->
    <dialog id="enter-pair-dialog" class="standard-dialog">
        <button class="dialog-close-button icon" aria-label="Close">×</button>
        <form method="dialog">
            <h2 class="dialog-title">Enter New Taxon Pair</h2>
            <div>
                <label for="taxon1">Taxon 1:</label>
                <input type="text" id="taxon1" required>
            </div>
            <div>
                <label for="taxon2">Taxon 2:</label>
                <input type="text" id="taxon2" required>
            </div>
            <div id="dialog-message" aria-live="polite"></div>
            <button type="submit" id="submit-dialog">Submit</button>
        </form>
    </dialog>


<!-- Phylogeny dialog -->
<dialog id="phylogeny-dialog" class="standard-dialog">
    <button class="dialog-close-button icon" aria-label="Close">×</button>
    <h3 class="dialog-title">Phylogenetic Relationship</h3>
    <div id="graph-hint" class="graph-hint">Tip: Click on a node to open its iNaturalist page</div>
    <div id="taxa-relationship-graph"></div>
</dialog>


<!-- Info dialog -->
<dialog id="info-dialog" class="info-dialog">

    <button class="dialog-close-button icon" id="info-close-button" aria-label="Close">×</button>
    <div class="info-dialog__header">
        <h2 id="info-dialog-taxon" class="info-dialog__taxon"></h2>
        <p id="info-dialog-vernacular" class="info-dialog__vernacular"></p>
    </div>
    <div id="info-dialog-facts" class="info-dialog__facts"></div>

<div class="info-dialog__buttons">
    <button id="hints-button" class="icon-button info-dialog__button info-dialog__button--hints" title="Hints" aria-label="Show identification hints (TODO)">
<!--    <svg class="icon info-dialog__button--inactive" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M9 21c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-1H9v1zm3-19C8.14 2 5 5.14 5 9c0 2.38 1.19 4.47 3 5.74V17c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-2.26c1.81-1.27 3-3.36 3-5.74 0-3.86-3.14-7-7-7zm2.85 11.1l-.85.6V16h-4v-2.3l-.85-.6C7.8 12.16 7 10.63 7 9c0-2.76 2.24-5 5-5s5 2.24 5 5c0 1.63-.8 3.16-2.15 4.1z"/>
        </svg>-->
<!--        <svg class="info-dialog__button-icon icon"><use href="./images/icons.svg#icon-info"/></svg>-->
    </button>
    <button id="photo-button" class="icon-button info-dialog__button info-dialog__button--photo" title="Photo Page" aria-label="Open iNat photo page">
        <svg class="info-dialog__button-icon icon"><use href="./images/icons.svg#icon-camera"/></svg>
    </button>
    <button id="observation-button" class="icon-button info-dialog__button info-dialog__button--observation" title="Observation page" aria-label="Open iNat observation (TODO)">
<!--        <svg class="info-dialog__button-icon icon info-dialog__button--inactive"><use href="./images/icons.svg#icon-microscope"/></svg>-->
    </button>
    <button id="taxon-button" class="icon-button info-dialog__button info-dialog__button--taxon" title="Taxon page" aria-label="Open taxon page">
        <svg class="info-dialog__button-icon icon"><use href="./images/icons.svg#icon-info"/></svg>
<!--        <svg class="info-dialog__button-icon icon"><use href="./images/icons.svg#icon-taxon"/></svg>-->
    </button>
    <button id="report-button" class="icon-button info-dialog__button info-dialog__button--report" title="Report problem" aria-label="Report problem">
<!--        <svg class="info-dialog__button-icon icon"><use href="./images/icons.svg#icon-report"/></svg>-->
    </button>
</div>

</dialog>


<!-- iNat down dialog -->
<dialog id="inat-down-dialog">
    <button class="dialog-close-button icon" aria-label="Close">×</button>
  <h2 class="dialog-title">iNaturalist Unavailable</h2>
  <p>We're having trouble connecting to iNaturalist. This could be due to maintenance or temporary issues.</p>
  <button id="check-inat-status">Check iNaturalist Status</button>
  <button id="retry-connection">Retry Connection</button>
</dialog>

<div id="swipe-info-message" class="swipe-info-message">New random pair</div>

</body>
</html>



# code/api.js

// iNat API

import logger from './logger.js';
import utils from './utils.js';

let taxonInfo = null;
let ancestryInfo = null;

const handleApiError = (error, context) => {
    logger.error(`API Error in ${context}:`, error);
    throw new Error(`Error in ${context}: ${error.message}`);
};

const api = (() => {
    return {

        loadTaxonInfo: async function() {
            try {
                if (taxonInfo === null) {
                    const response = await fetch('./data/taxonInfo.json');
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    taxonInfo = await response.json();
                }
                return taxonInfo;
            } catch (error) {
                handleApiError(error, 'loadTaxonInfo');
            }
        },

        getVernacularName: async function(taxonName) {
            try {
                const taxonInfo = await this.loadTaxonInfo();
                const taxonData = Object.values(taxonInfo).find(info => info.taxonName.toLowerCase() === taxonName.toLowerCase());
                return taxonData ? utils.capitalizeFirstLetter(taxonData.vernacularName) : '';
            } catch (error) {
                handleApiError(error, 'getVernacularName');
            }
        },

        // fetch from JSON file
       fetchTaxonPairs: async function () {
            try {
                const response = await fetch('./data/taxonPairs.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                handleApiError(error, 'fetchTaxonPairs');
            }
        },

        // for user input of new taxon pairs
        validateTaxon: async function (taxonName) {
            try {
                const response = await fetch(`https://api.inaturalist.org/v1/taxa/autocomplete?q=${encodeURIComponent(taxonName)}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                return data.results.length > 0 ? data.results[0] : null;
            } catch (error) {
                handleApiError(error, 'validateTaxon');
            }
        },

        fetchRandomImage: async function (taxonName) {
            try {
                const images = await this.fetchMultipleImages(taxonName, 12);
                if (images.length === 0) {
                    throw new Error(`No images found for ${taxonName}`);
                }
                const randomIndex = Math.floor(Math.random() * images.length);
                const result = images[randomIndex];
                logger.debug(`Fetched random image for ${taxonName}: ${result}`);
                return result;
            } catch (error) {
                handleApiError(error, 'fetchRandomImage');
            }
        },

        fetchImageMetadata: async function (taxonName, count = 12) {
//            logger.debug(`Fetching metadata for ${count} images of ${taxonName}`);
            try {
                const searchResponse = await fetch(`https://api.inaturalist.org/v1/taxa/autocomplete?q=${taxonName}`);
                const searchData = await searchResponse.json();
                if (searchData.results.length === 0) { throw new Error('Taxon not found'); }
                const taxonId = searchData.results[0].id;

                const taxonResponse = await fetch(`https://api.inaturalist.org/v1/taxa/${taxonId}`);
                const taxonData = await taxonResponse.json();
                if (taxonData.results.length === 0) { throw new Error('No details found for the taxon'); }
                const taxon = taxonData.results[0];

                let images = taxon.taxon_photos.map(photo => photo.photo.url.replace('square', 'medium'));

                const result = images.slice(0, Math.min(count, images.length));
//                logger.debug(`Fetched metadata for ${result.length} images of ${taxonName}`);
                return result;
            } catch (error) {
                logger.error(`Error fetching image metadata for ${taxonName}:`, error);
                return [];
            }
        },

        fetchRandomImageMetadata: async function (taxonName) {
//            logger.debug(`Fetching random image metadata for ${taxonName}`);
            const images = await this.fetchImageMetadata(taxonName, 12); // Fetch metadata for 12 images
            if (images.length === 0) {
                logger.error(`No image metadata found for ${taxonName}`);
                return null;
            }
            const randomIndex = Math.floor(Math.random() * images.length);
            const result = images[randomIndex];
//            logger.debug(`Selected random image metadata for ${taxonName}: ${result}`);
            return result;
        },

        async fetchMultipleImages(taxonName, count = 12) {
            try {
                const searchResponse = await fetch(`https://api.inaturalist.org/v1/taxa/autocomplete?q=${taxonName}`);
                if (!searchResponse.ok) throw new Error(`HTTP error! status: ${searchResponse.status}`);
                const searchData = await searchResponse.json();
                if (searchData.results.length === 0) throw new Error('Taxon not found');
                const taxonId = searchData.results[0].id;

                const taxonResponse = await fetch(`https://api.inaturalist.org/v1/taxa/${taxonId}?photos=true`);
                if (!taxonResponse.ok) throw new Error(`HTTP error! status: ${taxonResponse.status}`);
                const taxonData = await taxonResponse.json();
                if (taxonData.results.length === 0) throw new Error('No details found for the taxon');
                const taxon = taxonData.results[0];

                let images = taxon.taxon_photos.map(photo => photo.photo.url.replace('square', 'medium'));

                images = [...new Set(images)];
                images = images.sort(() => Math.random() - 0.5);

                return images.slice(0, Math.min(count, images.length));

            } catch (error) {
                handleApiError(error, 'fetchMultipleImages');
            }
        },

        // fetch vernacular name of taxon from local file or iNat
        fetchVernacular: async function (taxonName) {
          const taxonInfo = await this.loadTaxonInfo();
          
          // Find the entry with matching taxonName
          const entry = Object.values(taxonInfo).find(info => info.taxonName.toLowerCase() === taxonName.toLowerCase());
          
          if (entry && entry.vernacularName) {
            return entry.vernacularName;
          } else {
            logger.warn(`Vernacular name not found for ${taxonName} in local data`);
            // Optionally, you can still fallback to the API if not found locally
            return this.fetchVernacularFromAPI(taxonName);
          }
        },

        fetchVernacularFromAPI: async function (taxonName) {
            logger.debug("fetching vernacular from iNat");
            try {
                const baseUrl = 'https://api.inaturalist.org/v1/taxa/autocomplete';
                const response = await fetch(`${baseUrl}?q=${encodeURIComponent(taxonName)}`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                if (data.results && data.results.length > 0) {
                    const taxon = data.results[0];
                    return taxon.preferred_common_name || null;
                } else {
                    return null;
                }
            } catch (error) {
                handleApiError(error, 'fetchVernacularFromAPI');
            }
        },

        // function to check if iNaturalist API is reachable
        isINaturalistReachable: async function () {
            try {
                const response = await fetch('https://api.inaturalist.org/v1/taxa?q=test');
                return response.ok;
            } catch (error) {
                logger.error('Error pinging iNaturalist API:', error);
                return false;
            }
        },

        fetchTaxonId: async function (taxonName) {
            try {
                logger.debug(`Fetching taxon ID for ${taxonName}`);
                const response = await fetch(`https://api.inaturalist.org/v1/taxa/autocomplete?q=${encodeURIComponent(taxonName)}&per_page=1`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                if (data.results.length === 0) throw new Error(`Taxon not found: ${taxonName}`);
                logger.debug(`Taxon ID for ${taxonName}:`, data.results[0].id);
                return data.results[0].id;
            } catch (error) {
                handleApiError(error, 'fetchTaxonId');
            }
        },

        fetchTaxonDetails: async function (name) {
            try {
                const response = await fetch(`https://api.inaturalist.org/v1/taxa/autocomplete?q=${encodeURIComponent(name)}&per_page=1&all_names=true`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                if (data.results.length === 0) throw new Error(`Taxon not found: ${name}`);
                logger.debug('Fetched taxon details:', data.results[0]);
                return data.results[0];
            } catch (error) {
                handleApiError(error, 'fetchTaxonDetails');
            }
        },

        loadAncestryInfo: async function() {
            try {
                if (ancestryInfo === null) {
                    const response = await fetch('./data/ancestryInfo.json');
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    ancestryInfo = await response.json();
                }
                return ancestryInfo;
            } catch (error) {
                handleApiError(error, 'loadAncestryInfo');
            }
        },

        async getAncestryFromLocalData(taxonName) {
            const taxonInfo = await this.loadTaxonInfo();
            const taxonData = Object.values(taxonInfo).find(info => info.taxonName.toLowerCase() === taxonName.toLowerCase());
            return taxonData ? taxonData.ancestryIds.map(id => parseInt(id)) : [];
        },

        fetchAncestorDetails: async function (ancestorIds) {
            try {
                const ancestorDetails = new Map();
                const localAncestryInfo = await this.loadAncestryInfo();

                for (const id of ancestorIds) {
                    const localData = localAncestryInfo[id];
                    if (localData) {
                        ancestorDetails.set(id, {
                            id: parseInt(id),
                            name: localData.taxonName,
                            rank: localData.rank,
                            preferred_common_name: localData.vernacularName
                        });
                        logger.debug(`Using local ancestry data for ID ${id}:`, localData);
                    } else {
                        const response = await fetch(`https://api.inaturalist.org/v1/taxa/${id}`);
                        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                        const data = await response.json();
                        if (data.results.length > 0) {
                            ancestorDetails.set(id, data.results[0]);
                            logger.debug(`Fetched ancestry data from iNat for ID ${id}:`, data.results[0]);
                        }
                    }
                }
                return ancestorDetails;
            } catch (error) {
                handleApiError(error, 'fetchAncestorDetails');
            }
        },

    };

})();

export default api;



# code/config.js

// Configuration

const config = {

    // overlay colors
    overlayColors: {
        green: "rgba(116, 172, 0, 1.0)", /* iNat green */
        red: "rgba(172, 0, 40, 1.0)",
        gray: "rgba(100, 100, 100, 0.8)"
    },
    debug: true, // set to false for less console output
    enablePreloading: false // Set to false to disable preloading
};

export default config;



# code/eventHandlers.js

// Event handlers

import api from './api.js';
import dialogManager from './dialogManager.js';
import dragAndDrop from './dragAndDrop.js';
import game from './game.js';
import logger from './logger.js';
import { elements, gameState } from './state.js';
import ui from './ui.js';
import utils from './utils.js';

const eventHandlers = {

    // global variables for swiping left
    startX: 0,
    endX: 0,
    isDragging: false,
    gameContainer: null,
    touchStartX: 0,
    touchStartY: 0,
    touchEndX: 0,
    touchEndY: 0,

    swipeThreshold: 50, // minimum distance to trigger a swipe
    swipeRestraint: 100, // maximum vertical distance allowed during a swipe

    isLoadingNewPair: false,

    initialize() {
        this.initializeSwipeFunctionality();
        this.initializeMainMenuListeners();
        this.initializeAllEventListeners();

        this.debouncedKeyboardHandler = utils.debounce(this._handleKeyboardShortcuts.bind(this), 300);

        // Ensure keyboard shortcuts are properly set up
        document.removeEventListener('keydown', this.debouncedKeyboardHandler);
        document.addEventListener('keydown', this.debouncedKeyboardHandler);
    },

initializeSwipeFunctionality() {
    this.gameContainer = document.querySelector('.game-container');
    if (!this.gameContainer) {
        logger.error('Game container not found');
        return;
    }

    [elements.imageOneContainer, elements.imageTwoContainer].forEach((container, index) => {
        container.addEventListener('mousedown', (e) => {
            this.handleMouseDown(e);
        });
        container.addEventListener('touchstart', (e) => {
            this.handleTouchStart(e);
        }, { passive: true });
        container.addEventListener('mousemove', (e) => {
            this.handleDragMove(e);
        });
        container.addEventListener('touchmove', (e) => {
            this.handleDragMove(e);
        }, { passive: true });
        container.addEventListener('mouseup', (e) => {
            this.handleSwipeOrDrag(e);
        });
        container.addEventListener('touchend', (e) => {
            this.handleSwipeOrDrag(e);
        });
    });

},

    safeAddEventListener(id, eventType, handler) {
        const element = document.getElementById(id);
        if (element) {
            element.addEventListener(eventType, handler);
        } else {
            logger.debug(`Element with id '${id}' not found. Skipping event listener.`);
        }
    },

    initializeMainMenuListeners: function() {
        this.safeAddEventListener('share-button', 'click', () => {
            this.shareCurrentPair();
            ui.closeMainMenu(); // Close menu after action
        });
        this.safeAddEventListener('phylogeny-button', 'click', () => {
            game.showTaxaRelationship();
            ui.closeMainMenu(); // Close menu after action
        });
        this.safeAddEventListener('select-pair-button', 'click', () => {
            ui.showTaxonPairList();
            ui.closeMainMenu(); // Close menu after action
        });
        this.safeAddEventListener('enter-pair-button', 'click', () => {
            dialogManager.openDialog('enter-pair-dialog');
            ui.closeMainMenu(); // Close menu after action
        });
        this.safeAddEventListener('random-pair-button', 'click', () => {
            game.loadNewRandomPair();
            ui.closeMainMenu(); // Close menu after action
        });
        this.safeAddEventListener('like-button', 'click', () => {
            this.likePair();
            ui.closeMainMenu(); // Close menu after action
        });
        this.safeAddEventListener('trash-button', 'click', () => {
            this.trashPair();
            ui.closeMainMenu(); // Close menu after action
        });
        this.safeAddEventListener('surprise-button', 'click', () => {
            utils.surprise();
            ui.closeMainMenu(); // Close menu after action
        });
    },

    initializeAllEventListeners() {
        dragAndDrop.initialize();

        // touch events
        [elements.imageOneContainer, elements.imageTwoContainer].forEach(container => {
            container.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: true });
            container.addEventListener('touchend', this.handleImageInteraction.bind(this));
            container.addEventListener('mousedown', this.handleMouseDown.bind(this));
            container.addEventListener('mouseup', this.handleImageInteraction.bind(this));
        });

        ['1', '2'].forEach(index => {
            this.safeAddEventListener(`thumbs-up-${index}`, 'click', () => this.handleThumbsUp(index));
            this.safeAddEventListener(`thumbs-down-${index}`, 'click', () => this.handleThumbsDown(index));
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', this.debouncedKeyboardHandler);

        // Help button functionality
        document.getElementById('help-button').addEventListener('click', () => {
            dialogManager.openDialog('help-dialog');
        });
        document.getElementById('start-tutorial-button').addEventListener('click', () => {
            ui.showTutorial();
        });
        document.getElementById('discord-help-dialog').addEventListener('click', () => {
            window.open('https://discord.gg/DcWrhYHmeM', '_blank');
        });

    },

    handleThumbsUp(index) {
        // Implement thumbs up functionality
        logger.debug(`Thumbs up clicked for image ${index}`);
        // Add your implementation here
    },

    handleThumbsDown(index) {
        // Implement thumbs down functionality
        logger.debug(`Thumbs down clicked for image ${index}`);
        // Add your implementation here
    },

    handleMouseDown(e) {
        if (!e.target.closest('.image-container') || e.target.closest('.info-button')) return;
        if (e.target.closest('.name-pair__item--draggable')) return; // Ignore draggable elements
        this.startX = e.clientX;
        this.startY = e.clientY;
        this.isDragging = true;
    },

    handleTouchStart(e) {
        
        if (!e.target.closest('.image-container') || e.target.closest('.info-button')) {
            return;
        }
        
        this.startX = e.touches[0].clientX;
        this.startY = e.touches[0].clientY;
        this.isDragging = true;
    },

    handleSwipeOrDrag(e) {
        if (!this.isDragging) return;

        let endX, endY;
        if (e.type.includes('touch')) {
            endX = e.changedTouches[0].clientX;
            endY = e.changedTouches[0].clientY;
        } else {
            endX = e.clientX;
            endY = e.clientY;
        }

        const deltaX = this.startX - endX;
        const deltaY = Math.abs(this.startY - endY);

    if (deltaX > this.swipeThreshold && deltaY < this.swipeRestraint) {
        // Swipe left detected
        document.querySelector('.game-container').classList.add('swipe-out-left');

        // Hide the swipe info message
        const swipeInfoMessage = document.getElementById('swipe-info-message');
        swipeInfoMessage.style.opacity = 0;

        setTimeout(() => {
            document.querySelector('.game-container').classList.remove('swiping-left', 'swipe-out-left');
            ui.resetGameContainerStyle();
            game.loadNewRandomPair();
        }, 500); // Match this with the animation duration
    } else {
        // Reset if not swiped far enough or swiped vertically
        ui.resetGameContainerStyle();

        // Hide the swipe info message
        const swipeInfoMessage = document.getElementById('swipe-info-message');
        swipeInfoMessage.style.opacity = 0;
    }

    this.isDragging = false;
    },

    handleDragMove(e) {
        if (!this.isDragging) return;

        let currentX, currentY;
        if (e.type.includes('touch')) {
            currentX = e.touches[0].clientX;
            currentY = e.touches[0].clientY;
        } else {
            currentX = e.clientX;
            currentY = e.clientY;
        }

        const deltaX = this.startX - currentX;
        const deltaY = Math.abs(this.startY - currentY);

        if (deltaX > 0 && deltaY < this.swipeRestraint) {
            const progress = Math.min(deltaX / 100, 1);
            const rotation = progress * -5;
            const opacity = 1 - progress * 0.5;

            this.gameContainer.style.transform = `rotate(${rotation}deg) translateX(${-deltaX}px)`;
            this.gameContainer.style.opacity = opacity;

            // Update the swipe info message
            const swipeInfoMessage = document.getElementById('swipe-info-message');
            swipeInfoMessage.style.opacity = progress.toFixed(2); // Fade in smoothly
        }
    },

    handleImageInteraction(event) {
        if (!event) return;  // handle cases where event is undefined
        // Add any specific image interaction logic here
    },

    showTaxonPairList() {
        api.fetchTaxonPairs().then(taxonPairs => {
            ui.showTaxonPairList(taxonPairs, (selectedPair) => {
                game.nextSelectedPair = selectedPair;
                game.setupGame(true);
            });
        });
    },

    _handleKeyboardShortcuts(event) {
//        logger.debug("Keyboard event:", event.key);
        if (dialogManager.isAnyDialogOpen() || 
            document.getElementById('info-dialog').open || 
            dialogManager.activeDialog || 
            document.getElementById('enter-pair-dialog').open) {
//            logger.debug("Dialog is open, ignoring keyboard shortcut");
            return;
        }

        switch (event.key.toLowerCase()) {
            case 'r':
            case 'arrowleft':
                if (!this.isLoadingNewPair) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.isLoadingNewPair = true;
                    game.loadNewRandomPair().finally(() => {
                        this.isLoadingNewPair = false;
                    });
                }
                break;
            case 'arrowup':
                event.preventDefault();
                this.moveTileToDropZone('left', 'upper');
                break;
            case 'arrowdown':
                event.preventDefault();
                this.moveTileToDropZone('left', 'lower');
                break;
            case 's':
                event.preventDefault();
                ui.showTaxonPairList();
                break;
            case 'h':
                event.preventDefault();
                document.getElementById('help-button').click();
                break;
            case 'e':
                event.preventDefault();
                dialogManager.openDialog('enter-pair-dialog');
                break;
            case 'm':
                event.preventDefault();
                ui.toggleMainMenu();
                break;
            case 'p':
                event.preventDefault();
                document.getElementById('surprise-button').click();
                break;
            case 'g':
                event.preventDefault();
                game.showTaxaRelationship();
                break;
            case 'i':
                event.preventDefault();
                game.showInfoDialog(game.currentObservationURLs.imageOne, 1);
                break;
            case 'o':
                event.preventDefault();
                game.showInfoDialog(game.currentObservationURLs.imageTwo, 2);
                break;
            case 'w':
                // createWorldMap.toggleAllWorldMaps();
                // TODO need to find a way to trigger from here
                break;
        }
    },

    moveTileToDropZone(tilePosition, dropZonePosition) {
        const tile = document.getElementById(tilePosition === 'left' ? 'left-name' : 'right-name');
        const dropZone = document.getElementById(dropZonePosition === 'upper' ? 'drop-1' : 'drop-2');
        
        if (tile && dropZone) {
            // Remove the tile from its current position
            tile.parentNode.removeChild(tile);
            
            // Clear the drop zone and add the tile
            dropZone.innerHTML = '';
            dropZone.appendChild(tile);
            
            // Highlight the moved tile
            //ui.highlightTile(tile.id);
            
            // Trigger the answer check using the game's checkAnswer method
            game.checkAnswer(dropZone.id);
        }
    },

    // move to other module, utils?
    shareCurrentPair() {
        let currentUrl = new URL(window.location.href);
        currentUrl.searchParams.delete('taxon1');
        currentUrl.searchParams.delete('taxon2');
        currentUrl.searchParams.set('taxon1', gameState.taxonImageOne);
        currentUrl.searchParams.set('taxon2', gameState.taxonImageTwo);
        let shareUrl = currentUrl.toString();

        navigator.clipboard.writeText(shareUrl).then(() => { }).catch(err => {
            logger.error('Failed to copy: ', err);
            alert('Failed to copy link. Please try again.');
        });
    },

    likePair: function() {
        // Implement liking functionality
        logger.debug('Like pair clicked');
        // Add your implementation here
    },

    trashPair: function() {
        // Implement trashing functionality
        logger.debug('Trash pair clicked');
        // Add your implementation here
    },

};

export default eventHandlers;



# code/functions.js

import api from './api.js';
import config from './config.js';
import dialogManager from './dialogManager.js';
import { elements, gameState } from './state.js';
import eventHandlers from './eventHandlers.js';
import game from './game.js';
import logger, { LogLevel } from './logger.js';
import tooltipManager from './tooltipManager.js';
import ui from './ui.js';
import utils from './utils.js';

(function () {

    // Set the log level based on your config
    logger.setLevel(config.debug ? LogLevel.DEBUG : LogLevel.INFO);
    document.getElementById('version-id').innerHTML = `Version: <i>${document.lastModified}</i>`;

    function initializeApp() {
        logger.info("Initializing app");

        // Check for URL parameters
        const urlParams = utils.getURLParameters();
        if (urlParams) {
            logger.debug("URL parameters found:", urlParams);
            game.nextSelectedPair = urlParams;
        }

        dialogManager.initializeDialogs();
        game.setupGame(true);
        eventHandlers.initialize();
        ui.initialize();
        // tooltipManager.init(); /* need to remove bugs first */
        logger.info("App initialization complete");

        // Example of changing log level at runtime
        // Uncomment this line to test changing log level
        // logger.changeLogLevel(LogLevel.WARN);
    }

    // Expose initializeApp to the global scope
    window.initializeApp = initializeApp;

    // Call initialization function
    window.addEventListener('DOMContentLoaded', (event) => {
        window.initializeApp();
    });
})();




# code/game.js

import api from './api.js';
import config from './config.js';
import dialogManager from './dialogManager.js';
import { elements, gameState, updateGameState, GameState } from './state.js';
import logger from './logger.js';
import preloader from './preloader.js';
import taxaRelationshipViewer from './taxaRelationshipViewer.js';
import ui from './ui.js';
import utils from './utils.js';
import { createWorldMap } from './worldMap.js';

const game = {
    loadingMessage: "",
    //loadingMessage: "Loading...",
    nextSelectedPair: null,
    currentState: GameState.IDLE,
    currentGraphTaxa: null,
    preloadedPair: null,
    preloadedImages: {
        current: {
            taxon1: [],
            taxon2: []
        },
        next: {
            taxon1: [],
            taxon2: []
        }
    },

    currentObservationURLs: {
        imageOne: null,
        imageTwo: null
    },

    setState(newState) {
        this.currentState = newState;
    },

    showLoadingScreen: function () {
        document.getElementById('loading-screen').style.display = 'flex';
    },

    hideLoadingScreen: function () {
        setTimeout(() => {
            document.getElementById('loading-screen').style.display = 'none';
        }, 500); // 500ms delay, adjust as needed
    },

    async setupGame(newPair = false) {
        this.setState(GameState.LOADING);

        if (!await this.checkINaturalistReachability()) { return; }

        this.prepareUIForLoading();

        try {
            if (newPair || !gameState.currentTaxonImageCollection) {
                await this.initializeNewPair();
            } else {
                await this.setupRound();
            }

            this.finishSetup();
            
            // Call setNamePairHeight here, after the new pair or round is set up
            this.setNamePairHeight();

            // Preload for the next round
            preloader.preloadForNextRound();

            // Only preload for next pair if we don't have one already
            if (!preloader.hasPreloadedPair()) {
                preloader.preloadForNextPair();
            }

            this.setState(GameState.PLAYING);
            this.hideLoadingScreen();

            if (gameState.isInitialLoad) {
                updateGameState({ isInitialLoad: false });
            }

            ui.hideOverlay();
            ui.resetUIState();
        } catch (error) {
            this.handleSetupError(error);
        }
    },

    async initializeNewPair() {
        let newPair, imageOneURL, imageTwoURL;

        if (this.nextSelectedPair) {
            // Use the manually selected pair if available
            newPair = this.nextSelectedPair;
            this.nextSelectedPair = null; // Clear the selected pair after use
            [imageOneURL, imageTwoURL] = await Promise.all([
                api.fetchRandomImageMetadata(newPair.taxon1),
                api.fetchRandomImageMetadata(newPair.taxon2)
            ]);
        } else {
            // Use preloaded pair if available, otherwise fetch a new random pair
            const preloadedPair = preloader.getPreloadedImagesForNextPair();
            if (preloadedPair && preloadedPair.pair) {
                newPair = preloadedPair.pair;
                imageOneURL = preloadedPair.taxon1;
                imageTwoURL = preloadedPair.taxon2;
            } else {
                newPair = await utils.selectTaxonPair();
                [imageOneURL, imageTwoURL] = await Promise.all([
                    api.fetchRandomImageMetadata(newPair.taxon1),
                    api.fetchRandomImageMetadata(newPair.taxon2)
                ]);
            }
        }

        updateGameState({
            currentTaxonImageCollection: {
                pair: newPair,
                imageOneURL,
                imageTwoURL
            },
            usedImages: {
                taxon1: new Set([imageOneURL]),
                taxon2: new Set([imageTwoURL])
            }
        });

        await this.setupRound(true);
    },

    async setupRound(isNewPair = false) {
        const { pair } = gameState.currentTaxonImageCollection;
        const randomized = Math.random() < 0.5;

        let imageOneURL, imageTwoURL;

        if (isNewPair) {
            imageOneURL = gameState.currentTaxonImageCollection.imageOneURL;
            imageTwoURL = gameState.currentTaxonImageCollection.imageTwoURL;
        } else {
            const preloadedImages = preloader.getPreloadedImagesForNextRound();
            if (preloadedImages && preloadedImages.taxon1 && preloadedImages.taxon2) {
                imageOneURL = preloadedImages.taxon1;
                imageTwoURL = preloadedImages.taxon2;
            } else {
                [imageOneURL, imageTwoURL] = await Promise.all([
                    preloader.fetchDifferentImage(pair.taxon1, gameState.currentRound.imageOneURL),
                    preloader.fetchDifferentImage(pair.taxon2, gameState.currentRound.imageTwoURL)
                ]);
            }
        }

        const leftImageSrc = randomized ? imageOneURL : imageTwoURL;
        const rightImageSrc = randomized ? imageTwoURL : imageOneURL;

        await this.loadImages(leftImageSrc, rightImageSrc);

  // Set the observation URLs
    this.currentObservationURLs.imageOne = this.getObservationURLFromImageURL(leftImageSrc);
    this.currentObservationURLs.imageTwo = this.getObservationURLFromImageURL(rightImageSrc);

    const [leftVernacular, rightVernacular] = await Promise.all([
        utils.capitalizeFirstLetter(await api.fetchVernacular(randomized ? pair.taxon1 : pair.taxon2)),
        utils.capitalizeFirstLetter(await api.fetchVernacular(randomized ? pair.taxon2 : pair.taxon1))
    ]);

    this.setupNameTilesUI(
        randomized ? pair.taxon1 : pair.taxon2,
        randomized ? pair.taxon2 : pair.taxon1,
        leftVernacular,
        rightVernacular
    );

    // Add world maps
    const leftContinents = await this.getContinentForTaxon(randomized ? pair.taxon1 : pair.taxon2);
    const rightContinents = await this.getContinentForTaxon(randomized ? pair.taxon2 : pair.taxon1);
    createWorldMap(elements.imageOneContainer, leftContinents);
    createWorldMap(elements.imageTwoContainer, rightContinents);

        updateGameState({
            taxonImageOne: randomized ? pair.taxon1 : pair.taxon2,
            taxonImageTwo: randomized ? pair.taxon2 : pair.taxon1,
            currentRound: {
                pair,
                imageOneURL,
                imageTwoURL,
                imageOneVernacular: leftVernacular,
                imageTwoVernacular: rightVernacular,
                randomized
            }
        });

    },

    async getContinentForTaxon(taxon) {
        const taxonInfo = await api.loadTaxonInfo();
        const taxonData = Object.values(taxonInfo).find(info => info.taxonName.toLowerCase() === taxon.toLowerCase());
        
        if (taxonData && taxonData.distribution && taxonData.distribution.length > 0) {
            // Convert the continent codes to full names
            const continentMap = {
                'NA': 'North America',
                'SA': 'South America',
                'EU': 'Europe',
                'AS': 'Asia',
                'AF': 'Africa',
                'OC': 'Oceania'
            };
            
            // Convert all continent codes to full names
            const fullContinents = taxonData.distribution.map(code => continentMap[code]);
            
            return fullContinents;
        } else {
            logger.debug(`No distribution data found for ${taxon}. Using placeholder.`);
            return ['North America', 'South America', 'Europe', 'Africa', 'Asia', 'Oceania'];
        }
    },

    async checkINaturalistReachability() {
        if (!await api.isINaturalistReachable()) {
            ui.showINatDownDialog();
            this.setState(GameState.IDLE);
            return false;
        }
        ui.hideINatDownDialog();
        return true;
    },

    async fetchTaxonImageCollection(newPair) {
        let attempts = 0;
        const maxAttempts = 3;

        while (attempts < maxAttempts) {
            try {
                return await this.attemptFetchTaxonImageCollection(newPair);
            } catch (error) {
                attempts++;
                if (this.shouldRetryFetch(error, attempts, maxAttempts)) {
                    await this.handleFetchError(error);
                } else {
                    throw error;
                }
            }
        }

        throw new Error("Failed to load images after multiple attempts");
    },

    async attemptFetchTaxonImageCollection(newPair) {
        if (newPair || !gameState.currentTaxonImageCollection) {
            if (this.nextSelectedPair) {
                const collection = await this.initializeNewTaxonPair(this.nextSelectedPair);
                this.nextSelectedPair = null;
                return collection;
            } else if (this.preloadedPair) {
                const collection = this.preloadedPair;
                this.preloadedPair = null;
                return collection;
            } else {
                return await this.initializeNewTaxonPair();
            }
        }
        return gameState.currentTaxonImageCollection;
    },

    shouldRetryFetch(error, attempts, maxAttempts) {
        return attempts < maxAttempts && error.message.includes("No images found");
    },

    async handleFetchError(error) {
        if (error.message.includes("No images found")) {
            const taxonName = error.message.split("No images found for ")[1];
            ui.showOverlay(`Warning: No images found for ${taxonName}. Trying another pair...`, config.overlayColors.red);
            await utils.sleep(2000);
            this.nextSelectedPair = null;
        }
    },

    handleSetupError(error) {
        logger.error("Error setting up game:", error);
        ui.showOverlay("Error loading game. Please try again.", config.overlayColors.red);
        this.setState(GameState.IDLE);
        if (gameState.isInitialLoad) {
            this.hideLoadingScreen();
            updateGameState({ isInitialLoad: false });
        }
    },

    async initializeNewTaxonPair(pair = null) {

        const newPair = pair || await utils.selectTaxonPair();
        const [imageOneURL, imageTwoURL] = await Promise.all([
            api.fetchRandomImage(newPair.taxon1),
            api.fetchRandomImage(newPair.taxon2)
        ]);

        return {
            pair: newPair,
            imageOneURL,
            imageTwoURL,
            imageOneVernacular: null,
            imageTwoVernacular: null
        };
    },

    async loadCurrentTaxonImageCollection() {
        if (!gameState.currentTaxonImageCollection || !gameState.currentTaxonImageCollection.pair) {
            logger.error("currentTaxonImageCollection or its pair is null");
            throw new Error("Invalid currentTaxonImageCollection");
        }

        const { taxon1, taxon2 } = gameState.currentTaxonImageCollection.pair;
        // TODO not sure if for one or both pairs? one taxon should not have more than 12 images
        const MAX_IMAGES = 24; // Adjust this number as needed

        const [imageOneURLs, imageTwoURLs, imageOneVernacular, imageTwoVernacular] = await Promise.all([
            api.fetchMultipleImages(taxon1),
            api.fetchMultipleImages(taxon2),
            api.fetchVernacular(taxon1),
            api.fetchVernacular(taxon2)
        ]);

        updateGameState({
            currentTaxonImageCollection: {
                ...gameState.currentTaxonImageCollection,
                imageOneURLs: imageOneURLs.slice(0, MAX_IMAGES),
                imageTwoURLs: imageTwoURLs.slice(0, MAX_IMAGES),
                imageOneVernacular,
                imageTwoVernacular
            }
        });

        await preloader.preloadImages(imageOneURLs.slice(0, MAX_IMAGES).concat(imageTwoURLs.slice(0, MAX_IMAGES)));
    },

    async preloadImagesForCurrentPair() {
        const { pair } = gameState.currentTaxonImageCollection;

        try {
            const [newImageOneURL, newImageTwoURL] = await Promise.all([
                api.fetchRandomImageMetadata(pair.taxon1),
                api.fetchRandomImageMetadata(pair.taxon2)
            ]);

            await Promise.all([
                this.preloadImage(newImageOneURL),
                this.preloadImage(newImageTwoURL)
            ]);

            this.preloadedImages.current.taxon1.push(newImageOneURL);
            this.preloadedImages.current.taxon2.push(newImageTwoURL);

        } catch (error) {
            logger.error("Error preloading images for current pair:", error);
        }
    },

    preloadImage(url) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                resolve(url);
            };
            img.onerror = () => {
                logger.error(`Failed to load image: ${url}`);
                reject(url);
            };
            img.src = url;
        });
    },

    loadImages: async function (leftImageSrc, rightImageSrc) {
        await Promise.all([
            this.loadImageAndRemoveLoadingClass(elements.imageOne, leftImageSrc),
            this.loadImageAndRemoveLoadingClass(elements.imageTwo, rightImageSrc)
        ]);
    },

    async loadImageAndRemoveLoadingClass(imgElement, src) {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
                imgElement.src = src;
                imgElement.classList.remove('image-container__image--loading');
                // Add a slight delay before adding the 'loaded' class
                setTimeout(() => {
                    imgElement.classList.add('image-container__image--loaded');
                    resolve();
                }, 50); // 50ms delay to ensure the browser has time to apply the new src
            };
            img.src = src;
        });
    },

    async showTaxaRelationship() {
        const { taxonImageOne, taxonImageTwo } = gameState;
        const container = document.getElementById('taxa-relationship-graph');
        const dialog = document.getElementById('phylogeny-dialog');

        if (!taxonImageOne || !taxonImageTwo) {
            logger.error('Taxon names not available');
            alert('Unable to show relationship. Please try again after starting a new game.');
            return;
        }

        // Show the dialog
        dialog.style.display = 'flex'; // Change to flex to match the CSS layout
        dialogManager.openDialog('phylogeny-dialog');

        try {
            await taxaRelationshipViewer.initialize(container);

            if (this.currentGraphTaxa &&
                this.currentGraphTaxa[0] === taxonImageOne &&
                this.currentGraphTaxa[1] === taxonImageTwo) {
                logger.debug("Showing existing graph for the same taxa pair");
                taxaRelationshipViewer.showExistingGraph();
            } else {
                logger.debug("Creating new graph for a different taxa pair");
                taxaRelationshipViewer.clearGraph();
                await taxaRelationshipViewer.findRelationship(taxonImageOne, taxonImageTwo);
                this.currentGraphTaxa = [taxonImageOne, taxonImageTwo];
            }
        } catch (error) {
            logger.error('Error showing taxa relationship:', error);
            alert('Failed to load the relationship graph. Please try again later.');
            dialog.style.display = 'none'; // Hide the dialog on error
            dialogManager.closeDialog();
        }
    },

    prepareUIForLoading: function () {
        utils.resetDraggables();
        elements.imageOne.classList.add('image-container__image--loading');
        elements.imageTwo.classList.add('image-container__image--loading');
        var startMessage = gameState.isFirstLoad ? "Drag the names!" : `${this.loadingMessage}`;
        ui.showOverlay(startMessage, config.overlayColors.green);
        // what does this do?
        gameState.isFirstLoad = false;
    },

    async loadNewRandomPair() {
        if (this.currentState === GameState.LOADING) {
            logger.debug("Already loading a new pair, ignoring request");
            return;
        }

        logger.debug("Loading new random pair");
        this.setState(GameState.LOADING);
        ui.showOverlay(`${this.loadingMessage}`, config.overlayColors.green);
        elements.imageOne.classList.add('image-container__image--loading');
        elements.imageTwo.classList.add('image-container__image--loading');

        try {
            this.nextSelectedPair = null; // Ensure we're not using a previously selected pair
            await this.setupGame(true);
            ui.hideOverlay();
        } catch (error) {
            logger.error("Error loading new random pair:", error);
            ui.showOverlay("Error loading new pair. Please try again.", config.overlayColors.red);
        } finally {
            this.setState(GameState.PLAYING);
        }
    },

    // Update this method to set the nextSelectedPair
    async loadNewTaxonPair(newPair) {
        this.nextSelectedPair = newPair;
        await this.setupGame(true);
    },

    checkAnswer(droppedZoneId) {
        logger.debug("Checking answer. Current state:", this.currentState);

        if (this.currentState !== GameState.PLAYING) {
            logger.debug("Cannot check answer when not in PLAYING state");
            return;
        }

        this.setState(GameState.CHECKING);

        const dropOne = document.getElementById('drop-1');
        const dropTwo = document.getElementById('drop-2');
        const colorCorrect = config.overlayColors.green;
        const colorWrong = config.overlayColors.red;

        const leftAnswer = dropOne.children[0]?.getAttribute('data-taxon');
        const rightAnswer = dropTwo.children[0]?.getAttribute('data-taxon');

        if (leftAnswer || rightAnswer) {
            let isCorrect = false;
            if (droppedZoneId === 'drop-1') {
                isCorrect = leftAnswer === gameState.taxonImageOne;
            } else {
                isCorrect = rightAnswer === gameState.taxonImageTwo;
            }

            if (isCorrect) {
                this.handleCorrectAnswer();
            } else {
                this.handleIncorrectAnswer();
            }
        } else {
            logger.debug("Incomplete answer. Returning to PLAYING state.");
            this.setState(GameState.PLAYING);
        }
    },

    async handleCorrectAnswer() {
        await ui.showOverlay('Correct!', config.overlayColors.green);
        elements.imageOne.classList.add('image-container__image--loading');
        elements.imageTwo.classList.add('image-container__image--loading');
        await utils.sleep(2000); // Show "Correct!" for a while
        ui.updateOverlayMessage(`${this.loadingMessage}`); // Update message without changing color
        await this.setupGame(false);  // Start a new round with the same taxon pair
    },

    async handleIncorrectAnswer() {
        utils.resetDraggables();
        await ui.showOverlay('Try again!', config.overlayColors.red);
        await utils.sleep(1200);
        ui.hideOverlay();
        this.setState(GameState.PLAYING);
    },

    // determine height of tallest name tile, to keep layout stable over multiple rounds
    setNamePairHeight: function () {
        const leftName = document.getElementById('left-name');
        const rightName = document.getElementById('right-name');
        const namePair = document.querySelector('.name-pair');

        // Reset the height to auto to get the natural height
        leftName.style.height = 'auto';
        rightName.style.height = 'auto';
        namePair.style.height = 'auto';
        
        // Use requestAnimationFrame to ensure the browser has rendered the auto heights
        requestAnimationFrame(() => {
            const maxHeight = Math.max(leftName.offsetHeight, rightName.offsetHeight);
            
            // Set the height of the name-pair container
            namePair.style.height = `${maxHeight}px`;
            
            // Set both name tiles to this height
            leftName.style.height = `${maxHeight}px`;
            rightName.style.height = `${maxHeight}px`;
        });
    },

    setupNameTilesUI: function (leftName, rightName, leftNameVernacular, rightNameVernacular) {
        // Randomize the position of the name tiles
        const shouldSwap = Math.random() < 0.5;

        const nameOne = shouldSwap ? rightName : leftName;
        const nameTwo = shouldSwap ? leftName : rightName;
        const vernacularOne = shouldSwap ? rightNameVernacular : leftNameVernacular;
        const vernacularTwo = shouldSwap ? leftNameVernacular : rightNameVernacular;

        elements.leftName.setAttribute('data-taxon', nameOne);
        elements.rightName.setAttribute('data-taxon', nameTwo);
        elements.leftName.style.zIndex = '10';
        elements.rightName.style.zIndex = '10';

        // Create a span for the taxon name and a span for the vernacular name
        elements.leftName.innerHTML = `
            <span class="name-pair__taxon-name">${nameOne}</span>
            ${vernacularOne ? `<span class="name-pair__vernacular-name">${vernacularOne}</span>` : ''}
        `;
        elements.rightName.innerHTML = `
            <span class="name-pair__taxon-name">${nameTwo}</span>
            ${vernacularTwo ? `<span class="name-pair__vernacular-name">${vernacularTwo}</span>` : ''}
        `;

        gameState.taxonLeftName = nameOne;
        gameState.taxonRightName = nameTwo;

    },

    finishSetup: function () {
        ui.hideOverlay();
    },

    // TODO for now only gives photo page
    getObservationURLFromImageURL(imageURL) {
        const match = imageURL.match(/\/photos\/(\d+)\//);
        if (match && match[1]) {
            return `https://www.inaturalist.org/photos/${match[1]}`;
        }
        return null;
    },

    initializeInfoButtons() {
        const infoButton1 = document.getElementById('info-button-1');
        const infoButton2 = document.getElementById('info-button-2');

        infoButton1.addEventListener('click', () => this.showInfoDialog(this.currentObservationURLs.imageOne, 1));
        infoButton2.addEventListener('click', () => this.showInfoDialog(this.currentObservationURLs.imageTwo, 2));
    },

    openObservationURL(url) {
        if (url) {
            this.showInfoDialog(url);
        } else {
            logger.error('Observation URL not available');
        }
    },

    showInfoDialog(url, imageIndex) {
        const dialog = document.getElementById('info-dialog');
        const taxonElement = document.getElementById('info-dialog-taxon');
        const vernacularElement = document.getElementById('info-dialog-vernacular');
        const factsElement = document.getElementById('info-dialog-facts');
        const photoButton = document.getElementById('photo-button');
        const observationButton = document.getElementById('observation-button');
        const taxonButton = document.getElementById('taxon-button');
        const hintsButton = document.getElementById('hints-button');
        const reportButton = document.getElementById('report-button');
        const closeButton = document.getElementById('info-close-button');

        // Get the image containers
        const topImageContainer = document.getElementById('image-container-1');
        const bottomImageContainer = document.getElementById('image-container-2');
        const namePairContainer = document.querySelector('.name-pair');

        // Position the dialog
        const positionDialog = () => {
            const dialogRect = dialog.getBoundingClientRect();
            const topContainerRect = topImageContainer.getBoundingClientRect();
            const bottomContainerRect = bottomImageContainer.getBoundingClientRect();
            const namePairRect = namePairContainer.getBoundingClientRect();

            if (imageIndex === 1) {
                // For the top image
                dialog.style.top = `${namePairRect.top}px`;
                dialog.style.bottom = `${window.innerHeight - bottomContainerRect.bottom}px`;
                dialog.style.height = 'auto'; // Let the height adjust automatically
            } else {
                // For the bottom image
                dialog.style.top = `${topContainerRect.top}px`;
                dialog.style.bottom = `${window.innerHeight - namePairRect.bottom}px`;
                dialog.style.height = 'auto'; // Let the height adjust automatically
            }

            // Center horizontally
            dialog.style.left = `${(window.innerWidth - dialogRect.width) / 2}px`;
        };

        // Frame the corresponding image if imageIndex is provided
        if (imageIndex) {
            const imageContainer = document.getElementById(`image-container-${imageIndex}`);
            if (imageContainer) {
                imageContainer.classList.add('image-container--framed');
            }
        }

        // Set taxon and vernacular name
        const currentTaxon = this.getCurrentTaxonName(url);
        taxonElement.textContent = currentTaxon;

        api.getVernacularName(currentTaxon).then(vernacularName => {
            vernacularElement.textContent = vernacularName;

            // Add taxon facts (assuming they're still in taxonInfo.json)
            api.loadTaxonInfo().then(taxonInfo => {
                const taxonData = Object.values(taxonInfo).find(info => info.taxonName.toLowerCase() === currentTaxon.toLowerCase());
                if (taxonData && taxonData.taxonFacts && taxonData.taxonFacts.length > 0) {
                    factsElement.innerHTML = '<h3>Facts:</h3><ul>' + 
                        taxonData.taxonFacts.map(fact => `<li>${fact}</li>`).join('') + 
                        '</ul>';
                    factsElement.style.display = 'block';
                } else {
                    factsElement.style.display = 'none';
                }

                // Position the dialog after content is loaded
                dialog.setAttribute('open', ''); // Explicitly set the 'open' attribute
                positionDialog();
            });
        });

            photoButton.onclick = () => {
                window.open(url, '_blank');
                dialog.close();
            };

            observationButton.onclick = () => {
                logger.debug("Observation button clicked");
                // Implement observation functionality here
            };

            taxonButton.onclick = async () => {
                logger.debug("Taxon button clicked");
                try {
                    const taxonName = this.getCurrentTaxonName(url);
                    const taxonId = await api.fetchTaxonId(taxonName);
                    window.open(`https://www.inaturalist.org/taxa/${taxonId}`, '_blank');
                    dialog.close();
                } catch (error) {
                    logger.error("Error opening taxon page:", error);
                    alert("Unable to open taxon page. Please try again.");
                }
            };

            hintsButton.onclick = () => {
                logger.debug("Taxon hints button clicked");
                // Implement taxon hints functionality here
            };

            reportButton.onclick = () => {
                logger.debug("Report button clicked");
                // Implement report functionality here
            };

            closeButton.onclick = () => {
                dialog.close();
                document.querySelectorAll('.image-container').forEach(container => {
                    container.classList.remove('image-container--framed');
                });
            };

            dialog.addEventListener('close', () => {
                // Remove framing from all containers when dialog is closed
                document.querySelectorAll('.image-container').forEach(container => {
                    container.classList.remove('image-container--framed');
                });
            });

            dialog.showModal();
        // Reposition on window resize
        window.addEventListener('resize', positionDialog);

        },

    getCurrentTaxonName(url) {
        if (url === this.currentObservationURLs.imageOne) {
            return gameState.taxonImageOne;
        } else if (url === this.currentObservationURLs.imageTwo) {
            return gameState.taxonImageTwo;
        } else {
            logger.error("Unable to determine current taxon name");
            return null;
        }
    },

};

// Initialize info buttons
game.initializeInfoButtons();

export default game;



# code/preloader.js

import api from './api.js';
import { gameState, updateGameState } from './state.js';
import logger from './logger.js';
import utils from './utils.js';

const preloader = {
  preloadedImages: {
    nextRound: { taxon1: null, taxon2: null },
    nextPair: { taxon1: null, taxon2: null, pair: null }
  },

  async preloadImage(url) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(url);
      img.onerror = () => reject(new Error(`Failed to load image: ${url}`));
      img.src = url;
    });
  },

    async preloadForNextRound() {
        const { pair, imageOneURL, imageTwoURL } = gameState.currentTaxonImageCollection;
        const [newImageOneURL, newImageTwoURL] = await Promise.all([
            this.fetchDifferentImage(pair.taxon1, imageOneURL),
            this.fetchDifferentImage(pair.taxon2, imageTwoURL)
        ]);
        
        await Promise.all([
            this.preloadImage(newImageOneURL),
            this.preloadImage(newImageTwoURL)
        ]);

        this.preloadedImages.nextRound = { taxon1: newImageOneURL, taxon2: newImageTwoURL };
        logger.debug("Preloaded images for next round");
    },

    async fetchDifferentImage(taxonName, currentImageURL) {
        const images = await api.fetchMultipleImages(taxonName, 12);
        const taxonKey = taxonName === gameState.currentTaxonImageCollection.pair.taxon1 ? 'taxon1' : 'taxon2';
        let usedImages = gameState.usedImages[taxonKey];
        
        // Filter out the current image and any previously used images
        let availableImages = images.filter(img => !usedImages.has(img) && img !== currentImageURL);
        
        // If we've used all images, reset the used images but still avoid the current image
        if (availableImages.length === 0) {
            logger.warn(`All images for ${taxonName} have been used. Resetting used images.`);
            usedImages = new Set([currentImageURL]);
            availableImages = images.filter(img => img !== currentImageURL);
        }
        
        if (availableImages.length > 0) {
            const selectedImage = availableImages[Math.floor(Math.random() * availableImages.length)];
            usedImages.add(selectedImage);
            updateGameState({ 
                usedImages: { 
                    ...gameState.usedImages, 
                    [taxonKey]: usedImages 
                } 
            });
            return selectedImage;
        } else {
            // This should rarely happen, but just in case
            logger.error(`No available images found for ${taxonName}. Using current image.`);
            return currentImageURL;
        }
    },

    async preloadForNextPair() {
        if (this.preloadedImages.nextPair.pair) {
            logger.debug("Skipping preload for next pair as one is already available");
            return;
        }

        const newPair = await utils.selectTaxonPair();
        const [imageOneURL, imageTwoURL] = await Promise.all([
            this.fetchDifferentImage(newPair.taxon1, null),
            this.fetchDifferentImage(newPair.taxon2, null)
        ]);
        
        await Promise.all([
            this.preloadImage(imageOneURL),
            this.preloadImage(imageTwoURL)
        ]);

        this.preloadedImages.nextPair = { 
            pair: newPair,
            taxon1: imageOneURL, 
            taxon2: imageTwoURL 
        };
        logger.debug("Preloaded images for next pair");
    },

  getPreloadedImagesForNextRound() {
    const images = this.preloadedImages.nextRound;
    this.preloadedImages.nextRound = { taxon1: null, taxon2: null };
    return images;
  },

  getPreloadedImagesForNextPair() {
    const images = this.preloadedImages.nextPair;
    this.preloadedImages.nextPair = { taxon1: null, taxon2: null, pair: null };
    return images;
  },

  hasPreloadedPair() {
    return !!this.preloadedImages.nextPair.pair;
  }
};

export default preloader;



# code/state.js

// Elements and game state

// DOM elements
export const elements = {
  imageOne: document.getElementById('image-1'),
  imageTwo: document.getElementById('image-2'),
  imageOneContainer: document.getElementById('image-container-1'),
  imageTwoContainer: document.getElementById('image-container-2'),
  namePair: document.querySelector('.name-pair'),
  leftName: document.getElementById('left-name'),
  rightName: document.getElementById('right-name'),
  overlay: document.getElementById('overlay'),
  overlayMessage: document.getElementById('overlay-message'),
  buttons: document.querySelectorAll('.bottom-button')
};

// Game State enum
export const GameState = {
  IDLE: 'IDLE',
  LOADING: 'LOADING',
  READY: 'READY',
  PLAYING: 'PLAYING',
  CHECKING: 'CHECKING',
  PRELOADING: 'PRELOADING',
  PRELOADING_BACKGROUND: 'PRELOADING_BACKGROUND'
};

export const gameState = {
  preloadState: {
    currentRound: {
      taxon1: null,
      taxon2: null
    },
    nextRound: {
      taxon1: null,
      taxon2: null
    },
    nextPair: {
      taxon1: null,
      taxon2: null
    }
  },

  // check which of these still used:
  isFirstLoad: true,
  isInitialLoad: true,
  isPreloading: false,
  preloadedPair: null,
  currentSession: 1,
  /*   currentRound: 1, */
  roundPreload: null,
  pairPreload: null,

  currentRound: {
    pair: null,
    imageOneURLs: [],
    imageTwoURLs: [],
    imageOneVernacular: null,
    imageTwoVernacular: null,
    randomized: false
  },

    usedImages: {
        taxon1: new Set(),
        taxon2: new Set()
    },

  preloadedTaxonImageCollection: null,
  currentTaxonImageCollection: null,
  taxonImageOne: null,
  taxonImageTwo: null,
  taxonLeftName: null,
  taxonRightName: null,
  currentState: GameState.IDLE  // track the current game state
};

// Function to update game state
export function updateGameState(newState) {
  Object.assign(gameState, newState);
}



# code/ui.js

import api from './api.js';
import config from './config.js';
import dialogManager from './dialogManager.js';
import { elements, gameState } from './state.js';
import game from './game.js';
import logger from './logger.js';
import utils from './utils.js';

const ui = {
    isMenuOpen: false,

    resetUIState: function() {
        this.closeMainMenu();
        // Add any other UI state resets here if needed
    },

    resetGameContainerStyle: function () {
        const gameContainer = document.querySelector('.game-container');
        if (gameContainer) {
            gameContainer.style.transform = '';
            gameContainer.style.opacity = '';
        }
        elements.imageOneContainer.style.transform = '';
        elements.imageOneContainer.style.opacity = '';
        elements.imageTwoContainer.style.transform = '';
        elements.imageTwoContainer.style.opacity = '';
    },

    // display pair list for selection
    showTaxonPairList: function () {
        api.fetchTaxonPairs().then(taxonPairs => {
            if (taxonPairs.length === 0) {
                logger.error("No taxon pairs available");
                return;
            }

            const list = document.getElementById('taxon-pair-list');
            const searchInput = document.getElementById('taxon-search');
            const clearButton = document.getElementById('clear-search');
            
            // Clear the search input and hide the clear button
            searchInput.value = '';
            clearButton.style.display = 'none';

            list.innerHTML = ''; // Clear existing content

            const createTaxonPairButton = (pair, vernacular1, vernacular2) => {
                const button = document.createElement('button');
                button.className = 'taxon-pair-button';
                button.innerHTML = `
                    <div class="taxon-pair-container">
                        <div class="taxon-item">
                            <div class="taxon-name">${pair.taxon1}</div>
                            <div class="vernacular-name">${vernacular1}</div>
                        </div>
                        <div class="taxon-item">
                            <div class="taxon-name">${pair.taxon2}</div>
                            <div class="vernacular-name">${vernacular2}</div>
                        </div>
                    </div>
                `;

                button.onclick = () => {
                    // Remove selection from all buttons
                    document.querySelectorAll('.taxon-pair-button').forEach(btn => {
                        btn.classList.remove('taxon-pair-button--selected');
                    });
                    
                    // Add selection to clicked button
                    button.classList.add('taxon-pair-button--selected');

                    game.nextSelectedPair = pair;
                    // Don't close the dialog immediately to allow the user to see the selection
                    setTimeout(() => {
                        dialogManager.closeDialog();
                        game.setupGame(true);
                    }, 300); // 300ms delay before closing
                };
                return button;
            };

            const renderFilteredList = async (filter = '') => {
                const fragment = document.createDocumentFragment();
                const lowerFilter = filter.toLowerCase();
                for (const pair of taxonPairs) {
                    const vernacular1 = await api.getVernacularName(pair.taxon1);
                    const vernacular2 = await api.getVernacularName(pair.taxon2);
                    
                    const matchesTaxon = pair.taxon1.toLowerCase().includes(lowerFilter) || 
                                         pair.taxon2.toLowerCase().includes(lowerFilter);
                    const matchesVernacular = vernacular1.toLowerCase().includes(lowerFilter) || 
                                              vernacular2.toLowerCase().includes(lowerFilter);
                    
                    if (matchesTaxon || matchesVernacular) {
                        const button = createTaxonPairButton(pair, vernacular1, vernacular2);
                        fragment.appendChild(button);
                    }
                }
                list.innerHTML = '';
                list.appendChild(fragment);
            };

            (async () => {
                await renderFilteredList(); // Initial render with all pairs
            })();

            const debouncedFilter = utils.debounce(async (event) => {
                const filter = event.target.value.toLowerCase();
                await renderFilteredList(filter);
            }, 300);

            searchInput.addEventListener('input', (event) => {
                clearButton.style.display = event.target.value ? 'block' : 'none';
                debouncedFilter(event);
            });

            clearButton.addEventListener('click', () => {
                searchInput.value = '';
                clearButton.style.display = 'none';
                renderFilteredList();
                searchInput.focus();
            });

            dialogManager.openDialog('select-pair-dialog');

            // Focus on the search input when the dialog opens
            setTimeout(() => searchInput.focus(), 100);
        });
    },

    showOverlay: function (message = "", color) {
        elements.overlayMessage.innerHTML = message;
        elements.overlay.style.backgroundColor = color;
        elements.overlay.classList.add('show');

        // Adjust font size for longer messages
        if (message.length > 20) {
            elements.overlayMessage.style.fontSize = '1.4em';
        } else {
            elements.overlayMessage.style.fontSize = '2.4em';
        }
    },

    // Update this method to change only the message, not the visibility
    updateOverlayMessage: function (message) {
        const overlayMessage = document.getElementById('overlay-message');
        overlayMessage.innerHTML = message;

        // Adjust font size for longer messages
        if (message.length > 20) {
            overlayMessage.style.fontSize = '1.6em';
        } else {
            overlayMessage.style.fontSize = '2.4em';
        }
    },

    hideOverlay: function () {
        elements.overlay.classList.remove('show');
    },

    showINatDownDialog: function () {
        const loadingScreen = document.getElementById('loading-screen');
        if (loadingScreen) {
            loadingScreen.style.display = 'none';
        }

        dialogManager.openDialog('inat-down-dialog');

        const checkStatusBtn = document.getElementById('check-inat-status');
        const retryConnectionBtn = document.getElementById('retry-connection');

        const checkStatusHandler = () => {
            window.open('https://inaturalist.org', '_blank');
        };

        const retryConnectionHandler = async () => {
            dialogManager.closeDialog();
            if (await api.isINaturalistReachable()) {
                game.setupGame(true);
            } else {
                this.showINatDownDialog();
            }
        };

        checkStatusBtn.addEventListener('click', checkStatusHandler);
        retryConnectionBtn.addEventListener('click', retryConnectionHandler);
    },

    hideINatDownDialog: function () {
        dialogManager.closeDialog();
    },

    showTutorial: function () {
        const steps = [
            { message: "Welcome to DuoNat!<br>Let's learn how to play.", highlight: null, duration: 4000 },
            { message: "You'll see two images of different taxa.", highlights: ['#image-container-1', '#image-container-2'], duration: 5000 },
            { message: "Drag a name to the correct image.", highlight: '.name-pair', duration: 5000 },
            { message: "If correct, you'll move to the next round.", highlight: null, duration: 4000 },
            { 
                message: "Swipe left on an image for a new taxon set.", 
                highlight: null,
                action: () => { this.tiltGameContainer(3200); },
                duration: 6000
            },
            { message: "Get more info about a taxon.", highlights: ['#info-button-1', '#info-button-2'], duration: 6000 },
            { message: "Tap the menu for more functions.", highlight: '#menu-toggle', action: () => this.temporarilyOpenMenu(6000), duration: 6000 },
            { message: "Ready to start?<br>Let's go!", highlight: null, duration: 2000 }
        ];

        let currentStep = 0;
        let highlightElements = [];

        const showStep = () => {
            if (currentStep < steps.length) {
                const step = steps[currentStep];
                this.updateOverlayMessage(step.message);

                highlightElements.forEach(el => el.remove());
                highlightElements = [];

                if (step.highlight) {
                    const highlight = this.createHighlight(step.highlight);
                    if (highlight) highlightElements.push(highlight);
                } else if (step.highlights) {
                    step.highlights.forEach(selector => {
                        const highlight = this.createHighlight(selector);
                        if (highlight) highlightElements.push(highlight);
                    });
                }

                if (step.action) {
                    step.action();
                }

                currentStep++;
                setTimeout(showStep, step.duration); // Use the step's duration
            } else {
                this.hideOverlay();
                highlightElements.forEach(el => el.remove());
            }
        };

        // Close the help dialog before starting the tutorial
        document.getElementById('help-dialog').close();
        
        // Show the overlay at the start of the tutorial
        this.showOverlay("", config.overlayColors.green);
        
        // Start the tutorial
        showStep();
    },

    temporarilyOpenMenu: function(duration) {
      this.toggleMainMenu(); // Open the menu
      setTimeout(() => {
        this.closeMainMenu(); // Close the menu after the specified duration
      }, duration);
    },

    // for tutorial demo
    tiltGameContainer: function(duration = 3200) {
        const gameContainer = document.querySelector('.game-container');
        const midpoint = duration / 2;

        // Initial tilt
        gameContainer.style.transition = `transform ${midpoint}ms ease-out, opacity ${midpoint}ms ease-out`;
        gameContainer.style.transform = 'rotate(-3deg) translateX(-50px)';
        gameContainer.style.opacity = '0.7';

        // Return to original position
        setTimeout(() => {
            gameContainer.style.transition = `transform ${midpoint}ms ease-in, opacity ${midpoint}ms ease-in`;
            gameContainer.style.transform = '';
            gameContainer.style.opacity = '';
        }, midpoint);

        // Clean up
        setTimeout(() => {
            gameContainer.style.transition = '';
        }, duration);
    },

    createHighlight: function (targetSelector) {
        const target = document.querySelector(targetSelector);
        if (!target) {
            logger.error(`Target element not found: ${targetSelector}`);
            return null;
        }

        const highlight = document.createElement('div');
        highlight.className = 'tutorial-highlight';
        document.body.appendChild(highlight);

        const targetRect = target.getBoundingClientRect();
        highlight.style.width = `${targetRect.width}px`;
        highlight.style.height = `${targetRect.height}px`;
        highlight.style.top = `${targetRect.top}px`;
        highlight.style.left = `${targetRect.left}px`;

        return highlight;
    },

    toggleKeyboardShortcuts: function () {
        const keyboardShortcutsSection = document.getElementById('keyboard-shortcuts');
        if (utils.hasKeyboard()) {
            keyboardShortcutsSection.style.display = 'block';
        } else {
            keyboardShortcutsSection.style.display = 'none';
        }
    },

    initializeHelpDialog: function () {
        document.getElementById('help-button').addEventListener('click', () => {
            this.toggleKeyboardShortcuts();
            dialogManager.openDialog('help-dialog');
        });
    },

    initializeInfoDialog: function () {
        const infoDialog = document.getElementById('info-dialog');

        // Check if the device has a keyboard
        if (utils.hasKeyboard()) {
            document.body.classList.add('has-keyboard');
        }

        const handleKeyPress = (event) => {
            if (!infoDialog.open) return; // Only handle keypresses when the dialog is open

            event.stopPropagation();
            const key = event.key.toLowerCase();
            const buttonMap = {
                'p': 'photo-button',
                'h': 'hints-button',
                'o': 'observation-button',
                't': 'taxon-button',
                'r': 'report-button'
            };

            if (buttonMap[key]) {
                event.preventDefault();
                document.getElementById(buttonMap[key]).click();
            } else if (key === 'escape') {
                event.preventDefault();
                infoDialog.close();
            }
        };

        document.addEventListener('keydown', handleKeyPress);
    },

    // main menu code:
    initializeMainMenu: function() {
        const menuToggle = document.getElementById('menu-toggle');
        if (menuToggle) {
            menuToggle.addEventListener('click', (event) => {
//                logger.debug('Menu toggle button or its child clicked');
                event.stopPropagation();
                this.toggleMainMenu();
            });
        } else {
            logger.error('Menu toggle button not found');
        }

        window.addEventListener('resize', this.positionBottomGroup.bind(this));
        
        // Call once to set initial position
        this.positionBottomGroup();

        // Close the dropdown when clicking outside of it
        document.addEventListener('click', (event) => {
            if (!event.target.closest('.main-menu')) {
                this.closeMainMenu();
            }
        });
    },

    toggleMainMenu: function() {
        this.isMenuOpen = !this.isMenuOpen;

        const topGroup = document.querySelector('.main-menu__dropdown--top');
        const bottomGroup = document.querySelector('.main-menu__dropdown--bottom');

        if (topGroup && bottomGroup) {
            topGroup.classList.toggle('show');
            bottomGroup.classList.toggle('show');
//            logger.debug("Show classes toggled");

            if (this.isMenuOpen) {
                this.positionBottomGroup();
            }
        } else {
            logger.error('Dropdown groups not found');
        }
    },

    positionBottomGroup: function() {
        const bottomGroup = document.querySelector('.main-menu__dropdown--bottom');
        const lowerImageContainer = document.querySelector('#image-container-2');
        
        if (bottomGroup && lowerImageContainer) {
            const rect = lowerImageContainer.getBoundingClientRect();
            bottomGroup.style.top = `${rect.top}px`;
            bottomGroup.style.right = `0px`; // Adjust if needed
        }
    },

    closeMainMenu: function() {
        if (this.isMenuOpen) {
            const topGroup = document.querySelector('.main-menu__dropdown--top');
            const bottomGroup = document.querySelector('.main-menu__dropdown--bottom');
            if (topGroup && bottomGroup) {
                this.isMenuOpen = false;
                topGroup.classList.remove('show');
                bottomGroup.classList.remove('show');
            }
        }
    },

    initialize: function () {
        this.initializeHelpDialog();
        this.initializeInfoDialog();
        this.initializeMainMenu();
        this.closeMainMenu(); // Ensure menu is closed on initialization
        // Close the dropdown when clicking outside of it
        document.addEventListener('click', (event) => {
            if (!event.target.closest('.main-menu')) {
                this.closeMainMenu();
            }
        });
    },

};

export default ui;




# code/utils.js

// Utility functions

import api from './api.js';
import game from './game.js';
import logger from './logger.js';

const utils = {

    // optionally get pair of taxa from URL
    getURLParameters: function () {
        const params = new URLSearchParams(window.location.search);
        const taxon1 = params.get('taxon1');
        const taxon2 = params.get('taxon2');
        if (taxon1 && taxon2) {
            return { taxon1, taxon2 };
        }
        return null;
    },

    debounce: function (func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const context = this;
            const later = () => {
                clearTimeout(timeout);
                func.apply(context, args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    },

    // trying out things button
    surprise: function () {
        logger.debug("Surprise!");
        //        game.showTaxaRelationship();
        //this.fart();
        this.randomAnimalSound();
    },

    randomAnimalSound: async function () {
        try {
            // Fetch random observations with sounds
            const url = "https://api.inaturalist.org/v1/observations?order_by=random&sounds=true";
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error('Failed to fetch observations');
            }
            const data = await response.json();

            // Filter observations with sounds
            const observationsWithSounds = data.results.filter(obs => obs.sounds && obs.sounds.length > 0);

            if (observationsWithSounds.length > 0) {
                // Choose a random observation
                const randomObservation = observationsWithSounds[Math.floor(Math.random() * observationsWithSounds.length)];
                
                // Extract the sound URL
                const soundUrl = randomObservation.sounds[0].file_url;

                if (soundUrl) {
                    // Create and play the audio
                    const audio = new Audio(soundUrl);
                    await audio.play();
                    logger.info(`Playing sound from observation: ${randomObservation.species_guess || 'Unknown species'}`);
                } else {
                    logger.warn("Sound URL not found in the selected observation.");
                }
            } else {
                logger.warn("No observations with sounds found.");
            }
        } catch (error) {
            logger.error('Could not play animal sound:', error);
        }
    },

    fart: function () {
        // placeholder
        const soundUrl = './sound/fart.mp3';
        // Create a new Audio object

        const audio = new Audio(soundUrl);
        audio.play({ playbackMode: 'background' })
            .then(() => { logger.info("Everybody plays their fart."); /* Audio started playing successfully*/ }).catch(error => { logger.error('Could not play my fart:', error); });
    },

    hasKeyboard: function () {
        // Check if the device is mobile
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // Check if it's a tablet
        const isTablet = /(tablet|ipad|playbook|silk)|(android(?!.*mobile))/i.test(navigator.userAgent);

        // If it's not mobile and not a tablet, assume it has a keyboard
        const result = !isMobile && !isTablet;

//        logger.debug(`hasKeyboard detected: ${result}`);
//        logger.debug(`UserAgent: ${navigator.userAgent}`);

        return result;
    },

    debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    },

    sleep: function (ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    },

    resetDraggables: function () {
        const leftNameContainer = document.getElementsByClassName('name-pair__container--left')[0];
        const rightNameContainer = document.getElementsByClassName('name-pair__container--right')[0];
        const dropOne = document.getElementById('drop-1');
        const dropTwo = document.getElementById('drop-2');

        // Move draggables back to the names container
        leftNameContainer.appendChild(document.getElementById('left-name'));
        rightNameContainer.appendChild(document.getElementById('right-name'));

        // Clear drop zones
        dropOne.innerHTML = ''; dropTwo.innerHTML = '';
    },

    capitalizeFirstLetter: function (string) {
        if (!string) {
            return '';
        } else { return string.charAt(0).toUpperCase() + string.slice(1); }
    },

    shortenSpeciesName: function (string) {
        if (!string) { return ''; }

        let parts = string.split(' ');
        if (parts.length < 2) {
            return string; // Return the original string if it doesn't contain at least two parts
        }

        let genusInitial = parts[0].charAt(0).toUpperCase() + '.';
        let species = parts.slice(1).join(' '); // Join the remaining parts in case the species name has multiple words

        return genusInitial + ' ' + species;
    },

    // Returns a taxon pair from the index, or a random one if none indicated
    selectTaxonPair: async function (index = null) {
        const taxonPairs = await api.fetchTaxonPairs();
        if (taxonPairs.length === 0) {
            logger.error("No taxon pairs available");
            return null;
        }
        return index !== null ? taxonPairs[index] : taxonPairs[Math.floor(Math.random() * taxonPairs.length)];
    },

}; // const utils

export default utils;


