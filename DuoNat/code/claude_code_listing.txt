
# index.html

<!DOCTYPE html>
<html lang="en">
<head>
    <title>DuoNat • iNat Taxonomy Trainer</title>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta http-equiv="Cache-Control" content="no-cache">

    <!-- For iOS devices -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- For Android devices -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#74ac00">

    <!-- cache busting by appending version code. change code in script!-->
    <script src="./code/version.js" defer></script>

    <link rel="manifest" href="./manifest.json">

    <script type="module" src="./code/functions.js" defer></script>

    <link rel="stylesheet" href="./styles/main.css">

    <link rel="icon" href="./images/favicon.png" type="image/png">
  <!--  <link rel="preload" href="./images/icons.svg" as="image" type="image/svg+xml"> -->
</head>

<body>

<!-- Loading screen at app start -->
<div id="loading-screen" class="loading-screen">

    <div class="loading-screen__content">

        <img src="./images/icon-512x512.png" alt="DuoNat logo" class="loading-screen__logo">

        <h1 class="loading-screen__title">
            <span class="loading-screen__title-duo">Duo</span><span class="loading-screen__title-nat">Nat</span>
        </h1>

        <p class="loading-screen__message">Loading amazing creatures...</p>

        <div class="loading-screen__spinner"></div>

    </div>

</div>

<!-- App main screen -->
<div class="game-container">

<div class="image-container" id="image-container-1">
  <img class="image-container__image" src="" alt="Taxon 1 Image" id="image-1">

  <div class="image-container__world-map" id="world-map-1"></div>

  <div class="image-container__drop-zone" id="drop-1"></div>

        <div id="drop-1" class="droppable"></div>

        <div class="image-container__buttons" id="image-buttons-1">
            <!-- enable when functionality added -->
            <!--<button class="image-container__button image-container__button--thumbs-up" id="thumbs-up-1" title="Like this image" data-tooltip="Like this image">
                <svg class="icon"><use href="./images/icons.svg#icon-thumb-up"/></svg>
            </button>
            <button class="image-container__button image-container__button--thumbs-down" id="thumbs-down-1" title="Dislike this image" data-tooltip="Dislike this image">
                <svg class="icon"><use href="./images/icons.svg#icon-thumb-down"/></svg>
            </button>-->
            <button class="icon-button image-container__button image-container__button--info" id="info-button-1" title="Taxon info" aria-label="Taxon info">
                <svg class="icon image-container__button-icon"><use href="./images/icons.svg#icon-info"/></svg>
            </button>
        </div>

</div>

    <div class="name-pair">

        <div class="name-pair__container name-pair__container--left">
            <div id="left-name" class="name-pair__item name-pair__item--draggable" draggable="true"></div>
        </div>

        <div class="name-pair__container name-pair__container--right">
            <div id="right-name" class="name-pair__item name-pair__item--draggable" draggable="true"></div>
        </div>

        <div id="overlay" class="name-pair__overlay">
            <div id="overlay-message" class="name-pair__overlay-message"></div>
        </div>

    </div>

    <div class="image-container" id="image-container-2">
      <img class="image-container__image" src="" alt="Taxon 2 Image" id="image-2">

      <div class="image-container__world-map" id="world-map-2"></div>

      <div class="image-container__drop-zone" id="drop-2"></div>
            <div id="drop-2" class="droppable"></div>

            <div class="image-container__buttons" id="image-buttons-2">
                <!-- enable when functionality added -->
                <!--<button class="icon-button image-container__button image-container__button--thumbs-up" id="thumbs-up-2" title="Like this image" data-tooltip="Like this image">
                    <svg class="icon"><use href="./images/icons.svg#icon-thumb-up"/></svg>
                </button>
                <button class="icon-button image-container__button image-container__button--thumbs-down" id="thumbs-down-2" title="Dislike this image" data-tooltip="Dislike this image">
                    <svg class="icon"><use href="./images/icons.svg#icon-thumb-down"/></svg>
                </button>-->
                <button class="icon-button image-container__button image-container__button--info" id="info-button-2" title="Taxon info" aria-label="Taxon info">
                    <svg class="icon image-container__button-icon"><use href="./images/icons.svg#icon-info"/></svg>
                </button>
            </div>

    </div>

</div> <!-- game-container -->

<!-- overlay buttons on the main screen -->

<button class="icon-button" id="help-button" title="Help" aria-label="Open help dialog">
    <svg class="icon">
        <use href="./images/icons.svg#icon-help"/>
    </svg>
</button>

<!-- Main menu -->
<div class="main-menu">

    <button class="icon-button" id="menu-toggle" title="Menu" aria-label="Open menu">
      <svg class="icon"><use href="./images/icons.svg#icon-menu"/></svg>
    </button>

  <div class="main-menu__dropdown main-menu__dropdown--top">

    <div class="main-menu__item">
      <span class="main-menu__label">Share this pair</span>
      <button class="icon-button" id="share-button" aria-label="Share this pair">
        <svg class="icon"><use href="./images/icons.svg#icon-share"/></svg>
      </button>
    </div>

    <div class="main-menu__item">
      <span class="main-menu__label">Show phylogeny</span>
      <button class="icon-button" id="phylogeny-button" aria-label="Show phylogeny">
<!--      <svg class="icon"><use href="./images/icons.svg#icon-phylogeny"/></svg>-->
        <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z" transform="rotate(90 12 12)"/>
        </svg>
      </button>
    </div>

    <!-- enable when functionality added 
    <div class="main-menu__item">
      <span class="main-menu__label">Like this pair</span>
    <button class="icon-button" id="like-button" aria-label="Like this pair">
      <svg class="icon"><use href="./images/icons.svg#icon-heart"/></svg>
    </button>
    </div>

    <div class="main-menu__item">
      <span class="main-menu__label">Trash this pair</span>
    <button class="icon-button" id="trash-button" aria-label="Trash this pair">
      <svg class="icon"><use href="./images/icons.svg#icon-trash"/></svg>
    </button>
    </div> -->

  </div>

  <div class="main-menu__dropdown main-menu__dropdown--bottom">

    <div class="main-menu__item">
      <span class="main-menu__label">Select new pair</span>
      <button class="icon-button" id="select-pair-button" aria-label="Select new pair">
        <svg class="icon"><use href="./images/icons.svg#icon-list"/></svg>
      </button>
    </div>

    <div class="main-menu__item">
      <span class="main-menu__label">Enter new pair</span>
      <button class="icon-button" id="enter-pair-button" aria-label="Enter new pair">
        <svg class="icon"><use href="./images/icons.svg#icon-plus"/></svg>
      </button>
    </div>

    <div class="main-menu__item">
      <span class="main-menu__label">Random new pair</span>
      <button class="icon-button" id="random-pair-button" aria-label="Random new pair">
        <svg class="icon"><use href="./images/icons.svg#icon-random"/></svg>
      </button>
    </div> 

    <div class="main-menu__item">
      <span class="main-menu__label">Surprise!</span>
      <button class="icon-button" id="surprise-button" aria-label="Surprise!">
        <svg class="icon"><use href="./images/icons.svg#icon-star"/></svg>
      </button>
    </div>

  </div> <!-- bottom-group -->

</div> <!-- main menu -->


<!-- Dialogs, only visible when opened in app: -->
<!-- TODO: these should be in their own files -->

<!-- Help dialog -->
<dialog id="help-dialog">

<button class="dialog-close-button icon" aria-label="Close">×</button>
    <div class="help-dialog-content">
        <div class="help-dialog-header">
            <img src="./images/icon-512x512.png" alt="DuoNat logo" class="help-dialog-logo">
            <h2>
                <span class="duo">Duo</span><span class="nat">Nat</span>
                <br><span class="subtitle">iNat Taxonomy Trainer</span>
            </h2>
        </div>
        <div class="help-content">

            <div class="help-item">
                <svg class="icon"><use href="./images/icons.svg#icon-drag"/></svg>
                <p>Drag name to image</p>
            </div>

            <div class="help-item">
                <svg class="icon"> <use href="./images/icons.svg#icon-left"/></svg>
                <p>Swipe left for new pair</p>
            </div>

            <div class="help-item">
                <svg class="icon"> <use href="./images/icons.svg#icon-menu"/></svg>
                <p>Menu for more</p>
            </div>

            <div id="keyboard-shortcuts" style="display: none;">
                <h3>Keyboard Shortcuts</h3>
                <div class="help-item">
                    <svg class="icon"><use href="./images/icons.svg#icon-keyboard"/></svg>
                    <ul>
                        <li><strong>H</strong> Help</li>
                        <li><strong>G</strong> Show phylogeny graph</li>
                        <li><strong>I</strong> Info for left image</li>
                        <li><strong>O</strong> Info for right image</li>
                        <li><strong>R</strong> Random pair</li>
                        <li><strong>S</strong> Select pair</li>
                        <li><strong>E</strong> Enter pair</li>
                    </ul>
                </div>
            </div>

            <button id="start-tutorial-button">Start Tutorial</button>
            <button id="discord-help-dialog">Join us on Discord</button>
            <div id="version-id"></div>
        </div>
    </div>
</dialog>

<!-- Select pair dialog -->
    <dialog id="select-pair-dialog" class="standard-dialog">
        <div class="dialog-inner">
            <button class="dialog-close-button icon" aria-label="Close">×</button>
            <h3 class="dialog-title">Select Taxon Pair</h3>
            <button id="select-tags-button" class="select-tags-button">Select Tags</button>
            <div class="search-container">
                  <input type="text" id="taxon-search" placeholder="Search taxa..." aria-label="Search taxa">
                  <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                  <button id="clear-search" aria-label="Clear search" style="display: none;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                  </button>
            </div>
            <div id="taxon-pair-list" class="taxon-pair-list">
                <!-- Taxon pairs will be dynamically inserted here -->
            </div>
        </div>
    </dialog>

    <dialog id="tag-cloud-dialog" class="standard-dialog">
        <button class="dialog-close-button icon" aria-label="Close">×</button>
        <h3 class="dialog-title">Select Tags</h3>
        <div id="tag-cloud-container"></div>
        <p id="matching-pairs-count"></p>
        <button id="tag-cloud-done-button" class="done-button">Done</button>
    </dialog>

<!-- Enter pair dialog -->
    <dialog id="enter-pair-dialog" class="standard-dialog">
        <button class="dialog-close-button icon" aria-label="Close">×</button>
        <form method="dialog">
            <h2 class="dialog-title">Enter New Taxon Pair</h2>
            <div>
                <label for="taxon1">Taxon 1:</label>
                <input type="text" id="taxon1" required>
            </div>
            <div>
                <label for="taxon2">Taxon 2:</label>
                <input type="text" id="taxon2" required>
            </div>
            <div id="dialog-message" aria-live="polite"></div>
            <button type="submit" id="submit-dialog">Submit</button>
        </form>
    </dialog>


<!-- Phylogeny dialog -->
<dialog id="phylogeny-dialog" class="standard-dialog">
    <button class="dialog-close-button icon" aria-label="Close">×</button>
    <h3 class="dialog-title">Phylogenetic Relationship</h3>
    <div id="graph-hint" class="graph-hint">Tip: Click on a node to open its iNaturalist page</div>
    <div id="taxa-relationship-graph"></div>
</dialog>


<!-- Info dialog -->
<dialog id="info-dialog" class="info-dialog">

    <button class="dialog-close-button icon" id="info-close-button" aria-label="Close">×</button>
    <div class="info-dialog__header">
        <h2 id="info-dialog-taxon" class="info-dialog__taxon"></h2>
        <p id="info-dialog-vernacular" class="info-dialog__vernacular"></p>
    </div>
    <div id="info-dialog-facts" class="info-dialog__facts"></div>

<div class="info-dialog__buttons">
    <button id="hints-button" class="icon-button info-dialog__button info-dialog__button--hints" title="Hints" aria-label="Show identification hints (TODO)">
<!--    <svg class="icon info-dialog__button--inactive" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M9 21c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-1H9v1zm3-19C8.14 2 5 5.14 5 9c0 2.38 1.19 4.47 3 5.74V17c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-2.26c1.81-1.27 3-3.36 3-5.74 0-3.86-3.14-7-7-7zm2.85 11.1l-.85.6V16h-4v-2.3l-.85-.6C7.8 12.16 7 10.63 7 9c0-2.76 2.24-5 5-5s5 2.24 5 5c0 1.63-.8 3.16-2.15 4.1z"/>
        </svg>-->
<!--        <svg class="info-dialog__button-icon icon"><use href="./images/icons.svg#icon-info"/></svg>-->
    </button>
    <button id="photo-button" class="icon-button info-dialog__button info-dialog__button--photo" title="Photo Page" aria-label="Open iNat photo page">
        <svg class="info-dialog__button-icon icon"><use href="./images/icons.svg#icon-camera"/></svg>
    </button>
    <button id="observation-button" class="icon-button info-dialog__button info-dialog__button--observation" title="Observation page" aria-label="Open iNat observation (TODO)">
<!--        <svg class="info-dialog__button-icon icon info-dialog__button--inactive"><use href="./images/icons.svg#icon-microscope"/></svg>-->
    </button>
    <button id="taxon-button" class="icon-button info-dialog__button info-dialog__button--taxon" title="Taxon page" aria-label="Open taxon page">
        <svg class="info-dialog__button-icon icon"><use href="./images/icons.svg#icon-info"/></svg>
<!--        <svg class="info-dialog__button-icon icon"><use href="./images/icons.svg#icon-taxon"/></svg>-->
    </button>
    <button id="wiki-button" class="icon-button info-dialog__button info-dialog__button--wiki" title="Wikipedia page" aria-label="Open Wikipedia page">
        <svg class="info-dialog__button-icon icon"><use href="./images/icons.svg#icon-wiki"/></svg>
    </button>
    <button id="report-button" class="icon-button info-dialog__button info-dialog__button--report" title="Report problem" aria-label="Report problem">
<!--        <svg class="info-dialog__button-icon icon"><use href="./images/icons.svg#icon-report"/></svg>-->
    </button>
</div>

</dialog>


<!-- iNat down dialog -->
<dialog id="inat-down-dialog" class="standard-dialog">
    <button class="dialog-close-button icon" aria-label="Close">×</button>
  <h2 class="dialog-title">iNaturalist Unavailable</h2>
  <p>We're having trouble connecting to iNaturalist. This could be due to maintenance or temporary issues.</p>
  <button id="check-inat-status">Check iNaturalist Status</button>
  <button id="retry-connection">Retry Connection</button>
</dialog>

<div id="swipe-info-message" class="swipe-info-message">New random pair</div>

</body>
</html>



# code/game.js

import api from './api.js';
import config from './config.js';
import dialogManager from './dialogManager.js';
import { elements, gameState, updateGameState, GameState } from './state.js';
import logger from './logger.js';
import preloader from './preloader.js';
import taxaRelationshipViewer from './taxaRelationshipViewer.js';
import ui from './ui.js';
import utils from './utils.js';
import { createWorldMap } from './worldMap.js';

const game = {
    loadingMessage: "",
    //loadingMessage: "Loading...",
    nextSelectedPair: null,
    currentState: GameState.IDLE,
    currentGraphTaxa: null,
    preloadedPair: null,
    preloadedImages: {
        current: {
            taxon1: [],
            taxon2: []
        },
        next: {
            taxon1: [],
            taxon2: []
        }
    },

    currentObservationURLs: {
        imageOne: null,
        imageTwo: null
    },

    setState(newState) {
        this.currentState = newState;
    },

    showLoadingScreen: function () {
        document.getElementById('loading-screen').style.display = 'flex';
    },

    hideLoadingScreen: function () {
        setTimeout(() => {
            document.getElementById('loading-screen').style.display = 'none';
        }, 500); // 500ms delay, adjust as needed
    },

    async setupGame(newPair = false) {
        this.setState(GameState.LOADING);

        if (!await this.checkINaturalistReachability()) { return; }

        this.prepareUIForLoading();

        try {
            if (newPair || !gameState.currentTaxonImageCollection) {
                await this.initializeNewPair();
            } else {
                await this.setupRound();
            }

            this.finishSetup();
            
            // Call setNamePairHeight here, after the new pair or round is set up
            this.setNamePairHeight();

            // Preload for the next round
            preloader.preloadForNextRound();

            // Only preload for next pair if we don't have one already
            if (!preloader.hasPreloadedPair()) {
                preloader.preloadForNextPair();
            }

            this.setState(GameState.PLAYING);
            this.hideLoadingScreen();

            if (gameState.isInitialLoad) {
                updateGameState({ isInitialLoad: false });
            }

            ui.hideOverlay();
            ui.resetUIState();
        } catch (error) {
            this.handleSetupError(error);
        }
    },

    async initializeNewPair() {
        let newPair, imageOneURL, imageTwoURL;

        if (this.nextSelectedPair) {
            // Use the manually selected pair if available
            newPair = this.nextSelectedPair;
            this.nextSelectedPair = null; // Clear the selected pair after use
            [imageOneURL, imageTwoURL] = await Promise.all([
                api.fetchRandomImageMetadata(newPair.taxon1),
                api.fetchRandomImageMetadata(newPair.taxon2)
            ]);
        } else {
            // Use preloaded pair if available, otherwise fetch a new random pair
            const preloadedPair = preloader.getPreloadedImagesForNextPair();
            if (preloadedPair && preloadedPair.pair) {
                newPair = preloadedPair.pair;
                imageOneURL = preloadedPair.taxon1;
                imageTwoURL = preloadedPair.taxon2;
            } else {
                newPair = await utils.selectTaxonPair();
                [imageOneURL, imageTwoURL] = await Promise.all([
                    api.fetchRandomImageMetadata(newPair.taxon1),
                    api.fetchRandomImageMetadata(newPair.taxon2)
                ]);
            }
        }

        updateGameState({
            currentTaxonImageCollection: {
                pair: newPair,
                imageOneURL,
                imageTwoURL
            },
            usedImages: {
                taxon1: new Set([imageOneURL]),
                taxon2: new Set([imageTwoURL])
            }
        });

        await this.setupRound(true);
    },

    async setupRound(isNewPair = false) {
        const { pair } = gameState.currentTaxonImageCollection;
        const randomized = Math.random() < 0.5;

        let imageOneURL, imageTwoURL;

        if (isNewPair) {
            imageOneURL = gameState.currentTaxonImageCollection.imageOneURL;
            imageTwoURL = gameState.currentTaxonImageCollection.imageTwoURL;
        } else {
            const preloadedImages = preloader.getPreloadedImagesForNextRound();
            if (preloadedImages && preloadedImages.taxon1 && preloadedImages.taxon2) {
                imageOneURL = preloadedImages.taxon1;
                imageTwoURL = preloadedImages.taxon2;
            } else {
                [imageOneURL, imageTwoURL] = await Promise.all([
                    preloader.fetchDifferentImage(pair.taxon1, gameState.currentRound.imageOneURL),
                    preloader.fetchDifferentImage(pair.taxon2, gameState.currentRound.imageTwoURL)
                ]);
            }
        }

        const leftImageSrc = randomized ? imageOneURL : imageTwoURL;
        const rightImageSrc = randomized ? imageTwoURL : imageOneURL;

        await this.loadImages(leftImageSrc, rightImageSrc);

  // Set the observation URLs
    this.currentObservationURLs.imageOne = this.getObservationURLFromImageURL(leftImageSrc);
    this.currentObservationURLs.imageTwo = this.getObservationURLFromImageURL(rightImageSrc);

    const [leftVernacular, rightVernacular] = await Promise.all([
        utils.capitalizeFirstLetter(await api.fetchVernacular(randomized ? pair.taxon1 : pair.taxon2)),
        utils.capitalizeFirstLetter(await api.fetchVernacular(randomized ? pair.taxon2 : pair.taxon1))
    ]);

    this.setupNameTilesUI(
        randomized ? pair.taxon1 : pair.taxon2,
        randomized ? pair.taxon2 : pair.taxon1,
        leftVernacular,
        rightVernacular
    );

    // Add world maps
    const leftContinents = await this.getContinentForTaxon(randomized ? pair.taxon1 : pair.taxon2);
    const rightContinents = await this.getContinentForTaxon(randomized ? pair.taxon2 : pair.taxon1);
    createWorldMap(elements.imageOneContainer, leftContinents);
    createWorldMap(elements.imageTwoContainer, rightContinents);

        updateGameState({
            taxonImageOne: randomized ? pair.taxon1 : pair.taxon2,
            taxonImageTwo: randomized ? pair.taxon2 : pair.taxon1,
            currentRound: {
                pair,
                imageOneURL,
                imageTwoURL,
                imageOneVernacular: leftVernacular,
                imageTwoVernacular: rightVernacular,
                randomized
            }
        });

    },

    async getContinentForTaxon(taxon) {
        const taxonInfo = await api.loadTaxonInfo();
        const taxonData = Object.values(taxonInfo).find(info => info.taxonName.toLowerCase() === taxon.toLowerCase());
        
        if (taxonData && taxonData.distribution && taxonData.distribution.length > 0) {
            // Convert the continent codes to full names
            const continentMap = {
                'NA': 'North America',
                'SA': 'South America',
                'EU': 'Europe',
                'AS': 'Asia',
                'AF': 'Africa',
                'OC': 'Oceania'
            };
            
            // Convert all continent codes to full names
            const fullContinents = taxonData.distribution.map(code => continentMap[code]);
            
            return fullContinents;
        } else {
            logger.debug(`No distribution data found for ${taxon}. Using placeholder.`);
            return ['North America', 'South America', 'Europe', 'Africa', 'Asia', 'Oceania'];
        }
    },

    async checkINaturalistReachability() {
        if (!await api.isINaturalistReachable()) {
            ui.showINatDownDialog();
            this.setState(GameState.IDLE);
            return false;
        }
        ui.hideINatDownDialog();
        return true;
    },

    async fetchTaxonImageCollection(newPair) {
        let attempts = 0;
        const maxAttempts = 3;

        while (attempts < maxAttempts) {
            try {
                return await this.attemptFetchTaxonImageCollection(newPair);
            } catch (error) {
                attempts++;
                if (this.shouldRetryFetch(error, attempts, maxAttempts)) {
                    await this.handleFetchError(error);
                } else {
                    throw error;
                }
            }
        }

        throw new Error("Failed to load images after multiple attempts");
    },

    async attemptFetchTaxonImageCollection(newPair) {
        if (newPair || !gameState.currentTaxonImageCollection) {
            if (this.nextSelectedPair) {
                const collection = await this.initializeNewTaxonPair(this.nextSelectedPair);
                this.nextSelectedPair = null;
                return collection;
            } else if (this.preloadedPair) {
                const collection = this.preloadedPair;
                this.preloadedPair = null;
                return collection;
            } else {
                return await this.initializeNewTaxonPair();
            }
        }
        return gameState.currentTaxonImageCollection;
    },

    shouldRetryFetch(error, attempts, maxAttempts) {
        return attempts < maxAttempts && error.message.includes("No images found");
    },

    async handleFetchError(error) {
        if (error.message.includes("No images found")) {
            const taxonName = error.message.split("No images found for ")[1];
            ui.showOverlay(`Warning: No images found for ${taxonName}. Trying another pair...`, config.overlayColors.red);
            await utils.sleep(2000);
            this.nextSelectedPair = null;
        }
    },

    handleSetupError(error) {
        logger.error("Error setting up game:", error);
        ui.showOverlay("Error loading game. Please try again.", config.overlayColors.red);
        this.setState(GameState.IDLE);
        if (gameState.isInitialLoad) {
            this.hideLoadingScreen();
            updateGameState({ isInitialLoad: false });
        }
    },

    async initializeNewTaxonPair(pair = null) {

        const newPair = pair || await utils.selectTaxonPair();
        const [imageOneURL, imageTwoURL] = await Promise.all([
            api.fetchRandomImage(newPair.taxon1),
            api.fetchRandomImage(newPair.taxon2)
        ]);

        return {
            pair: newPair,
            imageOneURL,
            imageTwoURL,
            imageOneVernacular: null,
            imageTwoVernacular: null
        };
    },

    async loadCurrentTaxonImageCollection() {
        if (!gameState.currentTaxonImageCollection || !gameState.currentTaxonImageCollection.pair) {
            logger.error("currentTaxonImageCollection or its pair is null");
            throw new Error("Invalid currentTaxonImageCollection");
        }

        const { taxon1, taxon2 } = gameState.currentTaxonImageCollection.pair;
        // TODO not sure if for one or both pairs? one taxon should not have more than 12 images
        const MAX_IMAGES = 24; // Adjust this number as needed

        const [imageOneURLs, imageTwoURLs, imageOneVernacular, imageTwoVernacular] = await Promise.all([
            api.fetchMultipleImages(taxon1),
            api.fetchMultipleImages(taxon2),
            api.fetchVernacular(taxon1),
            api.fetchVernacular(taxon2)
        ]);

        updateGameState({
            currentTaxonImageCollection: {
                ...gameState.currentTaxonImageCollection,
                imageOneURLs: imageOneURLs.slice(0, MAX_IMAGES),
                imageTwoURLs: imageTwoURLs.slice(0, MAX_IMAGES),
                imageOneVernacular,
                imageTwoVernacular
            }
        });

        await preloader.preloadImages(imageOneURLs.slice(0, MAX_IMAGES).concat(imageTwoURLs.slice(0, MAX_IMAGES)));
    },

    async preloadImagesForCurrentPair() {
        const { pair } = gameState.currentTaxonImageCollection;

        try {
            const [newImageOneURL, newImageTwoURL] = await Promise.all([
                api.fetchRandomImageMetadata(pair.taxon1),
                api.fetchRandomImageMetadata(pair.taxon2)
            ]);

            await Promise.all([
                this.preloadImage(newImageOneURL),
                this.preloadImage(newImageTwoURL)
            ]);

            this.preloadedImages.current.taxon1.push(newImageOneURL);
            this.preloadedImages.current.taxon2.push(newImageTwoURL);

        } catch (error) {
            logger.error("Error preloading images for current pair:", error);
        }
    },

    preloadImage(url) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                resolve(url);
            };
            img.onerror = () => {
                logger.error(`Failed to load image: ${url}`);
                reject(url);
            };
            img.src = url;
        });
    },

    loadImages: async function (leftImageSrc, rightImageSrc) {
        await Promise.all([
            this.loadImageAndRemoveLoadingClass(elements.imageOne, leftImageSrc),
            this.loadImageAndRemoveLoadingClass(elements.imageTwo, rightImageSrc)
        ]);
    },

    async loadImageAndRemoveLoadingClass(imgElement, src) {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
                imgElement.src = src;
                imgElement.classList.remove('image-container__image--loading');
                // Add a slight delay before adding the 'loaded' class
                setTimeout(() => {
                    imgElement.classList.add('image-container__image--loaded');
                    resolve();
                }, 50); // 50ms delay to ensure the browser has time to apply the new src
            };
            img.src = src;
        });
    },

    async showTaxaRelationship() {
        const { taxonImageOne, taxonImageTwo } = gameState;
        const container = document.getElementById('taxa-relationship-graph');
        const dialog = document.getElementById('phylogeny-dialog');

        if (!taxonImageOne || !taxonImageTwo) {
            logger.error('Taxon names not available');
            alert('Unable to show relationship. Please try again after starting a new game.');
            return;
        }

        // Show the dialog
        dialog.style.display = 'flex'; // Change to flex to match the CSS layout
        dialogManager.openDialog('phylogeny-dialog');

        try {
            await taxaRelationshipViewer.initialize(container);

            if (this.currentGraphTaxa &&
                this.currentGraphTaxa[0] === taxonImageOne &&
                this.currentGraphTaxa[1] === taxonImageTwo) {
                logger.debug("Showing existing graph for the same taxa pair");
                taxaRelationshipViewer.showExistingGraph();
            } else {
                logger.debug("Creating new graph for a different taxa pair");
                taxaRelationshipViewer.clearGraph();
                await taxaRelationshipViewer.findRelationship(taxonImageOne, taxonImageTwo);
                this.currentGraphTaxa = [taxonImageOne, taxonImageTwo];
            }
        } catch (error) {
            logger.error('Error showing taxa relationship:', error);
            alert('Failed to load the relationship graph. Please try again later.');
            dialog.style.display = 'none'; // Hide the dialog on error
            dialogManager.closeDialog();
        }
    },

    prepareUIForLoading: function () {
        utils.resetDraggables();
        elements.imageOne.classList.add('image-container__image--loading');
        elements.imageTwo.classList.add('image-container__image--loading');
        var startMessage = gameState.isFirstLoad ? "Drag the names!" : `${this.loadingMessage}`;
        ui.showOverlay(startMessage, config.overlayColors.green);
        // what does this do?
        gameState.isFirstLoad = false;
    },

    async loadNewRandomPair() {
        if (this.currentState === GameState.LOADING) {
            logger.debug("Already loading a new pair, ignoring request");
            return;
        }

        logger.debug("Loading new random pair");
        this.setState(GameState.LOADING);
        ui.showOverlay(`${this.loadingMessage}`, config.overlayColors.green);
        elements.imageOne.classList.add('image-container__image--loading');
        elements.imageTwo.classList.add('image-container__image--loading');

        try {
            this.nextSelectedPair = null; // Ensure we're not using a previously selected pair
            await this.setupGame(true);
            ui.hideOverlay();
        } catch (error) {
            logger.error("Error loading new random pair:", error);
            ui.showOverlay("Error loading new pair. Please try again.", config.overlayColors.red);
        } finally {
            this.setState(GameState.PLAYING);
        }
    },

    // Update this method to set the nextSelectedPair
    async loadNewTaxonPair(newPair) {
        this.nextSelectedPair = newPair;
        await this.setupGame(true);
    },

    checkAnswer(droppedZoneId) {
        logger.debug("Checking answer. Current state:", this.currentState);

        if (this.currentState !== GameState.PLAYING) {
            logger.debug("Cannot check answer when not in PLAYING state");
            return;
        }

        this.setState(GameState.CHECKING);

        const dropOne = document.getElementById('drop-1');
        const dropTwo = document.getElementById('drop-2');
        const colorCorrect = config.overlayColors.green;
        const colorWrong = config.overlayColors.red;

        const leftAnswer = dropOne.children[0]?.getAttribute('data-taxon');
        const rightAnswer = dropTwo.children[0]?.getAttribute('data-taxon');

        if (leftAnswer || rightAnswer) {
            let isCorrect = false;
            if (droppedZoneId === 'drop-1') {
                isCorrect = leftAnswer === gameState.taxonImageOne;
            } else {
                isCorrect = rightAnswer === gameState.taxonImageTwo;
            }

            if (isCorrect) {
                this.handleCorrectAnswer();
            } else {
                this.handleIncorrectAnswer();
            }
        } else {
            logger.debug("Incomplete answer. Returning to PLAYING state.");
            this.setState(GameState.PLAYING);
        }
    },

    async handleCorrectAnswer() {
        await ui.showOverlay('Correct!', config.overlayColors.green);
        elements.imageOne.classList.add('image-container__image--loading');
        elements.imageTwo.classList.add('image-container__image--loading');
        await utils.sleep(2000); // Show "Correct!" for a while
        ui.updateOverlayMessage(`${this.loadingMessage}`); // Update message without changing color
        await this.setupGame(false);  // Start a new round with the same taxon pair
    },

    async handleIncorrectAnswer() {
        utils.resetDraggables();
        await ui.showOverlay('Try again!', config.overlayColors.red);
        await utils.sleep(1200);
        ui.hideOverlay();
        this.setState(GameState.PLAYING);
    },

    // determine height of tallest name tile, to keep layout stable over multiple rounds
    setNamePairHeight: function () {
        const leftName = document.getElementById('left-name');
        const rightName = document.getElementById('right-name');
        const namePair = document.querySelector('.name-pair');

        // Reset the height to auto to get the natural height
        leftName.style.height = 'auto';
        rightName.style.height = 'auto';
        namePair.style.height = 'auto';
        
        // Use requestAnimationFrame to ensure the browser has rendered the auto heights
        requestAnimationFrame(() => {
            const maxHeight = Math.max(leftName.offsetHeight, rightName.offsetHeight);
            
            // Set the height of the name-pair container
            namePair.style.height = `${maxHeight}px`;
            
            // Set both name tiles to this height
            leftName.style.height = `${maxHeight}px`;
            rightName.style.height = `${maxHeight}px`;
        });
    },

    setupNameTilesUI: function (leftName, rightName, leftNameVernacular, rightNameVernacular) {
        // Randomize the position of the name tiles
        const shouldSwap = Math.random() < 0.5;

        const nameOne = shouldSwap ? rightName : leftName;
        const nameTwo = shouldSwap ? leftName : rightName;
        const vernacularOne = shouldSwap ? rightNameVernacular : leftNameVernacular;
        const vernacularTwo = shouldSwap ? leftNameVernacular : rightNameVernacular;

        elements.leftName.setAttribute('data-taxon', nameOne);
        elements.rightName.setAttribute('data-taxon', nameTwo);
        elements.leftName.style.zIndex = '10';
        elements.rightName.style.zIndex = '10';

        // Create a span for the taxon name and a span for the vernacular name
        elements.leftName.innerHTML = `
            <span class="name-pair__taxon-name">${nameOne}</span>
            ${vernacularOne ? `<span class="name-pair__vernacular-name">${vernacularOne}</span>` : ''}
        `;
        elements.rightName.innerHTML = `
            <span class="name-pair__taxon-name">${nameTwo}</span>
            ${vernacularTwo ? `<span class="name-pair__vernacular-name">${vernacularTwo}</span>` : ''}
        `;

        gameState.taxonLeftName = nameOne;
        gameState.taxonRightName = nameTwo;

    },

    finishSetup: function () {
        ui.hideOverlay();
    },

    // TODO for now only gives photo page
    getObservationURLFromImageURL(imageURL) {
        const match = imageURL.match(/\/photos\/(\d+)\//);
        if (match && match[1]) {
            return `https://www.inaturalist.org/photos/${match[1]}`;
        }
        return null;
    },

    initializeInfoButtons() {
        const infoButton1 = document.getElementById('info-button-1');
        const infoButton2 = document.getElementById('info-button-2');

        infoButton1.addEventListener('click', () => this.showInfoDialog(this.currentObservationURLs.imageOne, 1));
        infoButton2.addEventListener('click', () => this.showInfoDialog(this.currentObservationURLs.imageTwo, 2));
    },

    openObservationURL(url) {
        if (url) {
            this.showInfoDialog(url);
        } else {
            logger.error('Observation URL not available');
        }
    },

    showInfoDialog(url, imageIndex) {
        const dialog = document.getElementById('info-dialog');
        const taxonElement = document.getElementById('info-dialog-taxon');
        const vernacularElement = document.getElementById('info-dialog-vernacular');
        const factsElement = document.getElementById('info-dialog-facts');
        const photoButton = document.getElementById('photo-button');
        const observationButton = document.getElementById('observation-button');
        const taxonButton = document.getElementById('taxon-button');
        const hintsButton = document.getElementById('hints-button');
        const wikiButton = document.getElementById('wiki-button');
        const reportButton = document.getElementById('report-button');
        const closeButton = document.getElementById('info-close-button');

        // Get the image containers
        const topImageContainer = document.getElementById('image-container-1');
        const bottomImageContainer = document.getElementById('image-container-2');
        const namePairContainer = document.querySelector('.name-pair');

        // Position the dialog
        const positionDialog = () => {
            const dialogRect = dialog.getBoundingClientRect();
            const topContainerRect = topImageContainer.getBoundingClientRect();
            const bottomContainerRect = bottomImageContainer.getBoundingClientRect();
            const namePairRect = namePairContainer.getBoundingClientRect();

            if (imageIndex === 1) {
                // For the top image
                dialog.style.top = `${namePairRect.top}px`;
                dialog.style.bottom = `${window.innerHeight - bottomContainerRect.bottom}px`;
                dialog.style.height = 'auto'; // Let the height adjust automatically
            } else {
                // For the bottom image
                dialog.style.top = `${topContainerRect.top}px`;
                dialog.style.bottom = `${window.innerHeight - namePairRect.bottom}px`;
                dialog.style.height = 'auto'; // Let the height adjust automatically
            }

            // Center horizontally
            dialog.style.left = `${(window.innerWidth - dialogRect.width) / 2}px`;
        };

        // Frame the corresponding image if imageIndex is provided
        if (imageIndex) {
            const imageContainer = document.getElementById(`image-container-${imageIndex}`);
            if (imageContainer) {
                imageContainer.classList.add('image-container--framed');
            }
        }

        // Set taxon and vernacular name
        const currentTaxon = this.getCurrentTaxonName(url);
        taxonElement.textContent = currentTaxon;

        api.getVernacularName(currentTaxon).then(vernacularName => {
            vernacularElement.textContent = vernacularName;

            // Add taxon facts (assuming they're still in taxonInfo.json)
            api.loadTaxonInfo().then(taxonInfo => {
                const taxonData = Object.values(taxonInfo).find(info => info.taxonName.toLowerCase() === currentTaxon.toLowerCase());
                if (taxonData && taxonData.taxonFacts && taxonData.taxonFacts.length > 0) {
                    factsElement.innerHTML = '<h3>Facts:</h3><ul>' + 
                        taxonData.taxonFacts.map(fact => `<li>${fact}</li>`).join('') + 
                        '</ul>';
                    factsElement.style.display = 'block';
                } else {
                    factsElement.style.display = 'none';
                }

                // Position the dialog after content is loaded
                dialog.setAttribute('open', ''); // Explicitly set the 'open' attribute
                positionDialog();
            });
        });

            photoButton.onclick = () => {
                window.open(url, '_blank');
                dialog.close();
            };

            observationButton.onclick = () => {
                logger.debug("Observation button clicked");
                // Implement observation functionality here
            };

            taxonButton.onclick = async () => {
                logger.debug("Taxon button clicked");
                try {
                    const taxonName = this.getCurrentTaxonName(url);
                    const taxonId = await api.fetchTaxonId(taxonName);
                    window.open(`https://www.inaturalist.org/taxa/${taxonId}`, '_blank');
                    dialog.close();
                } catch (error) {
                    logger.error("Error opening taxon page:", error);
                    alert("Unable to open taxon page. Please try again.");
                }
            };

            hintsButton.onclick = () => {
                logger.debug("Taxon hints button clicked");
                // Implement taxon hints functionality here
            };

            wikiButton.onclick = () => {
                logger.debug("Wiki button clicked");
                try {
                    const taxonName = this.getCurrentTaxonName(url);
//                    const taxonId = await api.fetchTaxonId(taxonName);
                    window.open(`https://en.wikipedia.org/wiki/${taxonName}`, '_blank');
                    dialog.close();
                } catch (error) {
                    logger.error("Error opening taxon page:", error);
                    alert("Unable to open Wikipedia page. Please try again.");
                }
            };

            reportButton.onclick = () => {
                logger.debug("Report button clicked");
                // Implement report functionality here
            };

            closeButton.onclick = () => {
                dialog.close();
                document.querySelectorAll('.image-container').forEach(container => {
                    container.classList.remove('image-container--framed');
                });
            };

            dialog.addEventListener('close', () => {
                // Remove framing from all containers when dialog is closed
                document.querySelectorAll('.image-container').forEach(container => {
                    container.classList.remove('image-container--framed');
                });
            });

            dialog.showModal();
        // Reposition on window resize
        window.addEventListener('resize', positionDialog);

        },

    getCurrentTaxonName(url) {
        if (url === this.currentObservationURLs.imageOne) {
            return gameState.taxonImageOne;
        } else if (url === this.currentObservationURLs.imageTwo) {
            return gameState.taxonImageTwo;
        } else {
            logger.error("Unable to determine current taxon name");
            return null;
        }
    },

};

// Initialize info buttons
game.initializeInfoButtons();

export default game;



# code/state.js

// Elements and game state

// DOM elements
export const elements = {
  imageOne: document.getElementById('image-1'),
  imageTwo: document.getElementById('image-2'),
  imageOneContainer: document.getElementById('image-container-1'),
  imageTwoContainer: document.getElementById('image-container-2'),
  namePair: document.querySelector('.name-pair'),
  leftName: document.getElementById('left-name'),
  rightName: document.getElementById('right-name'),
  overlay: document.getElementById('overlay'),
  overlayMessage: document.getElementById('overlay-message'),
  buttons: document.querySelectorAll('.bottom-button')
};

// Game State enum
export const GameState = {
  IDLE: 'IDLE',
  LOADING: 'LOADING',
  READY: 'READY',
  PLAYING: 'PLAYING',
  CHECKING: 'CHECKING',
  PRELOADING: 'PRELOADING',
  PRELOADING_BACKGROUND: 'PRELOADING_BACKGROUND'
};

export const gameState = {
  preloadState: {
    currentRound: {
      taxon1: null,
      taxon2: null
    },
    nextRound: {
      taxon1: null,
      taxon2: null
    },
    nextPair: {
      taxon1: null,
      taxon2: null
    },
  },
    selectedTags: [],

  // check which of these still used:
  isFirstLoad: true,
  isInitialLoad: true,
  isPreloading: false,
  preloadedPair: null,
  currentSession: 1,
  /*   currentRound: 1, */
  roundPreload: null,
  pairPreload: null,

  currentRound: {
    pair: null,
    imageOneURLs: [],
    imageTwoURLs: [],
    imageOneVernacular: null,
    imageTwoVernacular: null,
    randomized: false
  },

    usedImages: {
        taxon1: new Set(),
        taxon2: new Set()
    },

  preloadedTaxonImageCollection: null,
  currentTaxonImageCollection: null,
  taxonImageOne: null,
  taxonImageTwo: null,
  taxonLeftName: null,
  taxonRightName: null,
  currentState: GameState.IDLE  // track the current game state
};

// Function to update game state
export function updateGameState(newState) {
  Object.assign(gameState, newState);
}



# code/ui.js

import api from './api.js';
import config from './config.js';
import dialogManager from './dialogManager.js';
import { elements, gameState } from './state.js';
import game from './game.js';
import logger from './logger.js';
import utils from './utils.js';

const ui = {
    isMenuOpen: false,

    resetUIState: function() {
        this.closeMainMenu();
        // Add any other UI state resets here if needed
    },

    resetGameContainerStyle: function () {
        const gameContainer = document.querySelector('.game-container');
        if (gameContainer) {
            gameContainer.style.transform = '';
            gameContainer.style.opacity = '';
        }
        elements.imageOneContainer.style.transform = '';
        elements.imageOneContainer.style.opacity = '';
        elements.imageTwoContainer.style.transform = '';
        elements.imageTwoContainer.style.opacity = '';
    },

    // display pair list for selection
    showTaxonPairList: function () {
        api.fetchTaxonPairs().then(taxonPairs => {
            if (taxonPairs.length === 0) {
                logger.error("No taxon pairs available");
                return;
            }

            const list = document.getElementById('taxon-pair-list');
            const searchInput = document.getElementById('taxon-search');
            const clearButton = document.getElementById('clear-search');
            
            // Clear the search input and hide the clear button
            searchInput.value = '';
            clearButton.style.display = 'none';

            list.innerHTML = ''; // Clear existing content

            const createTaxonPairButton = (pair, vernacular1, vernacular2) => {
                const button = document.createElement('button');
                button.className = 'taxon-set-button';
                button.innerHTML = `
                    <div class="taxon-set-container">
                        <div class="taxon-set-info">
                            <div class="set-name">${pair.setName}</div>
                            <div class="tags">${pair.tags.join(', ')}</div>
                        </div>
                        <div class="taxon-item">
                            <div class="taxon-name">${pair.taxon1}</div>
                            <div class="vernacular-name">${vernacular1}</div>
                        </div>
                        <div class="taxon-item">
                            <div class="taxon-name">${pair.taxon2}</div>
                            <div class="vernacular-name">${vernacular2}</div>
                        </div>
                    </div>
                `;

                button.onclick = () => {
                    // Remove selection from all buttons
                    document.querySelectorAll('.taxon-set-button').forEach(btn => {
                        btn.classList.remove('taxon-set-button--selected');
                    });
                    
                    // Add selection to clicked button
                    button.classList.add('taxon-set-button--selected');

                    game.nextSelectedPair = pair;
                    // Don't close the dialog immediately to allow the user to see the selection
                    setTimeout(() => {
                        dialogManager.closeDialog();
                        game.setupGame(true);
                    }, 300); // 300ms delay before closing
                };
                return button;
            };

            const renderFilteredList = async (filter = '') => {
                const fragment = document.createDocumentFragment();
                const lowerFilter = filter.toLowerCase();
                for (const pair of taxonPairs) {
                    const vernacular1 = await api.getVernacularName(pair.taxon1);
                    const vernacular2 = await api.getVernacularName(pair.taxon2);
                    
                    const matchesTaxon = pair.taxon1.toLowerCase().includes(lowerFilter) || 
                                         pair.taxon2.toLowerCase().includes(lowerFilter);
                    const matchesVernacular = vernacular1.toLowerCase().includes(lowerFilter) || 
                                              vernacular2.toLowerCase().includes(lowerFilter);
                    const matchesSetName = pair.setName.toLowerCase().includes(lowerFilter);
                    const matchesTags = pair.tags.some(tag => tag.toLowerCase().includes(lowerFilter));
                    
                    if (matchesTaxon || matchesVernacular || matchesSetName || matchesTags) {
                        const button = createTaxonPairButton(pair, vernacular1, vernacular2);
                        fragment.appendChild(button);
                    }
                }
                list.innerHTML = '';
                list.appendChild(fragment);
            };

            (async () => {
                await renderFilteredList(); // Initial render with all pairs
            })();

            const debouncedFilter = utils.debounce(async (event) => {
                const filter = event.target.value.toLowerCase();
                await renderFilteredList(filter);
            }, 300);

            searchInput.addEventListener('input', (event) => {
                clearButton.style.display = event.target.value ? 'block' : 'none';
                debouncedFilter(event);
            });

            clearButton.addEventListener('click', () => {
                searchInput.value = '';
                clearButton.style.display = 'none';
                renderFilteredList();
                searchInput.focus();
            });

            dialogManager.openDialog('select-pair-dialog');

            // Focus on the search input when the dialog opens
            setTimeout(() => searchInput.focus(), 100);
        });
    },

    showOverlay: function (message = "", color) {
        elements.overlayMessage.innerHTML = message;
        elements.overlay.style.backgroundColor = color;
        elements.overlay.classList.add('show');

        // Adjust font size for longer messages
        if (message.length > 20) {
            elements.overlayMessage.style.fontSize = '1.4em';
        } else {
            elements.overlayMessage.style.fontSize = '2.4em';
        }
    },

    // Update this method to change only the message, not the visibility
    updateOverlayMessage: function (message) {
        const overlayMessage = document.getElementById('overlay-message');
        overlayMessage.innerHTML = message;

        // Adjust font size for longer messages
        if (message.length > 20) {
            overlayMessage.style.fontSize = '1.6em';
        } else {
            overlayMessage.style.fontSize = '2.4em';
        }
    },

    hideOverlay: function () {
        elements.overlay.classList.remove('show');
    },

    showINatDownDialog: function () {
        const loadingScreen = document.getElementById('loading-screen');
        if (loadingScreen) {
            loadingScreen.style.display = 'none';
        }

        dialogManager.openDialog('inat-down-dialog');

        const checkStatusBtn = document.getElementById('check-inat-status');
        const retryConnectionBtn = document.getElementById('retry-connection');

        const checkStatusHandler = () => {
            window.open('https://inaturalist.org', '_blank');
        };

        const retryConnectionHandler = async () => {
            dialogManager.closeDialog();
            if (await api.isINaturalistReachable()) {
                game.setupGame(true);
            } else {
                this.showINatDownDialog();
            }
        };

        checkStatusBtn.addEventListener('click', checkStatusHandler);
        retryConnectionBtn.addEventListener('click', retryConnectionHandler);
    },

    hideINatDownDialog: function () {
        dialogManager.closeDialog();
    },

    showTutorial: function () {
        const steps = [
            { message: "Welcome to DuoNat!<br>Let's learn how to play.", highlight: null, duration: 4000 },
            { message: "You'll see two images of different taxa.", highlights: ['#image-container-1', '#image-container-2'], duration: 5000 },
            { message: "Drag a name to the correct image.", highlight: '.name-pair', duration: 5000 },
            { message: "If correct, you'll move to the next round.", highlight: null, duration: 4000 },
            { 
                message: "Swipe left on an image for a new taxon set.", 
                highlight: null,
                action: () => { this.tiltGameContainer(3200); },
                duration: 6000
            },
            { message: "Get more info about a taxon.", highlights: ['#info-button-1', '#info-button-2'], duration: 6000 },
            { message: "Tap the menu for more functions.", highlight: '#menu-toggle', action: () => this.temporarilyOpenMenu(6000), duration: 6000 },
            { message: "Ready to start?<br>Let's go!", highlight: null, duration: 2000 }
        ];

        let currentStep = 0;
        let highlightElements = [];

        const showStep = () => {
            if (currentStep < steps.length) {
                const step = steps[currentStep];
                this.updateOverlayMessage(step.message);

                highlightElements.forEach(el => el.remove());
                highlightElements = [];

                if (step.highlight) {
                    const highlight = this.createHighlight(step.highlight);
                    if (highlight) highlightElements.push(highlight);
                } else if (step.highlights) {
                    step.highlights.forEach(selector => {
                        const highlight = this.createHighlight(selector);
                        if (highlight) highlightElements.push(highlight);
                    });
                }

                if (step.action) {
                    step.action();
                }

                currentStep++;
                setTimeout(showStep, step.duration); // Use the step's duration
            } else {
                this.hideOverlay();
                highlightElements.forEach(el => el.remove());
            }
        };

        // Close the help dialog before starting the tutorial
        document.getElementById('help-dialog').close();
        
        // Show the overlay at the start of the tutorial
        this.showOverlay("", config.overlayColors.green);
        
        // Start the tutorial
        showStep();
    },

    temporarilyOpenMenu: function(duration) {
      this.toggleMainMenu(); // Open the menu
      setTimeout(() => {
        this.closeMainMenu(); // Close the menu after the specified duration
      }, duration);
    },

    // for tutorial demo
    tiltGameContainer: function(duration = 3200) {
        const gameContainer = document.querySelector('.game-container');
        const midpoint = duration / 2;

        // Initial tilt
        gameContainer.style.transition = `transform ${midpoint}ms ease-out, opacity ${midpoint}ms ease-out`;
        gameContainer.style.transform = 'rotate(-3deg) translateX(-50px)';
        gameContainer.style.opacity = '0.7';

        // Return to original position
        setTimeout(() => {
            gameContainer.style.transition = `transform ${midpoint}ms ease-in, opacity ${midpoint}ms ease-in`;
            gameContainer.style.transform = '';
            gameContainer.style.opacity = '';
        }, midpoint);

        // Clean up
        setTimeout(() => {
            gameContainer.style.transition = '';
        }, duration);
    },

    createHighlight: function (targetSelector) {
        const target = document.querySelector(targetSelector);
        if (!target) {
            logger.error(`Target element not found: ${targetSelector}`);
            return null;
        }

        const highlight = document.createElement('div');
        highlight.className = 'tutorial-highlight';
        document.body.appendChild(highlight);

        const targetRect = target.getBoundingClientRect();
        highlight.style.width = `${targetRect.width}px`;
        highlight.style.height = `${targetRect.height}px`;
        highlight.style.top = `${targetRect.top}px`;
        highlight.style.left = `${targetRect.left}px`;

        return highlight;
    },

    toggleKeyboardShortcuts: function () {
        const keyboardShortcutsSection = document.getElementById('keyboard-shortcuts');
        if (utils.hasKeyboard()) {
            keyboardShortcutsSection.style.display = 'block';
        } else {
            keyboardShortcutsSection.style.display = 'none';
        }
    },

    initializeHelpDialog: function () {
        document.getElementById('help-button').addEventListener('click', () => {
            this.toggleKeyboardShortcuts();
            dialogManager.openDialog('help-dialog');
        });
    },

    initializeInfoDialog: function () {
        const infoDialog = document.getElementById('info-dialog');

        // Check if the device has a keyboard
        if (utils.hasKeyboard()) {
            document.body.classList.add('has-keyboard');
        }

        const handleKeyPress = (event) => {
            if (!infoDialog.open) return; // Only handle keypresses when the dialog is open

            event.stopPropagation();
            const key = event.key.toLowerCase();
            const buttonMap = {
                'p': 'photo-button',
                'h': 'hints-button',
                'o': 'observation-button',
                't': 'taxon-button',
                'w': 'wiki-button',
                'r': 'report-button'
            };

            if (buttonMap[key]) {
                event.preventDefault();
                document.getElementById(buttonMap[key]).click();
            } else if (key === 'escape') {
                event.preventDefault();
                infoDialog.close();
            }
        };

        document.addEventListener('keydown', handleKeyPress);
    },

    // main menu code:
    initializeMainMenu: function() {
        const menuToggle = document.getElementById('menu-toggle');
        if (menuToggle) {
            menuToggle.addEventListener('click', (event) => {
//                logger.debug('Menu toggle button or its child clicked');
                event.stopPropagation();
                this.toggleMainMenu();
            });
        } else {
            logger.error('Menu toggle button not found');
        }

        window.addEventListener('resize', this.positionBottomGroup.bind(this));
        
        // Call once to set initial position
        this.positionBottomGroup();

        // Close the dropdown when clicking outside of it
        document.addEventListener('click', (event) => {
            if (!event.target.closest('.main-menu')) {
                this.closeMainMenu();
            }
        });
    },

    toggleMainMenu: function() {
        this.isMenuOpen = !this.isMenuOpen;

        const topGroup = document.querySelector('.main-menu__dropdown--top');
        const bottomGroup = document.querySelector('.main-menu__dropdown--bottom');

        if (topGroup && bottomGroup) {
            topGroup.classList.toggle('show');
            bottomGroup.classList.toggle('show');
//            logger.debug("Show classes toggled");

            if (this.isMenuOpen) {
                this.positionBottomGroup();
            }
        } else {
            logger.error('Dropdown groups not found');
        }
    },

    positionBottomGroup: function() {
        const bottomGroup = document.querySelector('.main-menu__dropdown--bottom');
        const lowerImageContainer = document.querySelector('#image-container-2');
        
        if (bottomGroup && lowerImageContainer) {
            const rect = lowerImageContainer.getBoundingClientRect();
            bottomGroup.style.top = `${rect.top}px`;
            bottomGroup.style.right = `0px`; // Adjust if needed
        }
    },

    closeMainMenu: function() {
        if (this.isMenuOpen) {
            const topGroup = document.querySelector('.main-menu__dropdown--top');
            const bottomGroup = document.querySelector('.main-menu__dropdown--bottom');
            if (topGroup && bottomGroup) {
                this.isMenuOpen = false;
                topGroup.classList.remove('show');
                bottomGroup.classList.remove('show');
            }
        }
    },

    initialize: function () {
        this.initializeHelpDialog();
        this.initializeInfoDialog();
        this.initializeMainMenu();
        this.closeMainMenu(); // Ensure menu is closed on initialization
        // Close the dropdown when clicking outside of it
        document.addEventListener('click', (event) => {
            if (!event.target.closest('.main-menu')) {
                this.closeMainMenu();
            }
        });
    },

};

export default ui;




# code/utils.js

// Utility functions

import api from './api.js';
import game from './game.js';
import { gameState, updateGameState } from './state.js';
import logger from './logger.js';
import tagCloud from './tagCloud.js';

const utils = {

    // optionally get pair of taxa from URL
    getURLParameters: function () {
        const params = new URLSearchParams(window.location.search);
        const taxon1 = params.get('taxon1');
        const taxon2 = params.get('taxon2');
        if (taxon1 && taxon2) {
            return { taxon1, taxon2 };
        }
        return null;
    },

    debounce: function (func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const context = this;
            const later = () => {
                clearTimeout(timeout);
                func.apply(context, args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    },

    // trying out things button
    surprise: function () {
        logger.debug("Surprise!");
        //        game.showTaxaRelationship();
        //this.fart();
        this.randomAnimalSound();
    },

    randomAnimalSound: async function () {
        try {
            // Fetch random observations with sounds
            const url = "https://api.inaturalist.org/v1/observations?order_by=random&sounds=true";
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error('Failed to fetch observations');
            }
            const data = await response.json();

            // Filter observations with sounds
            const observationsWithSounds = data.results.filter(obs => obs.sounds && obs.sounds.length > 0);

            if (observationsWithSounds.length > 0) {
                // Choose a random observation
                const randomObservation = observationsWithSounds[Math.floor(Math.random() * observationsWithSounds.length)];
                
                // Extract the sound URL
                const soundUrl = randomObservation.sounds[0].file_url;

                if (soundUrl) {
                    // Create and play the audio
                    const audio = new Audio(soundUrl);
                    await audio.play();
                    logger.info(`Playing sound from observation: ${randomObservation.species_guess || 'Unknown species'}`);
                } else {
                    logger.warn("Sound URL not found in the selected observation.");
                }
            } else {
                logger.warn("No observations with sounds found.");
            }
        } catch (error) {
            logger.error('Could not play animal sound:', error);
        }
    },

    fart: function () {
        // placeholder
        const soundUrl = './sound/fart.mp3';
        // Create a new Audio object

        const audio = new Audio(soundUrl);
        audio.play({ playbackMode: 'background' })
            .then(() => { logger.info("Everybody plays their fart."); /* Audio started playing successfully*/ }).catch(error => { logger.error('Could not play my fart:', error); });
    },

    hasKeyboard: function () {
        // Check if the device is mobile
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // Check if it's a tablet
        const isTablet = /(tablet|ipad|playbook|silk)|(android(?!.*mobile))/i.test(navigator.userAgent);

        // If it's not mobile and not a tablet, assume it has a keyboard
        const result = !isMobile && !isTablet;

//        logger.debug(`hasKeyboard detected: ${result}`);
//        logger.debug(`UserAgent: ${navigator.userAgent}`);

        return result;
    },

    debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    },

    sleep: function (ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    },

    resetDraggables: function () {
        const leftNameContainer = document.getElementsByClassName('name-pair__container--left')[0];
        const rightNameContainer = document.getElementsByClassName('name-pair__container--right')[0];
        const dropOne = document.getElementById('drop-1');
        const dropTwo = document.getElementById('drop-2');

        // Move draggables back to the names container
        leftNameContainer.appendChild(document.getElementById('left-name'));
        rightNameContainer.appendChild(document.getElementById('right-name'));

        // Clear drop zones
        dropOne.innerHTML = ''; dropTwo.innerHTML = '';
    },

    capitalizeFirstLetter: function (string) {
        if (!string) {
            return '';
        } else { return string.charAt(0).toUpperCase() + string.slice(1); }
    },

    shortenSpeciesName: function (string) {
        if (!string) { return ''; }

        let parts = string.split(' ');
        if (parts.length < 2) {
            return string; // Return the original string if it doesn't contain at least two parts
        }

        let genusInitial = parts[0].charAt(0).toUpperCase() + '.';
        let species = parts.slice(1).join(' '); // Join the remaining parts in case the species name has multiple words

        return genusInitial + ' ' + species;
    },

    // Returns a taxon pair from the index, or a random one if none indicated
    selectTaxonPair: async function (index = null) {
        const taxonPairs = await api.fetchTaxonPairs();
        if (taxonPairs.length === 0) {
            logger.error("No taxon pairs available");
            return null;
        }

        let filteredPairs = taxonPairs;

        if (gameState.selectedTags.length > 0) {
            filteredPairs = taxonPairs.filter(pair => 
                pair.tags.some(tag => gameState.selectedTags.includes(tag))
            );
        }

        if (filteredPairs.length === 0) {
            logger.warn("No pairs match the selected tags. Using all pairs.");
            filteredPairs = taxonPairs;
        }

        return index !== null ? filteredPairs[index] : filteredPairs[Math.floor(Math.random() * filteredPairs.length)];
    }

}; // const utils

export default utils;



# code/preloader.js

import api from './api.js';
import { gameState, updateGameState } from './state.js';
import logger from './logger.js';
import utils from './utils.js';

const preloader = {
  preloadedImages: {
    nextRound: { taxon1: null, taxon2: null },
    nextPair: { taxon1: null, taxon2: null, pair: null }
  },

  async preloadImage(url) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(url);
      img.onerror = () => reject(new Error(`Failed to load image: ${url}`));
      img.src = url;
    });
  },

    async preloadForNextRound() {
        const { pair, imageOneURL, imageTwoURL } = gameState.currentTaxonImageCollection;
        const [newImageOneURL, newImageTwoURL] = await Promise.all([
            this.fetchDifferentImage(pair.taxon1, imageOneURL),
            this.fetchDifferentImage(pair.taxon2, imageTwoURL)
        ]);
        
        await Promise.all([
            this.preloadImage(newImageOneURL),
            this.preloadImage(newImageTwoURL)
        ]);

        this.preloadedImages.nextRound = { taxon1: newImageOneURL, taxon2: newImageTwoURL };
        logger.debug("Preloaded images for next round");
    },

    async fetchDifferentImage(taxonName, currentImageURL) {
        const images = await api.fetchMultipleImages(taxonName, 12);
        const taxonKey = taxonName === gameState.currentTaxonImageCollection.pair.taxon1 ? 'taxon1' : 'taxon2';
        let usedImages = gameState.usedImages[taxonKey];
        
        // Filter out the current image and any previously used images
        let availableImages = images.filter(img => !usedImages.has(img) && img !== currentImageURL);
        
        // If we've used all images, reset the used images but still avoid the current image
        if (availableImages.length === 0) {
            logger.warn(`All images for ${taxonName} have been used. Resetting used images.`);
            usedImages = new Set([currentImageURL]);
            availableImages = images.filter(img => img !== currentImageURL);
        }
        
        if (availableImages.length > 0) {
            const selectedImage = availableImages[Math.floor(Math.random() * availableImages.length)];
            usedImages.add(selectedImage);
            updateGameState({ 
                usedImages: { 
                    ...gameState.usedImages, 
                    [taxonKey]: usedImages 
                } 
            });
            return selectedImage;
        } else {
            // This should rarely happen, but just in case
            logger.error(`No available images found for ${taxonName}. Using current image.`);
            return currentImageURL;
        }
    },

    async preloadForNextPair() {
        if (this.preloadedImages.nextPair.pair) {
            logger.debug("Skipping preload for next pair as one is already available");
            return;
        }

        const newPair = await utils.selectTaxonPair();
        const [imageOneURL, imageTwoURL] = await Promise.all([
            this.fetchDifferentImage(newPair.taxon1, null),
            this.fetchDifferentImage(newPair.taxon2, null)
        ]);
        
        await Promise.all([
            this.preloadImage(imageOneURL),
            this.preloadImage(imageTwoURL)
        ]);

        this.preloadedImages.nextPair = { 
            pair: newPair,
            taxon1: imageOneURL, 
            taxon2: imageTwoURL 
        };
        logger.debug("Preloaded images for next pair");
    },

  getPreloadedImagesForNextRound() {
    const images = this.preloadedImages.nextRound;
    this.preloadedImages.nextRound = { taxon1: null, taxon2: null };
    return images;
  },

  getPreloadedImagesForNextPair() {
    const images = this.preloadedImages.nextPair;
    this.preloadedImages.nextPair = { taxon1: null, taxon2: null, pair: null };
    return images;
  },

  hasPreloadedPair() {
    return !!this.preloadedImages.nextPair.pair;
  },

    async preloadNewPairWithTags(selectedTags) {
        if (this.isPreloading) {
            logger.debug("Preloading already in progress, skipping tag-based preload");
            return;
        }

        this.isPreloading = true;
        logger.debug(`Selected tags: ${selectedTags}`);
        try {
            const newPair = await utils.selectTaxonPair();
            if (!newPair) {
                logger.warn("No pair found matching selected tags");
                return;
            }

            const [imageOneURL, imageTwoURL] = await Promise.all([
                this.fetchDifferentImage(newPair.taxon1, null),
                this.fetchDifferentImage(newPair.taxon2, null)
            ]);
            
            await Promise.all([
                this.preloadImage(imageOneURL),
                this.preloadImage(imageTwoURL)
            ]);

            this.preloadedImages.nextPair = { 
                pair: newPair,
                taxon1: imageOneURL, 
                taxon2: imageTwoURL 
            };
            logger.debug("Preloaded new pair based on selected tags");
        } catch (error) {
            logger.error("Error preloading new pair with tags:", error);
        } finally {
            this.isPreloading = false;
        }
    },

};

export default preloader;



# styles/base.css

/* Mostly styles for main page */

/* CSS reset */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

/* Custom properties */
:root {
    --primary-color: #74ac00; /* iNat green rgb(116, 172, 0) */
    --primary-counter-color: #ac0028; /* red rgb(172, 0, 40) */
    --light-green: rgba(116, 172, 0, 0.1);
    --dark-neutral-color: #444;
    --background-color: #ffffff;
    --text-color: #ffffff;
    --counter-text-color: #444;
    --shadow-color: rgba(0, 0, 0, 0.1);
    --overlay-color: rgba(0, 0, 0, 0.3);

    --normal-font-size: 18px;
    --border-radius: 8px;
    --max-image-width: 500px;
    --transition-speed: 0.3s;
    /* images wobble when <80px */
    --center-min-height: 80px; /* consider relative to screen */
}

body {
    display: flex;
    flex-direction: column;
    height: 100vh;
    margin: 0;
    padding: 0;
    overflow: auto;
    box-sizing: border-box;
    font-family: 'Open Sans', Arial, sans-serif;
    background-color: var(--light-green);
}

body * {
    text-align: center;
} /* percolate to child elements */

/* Other general styles */

button {
    outline: none;
    box-shadow: none;
    -webkit-tap-highlight-color: transparent;
}

/* remove black border when active */
.no-outline {
    outline: none;
    box-shadow: none;
    -webkit-tap-highlight-color: transparent;
}

.game-container {
    flex: none;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    height: 100vh;
    padding: 0;
    overflow: hidden;
    box-sizing: border-box;
    transition: transform 0.1s ease-out, opacity 0.1s ease-out;
}

.underline {
    text-decoration: underline;
}

/* Styles common to all main containers */
.image-container,
.name-pair,
#overlay {
    width: 98vw;
    max-width: var(--max-image-width);
}

/* Animation keyframes etc. */
@keyframes dropAnimation {
    0% {
        transform: scale(1.1);
    }
    100% {
        transform: scale(1);
    }
}

.drop-animation {
    animation: dropAnimation 0.3s ease-out forwards;
}

@keyframes swipeOutLeft {
    to {
        transform: rotate(-5deg) translateX(-100%);
        opacity: 0;
    }
}

.swipe-out-left {
    animation: swipeOutLeft 0.5s ease-out forwards;
}

.swipe-info-message {
    position: absolute;
    top: 40px;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(255, 255, 255, 0.8);
    color: var(--dark-neutral-color);
    height: fit-content;
    width: auto;
    max-width: 80%;
    padding: 6px 15px;
    border-radius: 15px;
    font-size: larger;
    white-space: nowrap;
    opacity: 0;
    transition: opacity 0.3s, transform 0.3s;
    pointer-events: none;
    z-index: 1000;
}




# styles/components.css





# styles/main.css

@import 'base.css';
@import 'components/loading.css';
@import 'components/menu.css';
@import 'components/buttons.css';
@import 'components/dialogs.css';

@import 'layout/image-container.css';
@import 'layout/name-pair.css';

@import 'components/tooltips.css';

/*
@import 'components/forms.css';
@import 'components/icons.css';
*/



# styles/components/buttons.css

/* For icons in general */
.icon {
  width: 24px;
  height: 24px;
  fill: var(--dark-neutral-color);
  transition: transform 0.2s ease, fill 0.2s ease;
}

.icon:hover, .icon-button:hover {
  transform: scale(1.1);
}

.icon:active, .icon-button:active {
  transform: scale(0.95);
}

/* For buttons containing icons */
.icon-button {
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: rgba(255, 255, 255, 0.6);
  border: none;
  border-radius: 50%;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  cursor: pointer;
  width: 40px;
  height: 40px;
  transition: background-color var(--transition-speed) ease, transform 0.2s ease;
}

.icon-button:hover {
  background: rgba(255, 255, 255, 0.8);
}


#help-button {
    position: fixed;
    top: 10px;
    right: 60px;
    z-index: 1000;
}

#like-button {
    fill: var(--primary-color);
}
#trash-button {
    fill: var(--primary-counter-color);
}

/* Styles for image button containers */

.image-container__buttons {
    position: absolute;
    left: 10px;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
}

#image-buttons-1,
#image-buttons-2 {
    bottom: 10px;
}

.image-container__button {
    margin-bottom: 10px;
    width: 36px;
    height: 36px;
}

/* Responsive adjustments */
@media (max-width: 480px) {
    .image-container__button {
        width: 32px;
        height: 32px;
    }

    .image-container__button-icon {
        width: 20px;
        height: 20px;
    }
}




# styles/components/dialogs.css

/* Generic dialog style */

dialog {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  margin: 0;
}

.standard-dialog {
    background-color: white;
    border-radius: 12px;
    border: none;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    width: 95%;
    max-width: 500px;
    max-height: 95vh;
    padding: 40px 20px 20px;
z-index: 5000; /* debug */
}

.dialog-title {
    color: var(--primary-counter-color);
    text-align: center;
    margin: 0 0 20px 0;
    font-size: 1.5em;
}

.dialog-close-button {
    position: absolute;
    top: 10px;
    right: 10px;
    background: none;
    font-size: 2em;
    color: var(--primary-counter-color);                
    outline: none;
    border: none;
    box-shadow: none;
    -webkit-tap-highlight-color: transparent; /* Removes tap highlight on iOS */
    cursor: pointer;
    padding: 5px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.3s ease;
    border-radius: 50%;
    z-index: 10;
}

/*.dialog-close-button:focus-visible {
    background-color: rgba(0, 0, 0, 0.1);
    box-shadow: 0 0 0 2px var(--primary-counter-color);
}*/

/* Hover styles */
.dialog-close-button:hover {
    background-color: rgba(0, 0, 0, 0.1);
}

/* Active styles */
.dialog-close-button:active {
    background-color: rgba(0, 0, 0, 0.2);
}

.dialog-close-button svg {
    stroke: var(--primary-counter-color);
}

/* Styles for button column on left main screen */

/* Styles for enter pair dialog */
#enter-pair-dialog {
    position: relative;
    border-radius: var(--border-radius);
    border: none;
    box-shadow: 0 0 10px var(--shadow-color);
    padding: 40px 20px 20px;
    max-width: 400px;
    width: 80%;
}
#enter-pair-dialog form {
    display: flex;
    flex-direction: column;
    gap: 15px;
}
#enter-pair-dialog label {
    display: inline-block;
    width: 80px;
    text-align: right;
    margin-right: 10px;
    font-weight: bold;
    font-size: 1.2em; /*var(--normal-font-size);*/
    color: var(--counter-text-color);
}
#enter-pair-dialog input {
    width: calc(100% - 90px);
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: var(--normal-font-size);
    color: var(--counter-text-color);
}
#enter-pair-dialog #submit-dialog {
    background-color: var(--primary-color);
    color: var(--text-color);
    border: none;
    padding: 10px 15px;
    border-radius: var(--border-radius);
    cursor: pointer;
    font-size: var(--normal-font-size);
    font-weight: bold;
    transition: background-color var(--transition-speed) ease;
}
#enter-pair-dialog button:hover {
    background-color: #5c8a00;
}

#dialog-message {
    color: var(--counter-text-color);
    font-style: italic;
    margin-top: 10px;
}
.dialog-buttons {
    display: flex;
    justify-content: space-between;
    margin-top: 20px;
}

/* Styles for select taxon pair list dialog */
#select-pair-dialog {
    width: 95%;
    max-width: var(--max-image-width);
    height: 90vh;
    max-height: 90vh;
    padding: 10px;
}

#select-pair-dialog .dialog-inner {
    display: flex;
    flex-direction: column;
    height: 100%;
    max-height: calc(90vh - 40px); /* Adjust for dialog padding */
}

.dialog-title {
    flex-shrink: 0;
    margin-bottom: 15px;
}

.taxon-pair-list {
    flex-grow: 1;
    width: 100%;
    max-height: calc(80vh - 150px);
    overflow-y: auto;
    overflow-x: hidden; /* Prevent horizontal scrolling */
    padding-bottom: 10px; /* This creates the gap at the bottom */
    margin-bottom: 0;
}

/* Adjust the scrollable area to leave space at the bottom */
#select-pair-dialog .taxon-pair-list {
    max-height: calc(90vh - 140px); /* Adjust this value as needed */
    padding-right: 5px; /* Add some padding for the scrollbar */
}

/* Style for webkit browsers */
#select-pair-dialog .taxon-pair-list::-webkit-scrollbar {
    width: 6px;
}

#select-pair-dialog .taxon-pair-list::-webkit-scrollbar-thumb {
    background-color: rgba(0,0,0,0.2);
    border-radius: 3px;
}

/* Style for Firefox */
#select-pair-dialog .taxon-pair-list {
    scrollbar-width: thin;
    scrollbar-color: rgba(0,0,0,0.2) transparent;
}

.taxon-set-button {
    display: block;
    width: 100%;
    padding: 5px;
    margin: 2px 0;
    background-color: rgba(116, 172, 0, 0.3); /* Light green background */
    border: none;
    border-radius: 10px;
    cursor: pointer;
    transition: background-color 0.3s ease;
    box-sizing: border-box; /* Include padding in width calculation */
}

.taxon-set-button:focus {
    outline: none;
    background-color: rgba(116, 172, 0, 0.5);
    box-shadow: 0 0 0 2px var(--primary-color);
}

.taxon-set-button:focus .taxon-item {
    background-color: #5c8a00;
}

.taxon-set-button--selected {
    background-color: rgba(116, 172, 0, 0.5); /* Darker green background */
    box-shadow: 0 0 0 2px var(--primary-color); /* Green outline */
}

.taxon-set-button--selected .taxon-item {
    background-color: #5c8a00; /* Darker green for the taxon items */
}

.taxon-set-button--selected:hover {
    background-color: rgba(116, 172, 0, 0.6); /* Even darker on hover */
}

.taxon-set-container {
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    align-items: stretch;
    gap: 5px; /* Small gap between the two "buttons" */
    width: 100%;
}

.set-name {
    font-size: 1.2em;
    font-weight: bold;
}

.tags {
    font-size: 1em;
    color: #666;
}

.taxon-item {
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 10px;
    background-color: var(--primary-color);
    color: var(--text-color);
    border-radius: 5px;
}

.taxon-set-button:hover .taxon-item {
    background-color: #5c8a00;
}

.taxon-name {
    font-style: italic;
    font-weight: bold;
    font-size: 1.3em;
    margin-bottom: 3px;
    text-align: center;
}

.vernacular-name {
    font-size: 1.2em;
    color: rgba(255, 255, 255, 0.8);
    text-align: center;
}

.taxon-pair-content {
    background-color: white;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    width: 90%;
    max-width: 500px;
    max-height: 80vh;
    position: relative;
    display: flex;
    flex-direction: column;
    padding: 40px 20px 20px;
}

.taxon-pair-title {
    color: var(--primary-color);
    text-align: center;
    margin: 0 0 20px 0;
    font-size: 1.5em;
}

.taxon-pair-modal {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}

.select-tags-button {
    background-color: var(--primary-color);
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: var(--border-radius);
    cursor: pointer;
    margin-bottom: 10px;
    font-size: 16px;
}

.select-tags-button:hover {
    background-color: #5c8a00;
}

.search-container {
  position: relative;
  margin-bottom: 15px;
  flex-shrink: 0;
}

#taxon-search {
  width: 100%;
  padding: 10px 15px;
  padding-left: 40px;
  border: 1px solid #ddd;
  border-radius: var(--border-radius);
  font-size: 16px;
  transition: border-color 0.3s ease;
}

#taxon-search:focus {
  outline: none;
  border-color: var(--primary-color);
}

.search-icon {
  position: absolute;
  left: 12px;
  top: 50%;
  transform: translateY(-50%);
  width: 20px;
  height: 20px;
  color: #888;
}

#clear-search {
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  cursor: pointer;
  padding: 0;
  width: 20px;
  height: 20px;
  color: #888;
  display: none;
}

#clear-search:hover {
  color: var(--primary-color);
}

/* Tag cloud dialog */

#tag-cloud-dialog {
    width: 95%;
    max-width: var(--max-image-width);
    height: 90vh;
    display: none; /* Hide the dialog by default */
}

#tag-cloud-dialog[open] {
    display: flex;
    flex-direction: column;
}

#tag-cloud-container {
    flex-grow: 1;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    padding: 20px;
    overflow-y: auto;
}

.tag-cloud-item {
    margin: 5px;
    padding: 5px 10px;
    background-color: #f0f0f0;
    border-radius: 15px;
    cursor: pointer;
    transition: background-color 0.3s, color 0.3s;
}

.tag-cloud-item.active {
    background-color: var(--primary-color);
    color: white;
}

.done-button {
    background-color: var(--primary-color);
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: var(--border-radius);
    cursor: pointer;
    margin-top: 10px;
    font-size: 16px;
}

.done-button:hover {
    background-color: #5c8a00;
}

/* Help dialog */

#help-dialog {
    position: relative;
    padding: 40px 24px 24px;
    padding: 24px;
    border-radius: 12px;
    border: none;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    max-width: 400px;
    width: 80%;
    background-color: #f9f9f9;
}
.help-dialog-content {
    position: relative;
    padding-top: 60px; /* Space for the logo */
}

.help-dialog-header {
    text-align: center;
    margin-bottom: 24px;
}

.help-dialog-logo {
    position: absolute;
    top: -20px;
    left: 50%;
    transform: translateX(-50%);
    width: 80px;
    height: 80px;
    opacity: 0.8;
}

#help-dialog h2 {
    color: var(--primary-color);
    margin-top: 0;
    font-size: 24px;
    line-height: 1.5;
}

#help-dialog h2 .duo {
    color: var(--primary-counter-color);
}

#help-dialog h2 .nat {
    color: var(--primary-color);
}

#help-dialog h2 .subtitle {
    color: var(--dark-neutral-color);
    font-size: 0.8em;
}

.help-content {
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.help-item {
    display: flex;
    align-items: center;
    gap: 16px;
    background-color: white;
    padding: 16px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
}

.help-item svg {
    flex-shrink: 0;
}

.help-item p {
    margin: 0;
    font-size: 18px;
    line-height: 1.4;
    color: var(--dark-neutral-color);
    text-align: left; /* TODO doesn't work */
}

#keyboard-shortcuts {
    margin-top: 20px;
}

#keyboard-shortcuts h3 {
    margin-bottom: 10px;
    color: var(--primary-color);
}

#keyboard-shortcuts ul {
    list-style-type: none;
    padding-left: 0;
}

#keyboard-shortcuts li {
    margin-bottom: 5px;
    text-align: left;
}

#keyboard-shortcuts strong, #shortcut-key {
    display: inline-block;
    width: 20px;
    text-align: center;
    margin-right: 10px;
    background-color: var(--primary-color);
    color: white;
    border-radius: 3px;
    padding: 2px;
}

#start-tutorial-button, #discord-help-dialog {
    background-color: var(--primary-color);
    color: var(--text-color);
    border: none;
    padding: 12px 24px;
    border-radius: 12px;
    cursor: pointer;
    text-align: center;
    font-size: 20px;
    font-weight: bold;
    transition: background-color var(--transition-speed) ease, transform 0.1s ease;
    width: 100%;
}

#version-id {
    padding-top: 8px;
    font-size: 14px;
    color: var(--counter-text-color);
}

/* Styles for tutorial */
.tutorial-highlight {
    position: absolute;
    border-radius: 8px;
    box-shadow: 0 0 0 4px rgba(172, 0, 40, 0.5); /* var(--primary-counter-color); */
    pointer-events: none;
    z-index: 10000;
    animation: pulse 1s infinite;
}

@keyframes pulse {
    0% {
        box-shadow: 0 0 0 0 rgba(172, 0, 40, 0.7);
    }
    70% {
        box-shadow: 0 0 0 10px rgba(172, 0, 40, 0);
    }
    100% {
        box-shadow: 0 0 0 0 rgba(172, 0, 40, 0);
    }
}

.shortcut-key {
    display: none;
    font-weight: bold;
    background-color: rgba(255, 255, 255, 0.2);
    padding: 2px 5px;
    border-radius: 3px;
    margin-right: 5px;
}

body.has-keyboard .shortcut-key {
    display: inline-block;
}
body.has-keyboard button {
    text-align: left;
}

/* Info dialog */

.info-dialog {
    position: fixed;
    transform: translate(0, 0); /* override system-wide centering of dialogs */
    padding: 20px;
    display: none;
    flex-direction: column;
    box-sizing: border-box;
    padding: 20px;
    background-color: #f1f7e5;
    border-radius: var(--border-radius);
    border-color: var(--primary-color);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    max-width: var(--max-image-width);
    width: 100%;
    overflow-y: auto;
    transition: top 0.3s ease-out, bottom 0.3s ease-out, height 0.3s ease-out;
}

.info-dialog[open] {
    display: flex;
}

.info-dialog__header {
    text-align: center;
    margin-bottom: 15px;
}

.info-dialog__taxon {
    font-size: 1.4em;
    margin: 0;
    color: var(--primary-counter-color);
    font-style: italic;
    text-shadow: 1px 1px 2px var(--shadow-color);
}

.info-dialog__vernacular {
    font-size: 1.2em;
    margin: 5px 0 0;
    color: var(--dark-neutral-color);
    text-shadow: 1px 1px 2px var(--shadow-color);
}

.info-dialog__facts {
    flex-grow: 1;
    margin: 15px 0;
    padding: 15px;
    background-color: var(--light-green);
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    overflow-y: auto;

}

.info-dialog__facts h3 {
    color: var(--primary-color);
    font-size: 1.2em;
    margin-bottom: 10px;
    padding-bottom: 8px;
    border-bottom: 2px solid var(--primary-color);
}

.info-dialog__facts ul {
    list-style-type: none;
    padding-left: 0;
    margin: 0;
}

.info-dialog__facts li {
    position: relative;
    padding-left: 24px;
    margin-bottom: 8px;
    text-align: left;
    font-size: 1.3em;
    line-height: 1.4;
    color: var(--dark-neutral-color);
    word-break: normal;
    overflow-wrap: break-word;
    hyphens: auto;
/*    text-shadow: 1px 1px 2px var(--shadow-color);*/
}

.info-dialog__facts li::before {
    content: "•";
    position: absolute;
    left: 8px;
    color: var(--primary-color);
    font-size: 1.3em;
}

.info-dialog__buttons {
    display: flex;
    justify-content: space-around;
    margin-top: 15px;
}

.info-dialog__button {
    padding: 10px;
}

@media (max-width: 480px) {
    .info-dialog {
        padding: 12px;
    }

    .info-dialog__header {
        margin-bottom: 5px;
    }

    .info-dialog__taxon {
        font-size: 1.4em;
    }

    .info-dialog__vernacular {
        font-size: 1.1em;
    }

    .info-dialog__facts {
        margin: 4px 0 0 0;
        padding: 10px;
    }

    .info-dialog__facts li {
        font-size: 1.2em;
        line-height: 1.2;
    }

    .info-dialog__buttons {
        margin-top: 15px;
    }

    .info-dialog__button-icon {
        width: 20px;
        height: 20px;
    }
}

/* Relationship graph dialog */

#phylogeny-dialog {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90%;
    height: 90%;
    max-width: 1800px;
    padding: 20px;
    display: flex;
    flex-direction: column;
    /*visibility: hidden;*/
    display: none;
    opacity: 0.92;
}

.graph-hint {
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(255, 255, 255, 0.8);
    color: var(--dark-neutral-color);
    padding: 5px 10px;
    border-radius: 15px;
    font-size: 0.9em;
    opacity: 0.8;
    transition: opacity 0.3s ease;
}

.graph-hint:hover {
    opacity: 0;
}

#taxa-relationship-graph {
    flex-grow: 1;
    overflow: hidden;
}

/* hide when dialog is hidden */
#phylogeny-dialog.hidden #taxa-relationship-graph {
    display: none;
    visibility: hidden;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    #phylogeny-dialog {
        width: 95%;
        height: 95%;
    }
}

#taxa-relationship-graph {
    flex-grow: 1;
    overflow: hidden;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .graph-dialog-content {
        width: 95%;
        height: 95%;
    }

    .graph-title {
        font-size: 1.2em;
        padding: 10px 0;
    }
}

.clickable-network .vis-network:hover {
    /* TODO: gives pointer not only over nodes*/
   /* cursor: pointer; */
}


/* Styles for iNaturalist Down Dialog */
#inat-down-dialog {
    position: relative;
    padding: 40px 2rem 2rem;
    width:100%; height:100%;
    z-index: 10000;
    background-color: white;
    padding: 0px;
    border-radius: 00px;
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
}

#inat-down-dialog {
  background-color: white;
  padding: 2rem;
  border-radius: var(--border-radius);
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
  max-width: 90%;
  width: 400px;
  text-align: center;
}

#inat-down-dialog h2 {
  color: var(--primary-counter-color);
  margin-bottom: 1rem;
}

#inat-down-dialog p {
  margin-bottom: 1rem;
  color: var(--counter-text-color);
}

#inat-down-dialog button {
  background-color: var(--primary-color);
  color: var(--text-color);
  border: none;
  padding: 0.75rem 1.5rem;
  border-radius: var(--border-radius);
  cursor: pointer;
  font-size: 1rem;
  margin: 0.5rem;
  transition: background-color var(--transition-speed) ease;
}

#inat-down-dialog button:hover {
  background-color: #5c8a00;
}

#check-inat-status {
  background-color: var(--primary-color);
}

#check-inat-status:hover {
  background-color: #8a0020;
}





# styles/components/loading.css

/* Styles for loading screen */

.loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #f9f9f9;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9000;
}

.loading-screen__content {
    text-align: center;
}

.loading-screen__logo {
    width: 100px;
    height: 100px;
    margin-bottom: 20px;
}

.loading-screen__title {
    font-size: 2.5em;
    margin-bottom: 10px;
}

.loading-screen__title-duo {
    color: var(--primary-counter-color);
}

.loading-screen__title-nat {
    color: var(--primary-color);
}

.loading-screen__message {
    font-size: 1.2em;
    color: #666;
    margin-bottom: 20px;
}

.loading-screen__spinner {
    border: 5px solid #f3f3f3;
    border-top: 5px solid var(--primary-color);
    border-radius: 50%;
    width: 50px;
    height: 50px;
    animation: spin 1s linear infinite;
    margin: 0 auto;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Phylogeny graph dialog */

.loading-indicator {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(255, 255, 255, 1);
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    text-align: center;
    z-index: 1000;
}

.loading-indicator-logo {
    width: 80px;
    height: 80px;
    margin-bottom: 15px;
}

.loading-indicator .loading-spinner {
    border: 5px solid #f3f3f3;
    border-top: 5px solid var(--primary-color);
    border-radius: 50%;
    width: 50px;
    height: 50px;
    animation: spin 1s linear infinite;
    margin: 0 auto 15px;
}

.loading-indicator p {
    margin: 0;
    color: var(--primary-color);
    font-size: 18px;
    font-weight: bold;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}





# styles/components/menu.css

/* Styles for main menu (to replace button column above) */

.main-menu {
    position: fixed;
    top: 10px;
    right: 10px;
    z-index: 1000;
}
/*
.main-menu button,
.main-menu__dropdown button {
    background-color: rgba(255, 255, 255, 0.6);
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    transition: background-color 0.3s ease;
    margin-bottom: 10px;
}

.main-menu button:hover,
.main-menu__dropdown button:hover {
    background-color: rgba(255, 255, 255, 0.8);
    transform: scale(1.1);
}
*/
.main-menu__dropdown {
    display: none;
    position: absolute;
    right: 0;
    top: 40px;
}

.main-menu__dropdown.show {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
}

.main-menu__item {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    margin-bottom: 10px;
}

.main-menu__label {
    display: flex;
    align-items: center;
    background-color: rgba(255, 255, 255, 0.9);
    height: fit-content; /* Adjust height to content */
    padding: 4px 10px;
    border-radius: 15px;
    font-size: 14px;
    margin-right: 10px;
    margin-top: -8px;
    opacity: 0;
    transition: opacity 0.3s ease;
    white-space: nowrap;
}

.main-menu__dropdown.show .main-menu__label {
    opacity: .8;
}

.main-menu__dropdown--top {
    top: 60px;
}

.main-menu__dropdown--bottom {
    position: absolute;
    top: 0; /* Will be set dynamically in JavaScript */
    right: 0;
}

/* Media query for larger screens */
@media (min-width: 768px) {
    .main-menu__dropdown--bottom {
        bottom: auto;
        top: 50px;
        right: 0;
    }
}




# styles/components/tooltips.css

/* not currently used */

.tooltip {
    position: absolute;
    background-color: var(--primary-color);
    color: white;
    padding: 5px 10px;
    border-radius: 8px;
    font-size: 14px;
    z-index: 1000;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.4s;
}

.tooltip.visible {
    opacity: 1;
}




# styles/layout/image-container.css

/* Image container and components */

.image-container {
    position: relative;
    flex: 1 1 300px;
    margin: 0px 0px;
    padding: 4px;
    aspect-ratio: 1/1;
    position: relative;
    background-color: var(--counter-text-color);
    box-shadow: 0 0 10px var(--shadow-color);
    border-radius: var(--border-radius);
    box-sizing: border-box;
    overflow: hidden;
    z-index: 1;
    cursor: default;
}
.image-container--drag-over {
    cursor: copy;
}

/* TODO this will be a problem when switching to side-by-side on desktop, keep in mind */
#image-container-1 {
    margin-top: 4px;
}
#image-container-2 {
    margin-bottom: 4px;
}
.image-container__image {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center;
    background-color: #f0f0f0;
    color: var(--primary-color);
    font-size: 36px;
    font-weight: bold;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: var(--border-radius);
    pointer-events: none; /* Prevents the image from interfering with dragging */
    transition: opacity var(--transition-speed) ease-in-out;
}

.image-container__image--loading {
    opacity: 0.5;
    transition: opacity var(--transition-speed) ease-in-out;    
}

/* World map overlays on images */

.image-container__world-map {
    position: absolute;
    left: 60px;
    width: 100px; /* Adjust as needed */
    height: 60px; /* Adjust as needed */
    border-radius: var(--border-radius);
    opacity: 0.6;
    z-index: 10;
}
.image-container__world-map svg {
    border-radius: var(--border-radius);
}

#world-map-1 {
    bottom: 5px;
}

#world-map-2 {
    bottom: 5px;
}

/* Drop zone for taxon tiles */
.image-container__drop-zone {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    opacity: 0.9;
    z-index: 10;
    width: 300px;
    max-width: calc(var(--max-image-width)-50px);
    height: 80px; /* Add a fixed height */
    transition: all 0.3s ease-out;
    pointer-events: none;
}

/* Used for marking the active image when showing the info dialog */

.image-container--framed {
    box-shadow: 0 0 0 4px rgba(116, 172, 0, 0.5);
    transition: box-shadow 0.3s ease;
    z-index: 1000;
}




# styles/layout/name-pair.css

/* Name pair container and components */

.name-pair {
    position: relative;
    display: flex;
    flex-wrap: nowrap;
    justify-content: center;
    align-items: stretch;
    background-color: rgb(0,0,0,0);
    margin: 4px auto;
    gap: 4px;
    width: 98%;
    max-width: var(--max-image-width);
    min-height: var(--center-min-height);
}

.name-pair__container--left, .name-pair__container--right {
    display: flex;
    flex: 1;
    min-width: 0;
    max-width: 300px;
    margin: 0px;
    min-height: var(--center-min-height);
}

/* Styles for draggable name tiles */
.name-pair__item--draggable {
    position: relative;
    box-sizing: border-box;
    z-index: 10;
    border-radius: var(--border-radius);

    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;

    padding: 6px;
    width: 300px;
    min-height: var(--center-min-height);

    color: var(--text-color);
    background-color: var(--primary-color);
    opacity: 1;
    font-size: 22px;

    text-shadow: 1px 1px 2px var(--shadow-color);

    touch-action: none;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    word-break: break-word;
    hyphens: auto;

    box-shadow: 0 0 0 2px white;
    cursor: grab;
    transition: box-shadow var(--transition-speed) ease;
}

.name-pair__taxon-name,
.name-pair__vernacular-name {
    width: 100%;
    display: block;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: wrap; /* TODO claude says no-wrap */
}

.name-pair__taxon-name {
    font-style: italic;
    font-weight: bold;
    margin-bottom: 2px;
    font-size: 0.95em;
}

.name-pair__vernacular-name {
    font-size: 0.85em;
    color: rgba(255, 255, 255, 0.8);
}

.name-pair__item--draggable:hover {
    transform: scale(1.02);
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

/*.name-pair__item--draggable,
.name-pair__item--draggable.dragging {
    max-width: 300px;
}
*/

.name-pair__item--dragging {
    /* Ensure the element is rendered as its own layer */
    transform: translateZ(0) !important;
    -webkit-transform: translateZ(0) !important;
}

.name-pair__item--draggable {
    -khtml-user-select: none !important;
    -moz-user-select: none !important;
    -ms-user-select: none !important;
}

/* Message overlay */

.name-pair__overlay {
    position: absolute;
    border-radius: var(--border-radius);
    height: 100%;
    background-color: var(--overlay-color);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    opacity: 0;
    pointer-events: none;
    transition: opacity var(--transition-speed) ease, background-color var(--transition-speed) ease;
}

.name-pair__overlay.show { opacity: 1; }

.name-pair__overlay-message {
    font-size: 2.4em;
    font-weight: bold;
    color: var(--text-color);
    text-shadow: 1px 1px 2px var(--shadow-color);
    padding: 15px;
    max-width: 95%;
    line-height: 1.4;
}

/*new*/
.name-pair__item--draggable {
    position: relative;
    box-sizing: border-box;
    z-index: 10;
    border-radius: var(--border-radius);
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 6px;
    width: 300px;
    min-height: var(--center-min-height);
    color: var(--text-color);
    background-color: var(--primary-color);
    opacity: 1;
    font-size: 22px;
    text-shadow: 1px 1px 2px var(--shadow-color);
    touch-action: none;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    word-break: break-word;
    hyphens: auto;
    box-shadow: 0 0 0 2px white;
    cursor: grab;
    transition: all 0.3s ease-out;
    -webkit-touch-callout: none !important;
    -webkit-user-select: none !important;
    user-select: none !important;
    -webkit-tap-highlight-color: rgba(0,0,0,0) !important;
}

.name-pair__item--landing {
    transition: all 0.3s ease-out !important;
}

.name-pair__item--draggable:active,
.name-pair__item--dragging {
    width: 300px !important;
    opacity: 0.9 !important;
    border: 2px solid white !important;
    box-shadow: 0 0 0 2px white, 0 0 10px 3px rgba(255, 255, 255, 0.7);
    box-shadow: 0 0 10px 3px rgba(255, 255, 255, 0.7) !important;
    -webkit-box-shadow: 0 0 10px 3px rgba(255, 255, 255, 0.7) !important;
    transition: all 0.1s ease-out !important;
    z-index: 1000 !important;
    transform: translateZ(0) !important;
    -webkit-transform: scale(1.05) translateZ(0) !important;
    -webkit-backface-visibility: hidden !important;
    -webkit-perspective: 1000 !important;
    cursor: grabbing !important;
}

/*
@keyframes correctAnswer {
    0%, 100% { background-color: var(--primary-color); }
    50% { background-color: #4CAF50; } 
}
*/

@keyframes incorrectAnswer {
    0%, 100% { background-color: var(--primary-color); }
    50% { background-color: #F44336; } /* Red */
}

.name-pair__item--correct {
    animation: correctAnswer 0.6s ease-in-out;
}

.name-pair__item--incorrect {
    animation: incorrectAnswer 0.6s ease-in-out;
}



# code/tagCloud.js

import api from './api.js';
import dialogManager from './dialogManager.js';
import { gameState, updateGameState } from './state.js';
import preloader from './preloader.js';

const tagCloud = {
    selectedTags: new Set(),

    async initialize() {
        const selectTagsButton = document.getElementById('select-tags-button');
        const tagCloudDialog = document.getElementById('tag-cloud-dialog');
        const doneButton = document.getElementById('tag-cloud-done-button');

        selectTagsButton.addEventListener('click', () => this.openTagCloud());
        doneButton.addEventListener('click', () => this.closeTagCloud());

        // Close button functionality
        const closeButton = tagCloudDialog.querySelector('.dialog-close-button');
        closeButton.addEventListener('click', () => this.closeTagCloud());
    },                  

    async openTagCloud() {
        const tagCounts = await this.getTagCounts();
        this.renderTagCloud(tagCounts);
        dialogManager.openDialog('tag-cloud-dialog');
    },

    closeTagCloud() {
        dialogManager.closeDialog('tag-cloud-dialog');
        preloader.preloadNewPairWithTags(gameState.selectedTags);
    },

    async getTagCounts() {
        const taxonPairs = await api.fetchTaxonPairs();
        const tagCounts = {};
        taxonPairs.forEach(pair => {
            pair.tags.forEach(tag => {
                tagCounts[tag] = (tagCounts[tag] || 0) + 1;
            });
        });
        return tagCounts;
    },

    async updateMatchingPairsCount() {
        const taxonPairs = await api.fetchTaxonPairs();
        const selectedTags = Array.from(this.selectedTags);
        const matchingPairs = taxonPairs.filter(pair => 
            pair.tags.some(tag => selectedTags.includes(tag))
        );
        
        const countElement = document.getElementById('matching-pairs-count');
        if (countElement) {
            countElement.textContent = `Matching pairs: ${matchingPairs.length}`;
        }
    },

    renderTagCloud(tagCounts) {
        const container = document.getElementById('tag-cloud-container');
        container.innerHTML = '';
        const maxCount = Math.max(...Object.values(tagCounts));
        
        Object.entries(tagCounts).forEach(([tag, count]) => {
            const size = 14 + (count / maxCount) * 24; // Font size between 14px and 38px
            const tagElement = document.createElement('span');
            tagElement.textContent = tag;
            tagElement.className = 'tag-cloud-item';
            tagElement.style.fontSize = `${size}px`;
            if (this.selectedTags.has(tag)) {
                tagElement.classList.add('active');
            }
            tagElement.addEventListener('click', () => this.toggleTag(tagElement, tag));
            container.appendChild(tagElement);
        });
    },

    toggleTag(element, tag) {
        element.classList.toggle('active');
        let newSelectedTags;
        if (this.selectedTags.has(tag)) {
            this.selectedTags.delete(tag);
            newSelectedTags = Array.from(this.selectedTags);
        } else {
            this.selectedTags.add(tag);
            newSelectedTags = Array.from(this.selectedTags);
        }
        updateGameState({ selectedTags: newSelectedTags });
        this.updateMatchingPairsCount();
    },

    getSelectedTags() {
        return Array.from(this.selectedTags);
    },

    clearTags() {
        this.selectedTags.clear();
        updateGameState({ selectedTags: [] });
        this.renderTagCloud(this.getTagCounts());
        this.updateMatchingPairsCount();
    },
};

export default tagCloud;



# code/eventHandlers.js

// Event handlers

import api from './api.js';
import dialogManager from './dialogManager.js';
import dragAndDrop from './dragAndDrop.js';
import game from './game.js';
import logger from './logger.js';
import { elements, gameState } from './state.js';
import ui from './ui.js';
import utils from './utils.js';

const eventHandlers = {

    // global variables for swiping left
    startX: 0,
    endX: 0,
    isDragging: false,
    gameContainer: null,
    touchStartX: 0,
    touchStartY: 0,
    touchEndX: 0,
    touchEndY: 0,

    swipeThreshold: 50, // minimum distance to trigger a swipe
    swipeRestraint: 100, // maximum vertical distance allowed during a swipe

    isLoadingNewPair: false,

    initialize() {
        this.initializeSwipeFunctionality();
        this.initializeMainMenuListeners();
        this.initializeAllEventListeners();

        this.debouncedKeyboardHandler = utils.debounce(this._handleKeyboardShortcuts.bind(this), 300);

        // Ensure keyboard shortcuts are properly set up
        document.removeEventListener('keydown', this.debouncedKeyboardHandler);
        document.addEventListener('keydown', this.debouncedKeyboardHandler);

        // Select pair dialog close button
        const selectPairDialog = document.getElementById('select-pair-dialog');
        const selectPairCloseButton = selectPairDialog.querySelector('.dialog-close-button');
        selectPairCloseButton.addEventListener('click', () => {
            dialogManager.closeDialog('select-pair-dialog');
        });

        // Tag cloud dialog close button
        const tagCloudDialog = document.getElementById('tag-cloud-dialog');
        const tagCloudCloseButton = tagCloudDialog.querySelector('.dialog-close-button');
        tagCloudCloseButton.addEventListener('click', () => {
            dialogManager.closeDialog('tag-cloud-dialog');
        });

    },

initializeSwipeFunctionality() {
    this.gameContainer = document.querySelector('.game-container');
    if (!this.gameContainer) {
        logger.error('Game container not found');
        return;
    }

    [elements.imageOneContainer, elements.imageTwoContainer].forEach((container, index) => {
        container.addEventListener('mousedown', (e) => {
            this.handleMouseDown(e);
        });
        container.addEventListener('touchstart', (e) => {
            this.handleTouchStart(e);
        }, { passive: true });
        container.addEventListener('mousemove', (e) => {
            this.handleDragMove(e);
        });
        container.addEventListener('touchmove', (e) => {
            this.handleDragMove(e);
        }, { passive: true });
        container.addEventListener('mouseup', (e) => {
            this.handleSwipeOrDrag(e);
        });
        container.addEventListener('touchend', (e) => {
            this.handleSwipeOrDrag(e);
        });
    });

},

    safeAddEventListener(id, eventType, handler) {
        const element = document.getElementById(id);
        if (element) {
            element.addEventListener(eventType, handler);
        } else {
            logger.debug(`Element with id '${id}' not found. Skipping event listener.`);
        }
    },

    initializeMainMenuListeners: function() {
        this.safeAddEventListener('share-button', 'click', () => {
            this.shareCurrentPair();
            ui.closeMainMenu(); // Close menu after action
        });
        this.safeAddEventListener('phylogeny-button', 'click', () => {
            game.showTaxaRelationship();
            ui.closeMainMenu(); // Close menu after action
        });
        this.safeAddEventListener('select-pair-button', 'click', () => {
            ui.showTaxonPairList();
            ui.closeMainMenu(); // Close menu after action
        });
        this.safeAddEventListener('enter-pair-button', 'click', () => {
            dialogManager.openDialog('enter-pair-dialog');
            ui.closeMainMenu(); // Close menu after action
        });
        this.safeAddEventListener('random-pair-button', 'click', () => {
            game.loadNewRandomPair();
            ui.closeMainMenu(); // Close menu after action
        });
        this.safeAddEventListener('like-button', 'click', () => {
            this.likePair();
            ui.closeMainMenu(); // Close menu after action
        });
        this.safeAddEventListener('trash-button', 'click', () => {
            this.trashPair();
            ui.closeMainMenu(); // Close menu after action
        });
        this.safeAddEventListener('surprise-button', 'click', () => {
            utils.surprise();
            ui.closeMainMenu(); // Close menu after action
        });
    },

    initializeAllEventListeners() {
        dragAndDrop.initialize();

        // touch events
        [elements.imageOneContainer, elements.imageTwoContainer].forEach(container => {
            container.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: true });
            container.addEventListener('touchend', this.handleImageInteraction.bind(this));
            container.addEventListener('mousedown', this.handleMouseDown.bind(this));
            container.addEventListener('mouseup', this.handleImageInteraction.bind(this));
        });

        ['1', '2'].forEach(index => {
            this.safeAddEventListener(`thumbs-up-${index}`, 'click', () => this.handleThumbsUp(index));
            this.safeAddEventListener(`thumbs-down-${index}`, 'click', () => this.handleThumbsDown(index));
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', this.debouncedKeyboardHandler);

        // Failsafe to ensure all dialogs can be closed
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                dialogManager.closeAllDialogs();
            }
        });

        // Help button functionality
        document.getElementById('help-button').addEventListener('click', () => {
            dialogManager.openDialog('help-dialog');
        });
        document.getElementById('start-tutorial-button').addEventListener('click', () => {
            ui.showTutorial();
        });
        document.getElementById('discord-help-dialog').addEventListener('click', () => {
            window.open('https://discord.gg/DcWrhYHmeM', '_blank');
        });

    },

    handleThumbsUp(index) {
        // Implement thumbs up functionality
        logger.debug(`Thumbs up clicked for image ${index}`);
        // Add your implementation here
    },

    handleThumbsDown(index) {
        // Implement thumbs down functionality
        logger.debug(`Thumbs down clicked for image ${index}`);
        // Add your implementation here
    },

    handleMouseDown(e) {
        if (!e.target.closest('.image-container') || e.target.closest('.info-button')) return;
        if (e.target.closest('.name-pair__item--draggable')) return; // Ignore draggable elements
        this.startX = e.clientX;
        this.startY = e.clientY;
        this.isDragging = true;
    },

    handleTouchStart(e) {
        
        if (!e.target.closest('.image-container') || e.target.closest('.info-button')) {
            return;
        }
        
        this.startX = e.touches[0].clientX;
        this.startY = e.touches[0].clientY;
        this.isDragging = true;
    },

    handleSwipeOrDrag(e) {
        if (!this.isDragging) return;

        let endX, endY;
        if (e.type.includes('touch')) {
            endX = e.changedTouches[0].clientX;
            endY = e.changedTouches[0].clientY;
        } else {
            endX = e.clientX;
            endY = e.clientY;
        }

        const deltaX = this.startX - endX;
        const deltaY = Math.abs(this.startY - endY);

    if (deltaX > this.swipeThreshold && deltaY < this.swipeRestraint) {
        // Swipe left detected
        document.querySelector('.game-container').classList.add('swipe-out-left');

        // Hide the swipe info message
        const swipeInfoMessage = document.getElementById('swipe-info-message');
        swipeInfoMessage.style.opacity = 0;

        setTimeout(() => {
            document.querySelector('.game-container').classList.remove('swiping-left', 'swipe-out-left');
            ui.resetGameContainerStyle();
            game.loadNewRandomPair();
        }, 500); // Match this with the animation duration
    } else {
        // Reset if not swiped far enough or swiped vertically
        ui.resetGameContainerStyle();

        // Hide the swipe info message
        const swipeInfoMessage = document.getElementById('swipe-info-message');
        swipeInfoMessage.style.opacity = 0;
    }

    this.isDragging = false;
    },

    handleDragMove(e) {
        if (!this.isDragging) return;

        let currentX, currentY;
        if (e.type.includes('touch')) {
            currentX = e.touches[0].clientX;
            currentY = e.touches[0].clientY;
        } else {
            currentX = e.clientX;
            currentY = e.clientY;
        }

        const deltaX = this.startX - currentX;
        const deltaY = Math.abs(this.startY - currentY);

        if (deltaX > 0 && deltaY < this.swipeRestraint) {
            const progress = Math.min(deltaX / 100, 1);
            const rotation = progress * -5;
            const opacity = 1 - progress * 0.5;

            this.gameContainer.style.transform = `rotate(${rotation}deg) translateX(${-deltaX}px)`;
            this.gameContainer.style.opacity = opacity;

            // Update the swipe info message
            const swipeInfoMessage = document.getElementById('swipe-info-message');
            swipeInfoMessage.style.opacity = progress.toFixed(2); // Fade in smoothly
        }
    },

    handleImageInteraction(event) {
        if (!event) return;  // handle cases where event is undefined
        // Add any specific image interaction logic here
    },

    showTaxonPairList() {
        api.fetchTaxonPairs().then(taxonPairs => {
            ui.showTaxonPairList(taxonPairs, (selectedPair) => {
                game.nextSelectedPair = selectedPair;
                game.setupGame(true);
            });
        });
    },

    _handleKeyboardShortcuts(event) {
//        logger.debug("Keyboard event:", event.key);
        if (dialogManager.isAnyDialogOpen() || 
            document.getElementById('info-dialog').open || 
            dialogManager.activeDialog || 
            document.getElementById('enter-pair-dialog').open) {
//            logger.debug("Dialog is open, ignoring keyboard shortcut");
            return;
        }

        switch (event.key.toLowerCase()) {
            case 'r':
            case 'arrowleft':
                if (!this.isLoadingNewPair) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.isLoadingNewPair = true;
                    game.loadNewRandomPair().finally(() => {
                        this.isLoadingNewPair = false;
                    });
                }
                break;
            case 'arrowup':
                event.preventDefault();
                this.moveTileToDropZone('left', 'upper');
                break;
            case 'arrowdown':
                event.preventDefault();
                this.moveTileToDropZone('left', 'lower');
                break;
            case 's':
                event.preventDefault();
                ui.showTaxonPairList();
                break;
            case 'h':
                event.preventDefault();
                document.getElementById('help-button').click();
                break;
            case 'e':
                event.preventDefault();
                dialogManager.openDialog('enter-pair-dialog');
                break;
            case 'm':
                event.preventDefault();
                ui.toggleMainMenu();
                break;
            case 'p':
                event.preventDefault();
                document.getElementById('surprise-button').click();
                break;
            case 'g':
                event.preventDefault();
                game.showTaxaRelationship();
                break;
            case 'i':
                event.preventDefault();
                game.showInfoDialog(game.currentObservationURLs.imageOne, 1);
                break;
            case 'o':
                event.preventDefault();
                game.showInfoDialog(game.currentObservationURLs.imageTwo, 2);
                break;
            case 'w':
                // createWorldMap.toggleAllWorldMaps();
                // TODO need to find a way to trigger from here
                break;
        }
    },

    moveTileToDropZone(tilePosition, dropZonePosition) {
        const tile = document.getElementById(tilePosition === 'left' ? 'left-name' : 'right-name');
        const dropZone = document.getElementById(dropZonePosition === 'upper' ? 'drop-1' : 'drop-2');
        
        if (tile && dropZone) {
            // Remove the tile from its current position
            tile.parentNode.removeChild(tile);
            
            // Clear the drop zone and add the tile
            dropZone.innerHTML = '';
            dropZone.appendChild(tile);
            
            // Highlight the moved tile
            //ui.highlightTile(tile.id);
            
            // Trigger the answer check using the game's checkAnswer method
            game.checkAnswer(dropZone.id);
        }
    },

    // move to other module, utils?
    shareCurrentPair() {
        let currentUrl = new URL(window.location.href);
        currentUrl.searchParams.delete('taxon1');
        currentUrl.searchParams.delete('taxon2');
        currentUrl.searchParams.set('taxon1', gameState.taxonImageOne);
        currentUrl.searchParams.set('taxon2', gameState.taxonImageTwo);
        let shareUrl = currentUrl.toString();

        navigator.clipboard.writeText(shareUrl).then(() => { }).catch(err => {
            logger.error('Failed to copy: ', err);
            alert('Failed to copy link. Please try again.');
        });
    },

    likePair: function() {
        // Implement liking functionality
        logger.debug('Like pair clicked');
        // Add your implementation here
    },

    trashPair: function() {
        // Implement trashing functionality
        logger.debug('Trash pair clicked');
        // Add your implementation here
    },

};

export default eventHandlers;



# code/dialogManager.js

import api from './api.js';
import eventHandlers from './eventHandlers.js';
import game from './game.js';
import logger from './logger.js';
import ui from './ui.js';

const dialogManager = {
    activeDialog: null,
    mainEventHandlers: {},
    eventListeners: {},
    openDialogs: new Set(),

    openDialog(dialogId) {
        const dialog = document.getElementById(dialogId);
        if (dialog && dialog.tagName.toLowerCase() === 'dialog') {
            dialog.showModal();
            this.openDialogs.add(dialogId);
        }
    },

    closeDialog(dialogId) {
        const dialog = document.getElementById(dialogId);
        if (dialog) {
            if (dialog.id === 'phylogeny-dialog') {
                dialog.style.display = 'none';
            }
        }
        if (dialog && dialog.tagName.toLowerCase() === 'dialog') {
            dialog.close();
            this.openDialogs.delete(dialogId);
        }
    },

    closeAllDialogs() {
        this.openDialogs.forEach(dialogId => this.closeDialog(dialogId));
    },

    isAnyDialogOpen() {
        return !!this.activeDialog;
    },
/*
    openDialog(dialogId) {
        ui.closeMainMenu();
        const dialog = document.getElementById(dialogId);
        if (!dialog) {
            console.error(`Dialog with id ${dialogId} not found`);
            return;
        }

        this.disableMainEventHandlers();

        if (dialog instanceof HTMLElement) {
            if (dialog.tagName.toLowerCase() === 'dialog') {
                dialog.showModal();
            } else {
                dialog.classList.remove('hidden');
                if (dialogId === 'phylogeny-dialog') {
                    dialog.style.display = 'flex';
                }
            }
        }
        this.activeDialog = dialog;

        document.addEventListener('keydown', this.handleEscapeKey.bind(this));
        if (dialog instanceof HTMLElement) {
            dialog.addEventListener('close', () => this.handleDialogClose(dialog));
            const closeButton = dialog.querySelector('.dialog-close-button');
            if (closeButton) {
                closeButton.addEventListener('click', () => this.closeDialog());
            }
        }
    },

    closeDialog() {
        if (this.activeDialog) {
            const dialog = this.activeDialog;
            this.activeDialog = null;

            if (dialog instanceof HTMLElement) {
                if (dialog.tagName.toLowerCase() === 'dialog') {
                    dialog.close();
                } else {
                    dialog.classList.add('hidden');
                }

                if (dialog.id === 'phylogeny-dialog') {
                    dialog.style.display = 'none';
                }
            }
            this.handleDialogClose(dialog);
            
            this.emit('dialogClose', dialog.id);
        }
    },
*/
    handleDialogClose(dialog) {
        if (!dialog) {
            logger.warn('handleDialogClose called with no dialog');
            return;
        }

        this.enableMainEventHandlers();

        document.removeEventListener('keydown', this.handleEscapeKey);

        if (dialog instanceof HTMLElement) {
            const closeButton = dialog.querySelector('.dialog-close-button');
            if (closeButton) {
                closeButton.removeEventListener('click', this.closeDialog);
            }
        }

        // Ensure main event handlers are re-enabled
        this.enableMainEventHandlers();

        this.activeDialog = null;

        ui.resetUIState();
    },

    on(eventName, callback) {
        if (!this.eventListeners[eventName]) {
            this.eventListeners[eventName] = [];
        }
        this.eventListeners[eventName].push(callback);
    },

    off(eventName, callback) {
        if (this.eventListeners[eventName]) {
            this.eventListeners[eventName] = this.eventListeners[eventName].filter(
                listener => listener !== callback
            );
        }
    },

    emit(eventName, data) {
        if (this.eventListeners[eventName]) {
            this.eventListeners[eventName].forEach(callback => callback(data));
        } else {
            logger.debug(`No listeners for event: ${eventName}`);
        }
    }, 

    handleDialogClose(dialog) {
        if (!dialog) {
            logger.warn('handleDialogClose called with no dialog');
            return;
        }

        // Re-enable main window event handlers
        this.enableMainEventHandlers();

        // Remove event listener
        document.removeEventListener('keydown', this.handleEscapeKey);

        // Remove close button event listener if dialog is an HTMLElement
        if (dialog instanceof HTMLElement) {
            const closeButton = dialog.querySelector('.dialog-close-button');
            if (closeButton) {
                closeButton.removeEventListener('click', this.closeDialog);
            }
        }

        // Ensure main event handlers are re-enabled
        this.enableMainEventHandlers();

        // Ensure the UI knows no dialog is open
        this.activeDialog = null;

        // Reset the UI state
        ui.resetUIState();
    },

    handleEscapeKey(event) {
        if (event.key === 'Escape' && this.activeDialog) {
            this.closeDialog();
        }
    },

    disableMainEventHandlers() {
        // Store and disable main window event handlers
        const mainElements = ['#random-pair-button', '#select-pair-button', '#enter-pair-button', '#share-button', '#help-button'];
        mainElements.forEach(selector => {
            const element = document.querySelector(selector);
            if (element) {
                this.mainEventHandlers[selector] = element.onclick;
                element.onclick = null;
            }
        });

        // Disable keyboard shortcuts
        document.removeEventListener('keydown', eventHandlers.handleKeyboardShortcuts);
    },

    enableMainEventHandlers() {
        // Re-enable main window event handlers
        Object.entries(this.mainEventHandlers).forEach(([selector, handler]) => {
            const element = document.querySelector(selector);
            if (element) {
                element.onclick = handler;
            }
        });

        // Re-enable keyboard shortcuts
        document.addEventListener('keydown', eventHandlers.handleKeyboardShortcuts);

        this.mainEventHandlers = {};
    },

    initializeDialogs() {
        const dialogs = ['select-pair-dialog', 'enter-pair-dialog', 'help-dialog', 'info-dialog', 'phylogeny-dialog', 'inat-down-dialog'];

        dialogs.forEach(dialogId => {
            const dialog = document.getElementById(dialogId);
            const closeButton = dialog.querySelector('.dialog-close-button');
            if (closeButton) {
                closeButton.addEventListener('click', () => this.closeDialog());
            }
        });

        // Initialize enter pair dialog elements
        this.enterPairDialog = document.getElementById('enter-pair-dialog');
        this.taxon1Input = document.getElementById('taxon1');
        this.taxon2Input = document.getElementById('taxon2');
        this.dialogMessage = document.getElementById('dialog-message');
        this.submitButton = document.getElementById('submit-dialog');

        // Add event listeners for enter pair dialog
        document.getElementById('enter-pair-button').addEventListener('click', () => this.openDialog('enter-pair-dialog'));
        document.querySelector('#enter-pair-dialog form').addEventListener('submit', this.handleNewPairSubmit.bind(this));

        this.on('dialogClose', (dialogId) => {
            // Add any specific actions you want to perform when a dialog is closed
        });

        // input validation
        this.taxon1Input.addEventListener('input', () => this.validateInputs());
        this.taxon2Input.addEventListener('input', () => this.validateInputs());
    },

    validateInputs() {
        const isValid = this.taxon1Input.value.trim() !== '' && this.taxon2Input.value.trim() !== '';
        this.submitButton.disabled = !isValid;
    },

    clearEnterPairInputs() {
        const taxon1Input = document.getElementById('taxon1');
        const taxon2Input = document.getElementById('taxon2');
        const dialogMessage = document.getElementById('dialog-message');
        taxon1Input.value = '';
        taxon2Input.value = '';
        dialogMessage.textContent = '';
        this.validateInputs();
    },

    async handleNewPairSubmit(event) {
        event.preventDefault();

        const taxon1 = this.taxon1Input.value.trim();
        const taxon2 = this.taxon2Input.value.trim();

        if (!taxon1 || !taxon2) {
            this.dialogMessage.textContent = 'Please enter both taxa.';
            return;
        }

        this.dialogMessage.textContent = 'Validating taxa...';
        this.submitButton.disabled = true;
        this.addLoadingSpinner();

        try {
            const [validatedTaxon1, validatedTaxon2] = await Promise.all([
                api.validateTaxon(taxon1),
                api.validateTaxon(taxon2)
            ]);

            if (validatedTaxon1 && validatedTaxon2) {
                const newPair = {
                    taxon1: validatedTaxon1.name,
                    taxon2: validatedTaxon2.name
                };

                this.dialogMessage.textContent = 'Saving new pair...';

                try {
                    const response = await fetch('./data/taxonPairs.json');
                    const taxonPairs = await response.json();
                    taxonPairs.push(newPair);

                    game.nextSelectedPair = newPair;
                    this.closeDialog();
                    game.setupGame(true);
                } catch (error) {
                    logger.error('Error updating taxonPairs.json:', error);
                    this.dialogMessage.textContent = 'Error saving new pair. Please try again.';
                }
            } else {
                this.dialogMessage.textContent = 'One or both taxa are invalid. Please check and try again.';
            }
        } catch (error) {
            logger.error('Error validating taxa:', error);
            this.dialogMessage.textContent = 'Error validating taxa. Please try again.';
        } finally {
            this.submitButton.disabled = false;
            this.removeLoadingSpinner();
        }
    },

    addLoadingSpinner() {
        const spinner = document.createElement('div');
        spinner.className = 'loading-spinner';
        this.dialogMessage.appendChild(spinner);
    },

    removeLoadingSpinner() {
        const spinner = this.dialogMessage.querySelector('.loading-spinner');
        if (spinner) {
            spinner.remove();
        }
    },

};

export default dialogManager;


