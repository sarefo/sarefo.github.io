
# index.html

<!DOCTYPE html>
<html lang="en">
<head>
    <title>DuoNat • iNat Taxonomy Trainer</title>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta http-equiv="Cache-Control" content="no-cache">

    <!-- For iOS devices -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- For Android devices -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#74ac00">

    <!-- cache busting by appending version code. change code in script!-->
    <script src="./code/version.js" defer></script>

    <link rel="manifest" href="./manifest.json">

    <script type="module" src="./code/functions.js" defer></script>

    <link rel="stylesheet" href="./styles/main.css">

    <link rel="icon" href="./images/favicon.png" type="image/png">
  <!--  <link rel="preload" href="./images/icons.svg" as="image" type="image/svg+xml"> -->
</head>

<body>

<!-- Loading screen at app start -->
<div id="loading-screen" class="loading-screen">

    <div class="loading-screen__content">

        <img src="./images/icon-512x512.png" alt="DuoNat logo" class="loading-screen__logo">

        <h1 class="loading-screen__title">
            <span class="loading-screen__title-duo">Duo</span><span class="loading-screen__title-nat">Nat</span>
        </h1>

        <p class="loading-screen__message">Loading amazing creatures...</p>

        <div class="loading-screen__spinner"></div>

    </div>

</div>

<!-- App main screen -->
<div class="game-container">

<div class="image-container" id="image-container-1">
  <img class="image-container__image" src="" alt="Taxon 1 Image" id="image-1">

  <div class="image-container__world-map" id="world-map-1"></div>

  <div class="image-container__drop-zone" id="drop-1"></div>

        <div id="drop-1" class="droppable"></div>

        <div class="image-container__buttons" id="image-buttons-1">
            <!-- enable when functionality added -->
            <!--<button class="image-container__button image-container__button--thumbs-up" id="thumbs-up-1" title="Like this image" data-tooltip="Like this image">
                <svg class="icon"><use href="./images/icons.svg#icon-thumb-up"/></svg>
            </button>
            <button class="image-container__button image-container__button--thumbs-down" id="thumbs-down-1" title="Dislike this image" data-tooltip="Dislike this image">
                <svg class="icon"><use href="./images/icons.svg#icon-thumb-down"/></svg>
            </button>-->
            <button class="icon-button image-container__button image-container__button--info" id="info-button-1" title="Taxon info" aria-label="Taxon info">
                <svg class="icon image-container__button-icon"><use href="./images/icons.svg#icon-info"/></svg>
            </button>
        </div>

</div>

    <div class="name-pair">

        <div class="name-pair__container name-pair__container--left">
            <div id="left-name" class="name-pair__item name-pair__item--draggable" draggable="true"></div>
        </div>

        <div class="name-pair__container name-pair__container--right">
            <div id="right-name" class="name-pair__item name-pair__item--draggable" draggable="true"></div>
        </div>

        <div id="overlay" class="name-pair__overlay">
            <div id="overlay-message" class="name-pair__overlay-message"></div>
        </div>

    </div>

    <div class="image-container" id="image-container-2">
      <img class="image-container__image" src="" alt="Taxon 2 Image" id="image-2">

      <div class="image-container__world-map" id="world-map-2"></div>

      <div class="image-container__drop-zone" id="drop-2"></div>
            <div id="drop-2" class="droppable"></div>

            <div class="image-container__buttons" id="image-buttons-2">
                <!-- enable when functionality added -->
                <!--<button class="icon-button image-container__button image-container__button--thumbs-up" id="thumbs-up-2" title="Like this image" data-tooltip="Like this image">
                    <svg class="icon"><use href="./images/icons.svg#icon-thumb-up"/></svg>
                </button>
                <button class="icon-button image-container__button image-container__button--thumbs-down" id="thumbs-down-2" title="Dislike this image" data-tooltip="Dislike this image">
                    <svg class="icon"><use href="./images/icons.svg#icon-thumb-down"/></svg>
                </button>-->
                <button class="icon-button image-container__button image-container__button--info" id="info-button-2" title="Taxon info" aria-label="Taxon info">
                    <svg class="icon image-container__button-icon"><use href="./images/icons.svg#icon-info"/></svg>
                </button>
            </div>

    </div>

</div> <!-- game-container -->

<!-- overlay buttons on the main screen -->

<button class="icon-button" id="help-button" title="Help" aria-label="Open help dialog">
    <svg class="icon">
        <use href="./images/icons.svg#icon-help"/>
    </svg>
</button>

<!-- Main menu -->
<div class="main-menu">

    <button class="icon-button" id="menu-toggle" title="Menu" aria-label="Open menu">
      <svg class="icon"><use href="./images/icons.svg#icon-menu"/></svg>
    </button>

  <div class="main-menu__dropdown main-menu__dropdown--top">

    <div class="main-menu__item">
      <span class="main-menu__label">Share this set</span>
      <button class="icon-button" id="share-button" aria-label="Share this pair">
        <svg class="icon"><use href="./images/icons.svg#icon-share"/></svg>
      </button>
    </div>

    <div class="main-menu__item">
      <span class="main-menu__label">Select new set</span>
      <button class="icon-button" id="select-pair-button" aria-label="Select new pair">
        <svg class="icon"><use href="./images/icons.svg#icon-list"/></svg>
      </button>
    </div>

    <div class="main-menu__item">
      <span class="main-menu__label">Show phylogeny</span>
      <button class="icon-button" id="phylogeny-button" aria-label="Show phylogeny">
<!--      <svg class="icon"><use href="./images/icons.svg#icon-phylogeny"/></svg>-->
        <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z" transform="rotate(90 12 12)"/>
        </svg>
      </button>
    </div>

    <!-- enable when functionality added 
    <div class="main-menu__item">
      <span class="main-menu__label">Like this pair</span>
    <button class="icon-button" id="like-button" aria-label="Like this pair">
      <svg class="icon"><use href="./images/icons.svg#icon-heart"/></svg>
    </button>
    </div>

    <div class="main-menu__item">
      <span class="main-menu__label">Trash this pair</span>
    <button class="icon-button" id="trash-button" aria-label="Trash this pair">
      <svg class="icon"><use href="./images/icons.svg#icon-trash"/></svg>
    </button>
    </div> -->

  </div>

  <div class="main-menu__dropdown main-menu__dropdown--bottom">

    <div class="main-menu__item">
      <span class="main-menu__label">Enter new pair</span>
      <button class="icon-button" id="enter-pair-button" aria-label="Enter new pair">
        <svg class="icon"><use href="./images/icons.svg#icon-plus"/></svg>
      </button>
    </div>
<!--
    <div class="main-menu__item">
      <span class="main-menu__label">Random new pair</span>
      <button class="icon-button" id="random-pair-button" aria-label="Random new pair">
        <svg class="icon"><use href="./images/icons.svg#icon-random"/></svg>
      </button>
    </div> 
-->
    <div class="main-menu__item">
      <span class="main-menu__label">Surprise!</span>
      <button class="icon-button" id="surprise-button" aria-label="Surprise!">
        <svg class="icon"><use href="./images/icons.svg#icon-star"/></svg>
      </button>
    </div>

  </div> <!-- bottom-group -->

</div> <!-- main menu -->


<!-- Dialogs, only visible when opened in app: -->
<!-- TODO: these should be in their own files -->

<!-- Help dialog -->
<dialog id="help-dialog">

<button class="dialog-close-button icon" aria-label="Close">×</button>
    <div class="help-dialog-content">
        <div class="help-dialog-header">
            <img src="./images/icon-512x512.png" alt="DuoNat logo" class="help-dialog-logo">
            <h2>
                <span class="duo">Duo</span><span class="nat">Nat</span>
                <br><span class="subtitle">iNat Taxonomy Trainer</span>
            </h2>
        </div>
        <div class="help-content">

            <div class="help-item">
                <svg class="icon"><use href="./images/icons.svg#icon-drag"/></svg>
                <p>Drag name to image</p>
            </div>

            <div class="help-item">
                <svg class="icon"> <use href="./images/icons.svg#icon-left"/></svg>
                <p>Swipe left for new pair</p>
            </div>

            <div class="help-item">
                <svg class="icon"> <use href="./images/icons.svg#icon-menu"/></svg>
                <p>Menu for more</p>
            </div>

            <div id="keyboard-shortcuts" style="display: none;">
                <h3>Keyboard Shortcuts</h3>
                <div class="help-item">
                    <svg class="icon"><use href="./images/icons.svg#icon-keyboard"/></svg>
                    <ul>
                        <li><strong>H</strong> Help</li>
                        <li><strong>G</strong> Show phylogeny graph</li>
                        <li><strong>I</strong> Info for left image</li>
                        <li><strong>O</strong> Info for right image</li>
                        <li><strong>R</strong> Random pair</li>
                        <li><strong>S</strong> Select pair</li>
                        <li><strong>E</strong> Enter pair</li>
                    </ul>
                </div>
            </div>

            <button id="start-tutorial-button">Start Tutorial</button>
            <button id="discord-help-dialog">Join us on Discord</button>
            <div id="version-id"></div>
        </div>
    </div>
</dialog>

<!-- Select pair dialog -->
    <dialog id="select-pair-dialog" class="standard-dialog">
        <div class="dialog-inner">
            <button class="dialog-close-button icon" aria-label="Close">×</button>
            <h3 class="dialog-title">Select Taxon Pair</h3>

            <button id="select-tags-button" class="select-tags-button">Select Tags</button>

            <div id="active-tags-container" class="active-tags-container">
                <div id="active-tags" class="active-tags"></div>
                <button id="clear-all-tags" class="clear-all-tags">Clear All Tags</button>
            </div>

            <div class="search-container">
                  <input type="text" id="taxon-search" placeholder="Search taxa..." aria-label="Search taxa">
                  <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                  <button id="clear-search" aria-label="Clear search" style="display: none;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                  </button>
            </div>
            <div id="taxon-pair-list" class="taxon-pair-list">
                <!-- Taxon pairs will be dynamically inserted here -->
            </div>
        </div>
    </dialog>

    <dialog id="tag-cloud-dialog" class="standard-dialog">
        <button class="dialog-close-button icon" aria-label="Close">×</button>
        <h3 class="dialog-title">Select Tags</h3>
        <div id="tag-cloud-container"></div>
        <p id="matching-pairs-count"></p>
        <button id="tag-cloud-done-button" class="done-button">Done</button>
    </dialog>

<!-- Enter pair dialog -->
    <dialog id="enter-pair-dialog" class="standard-dialog">
        <button class="dialog-close-button icon" aria-label="Close">×</button>
        <form method="dialog">
            <h2 class="dialog-title">Enter New Taxon Pair</h2>
            <div>
                <label for="taxon1">Taxon 1:</label>
                <input type="text" id="taxon1" required>
            </div>
            <div>
                <label for="taxon2">Taxon 2:</label>
                <input type="text" id="taxon2" required>
            </div>
            <div id="dialog-message" aria-live="polite"></div>
            <button type="submit" id="submit-dialog">Submit</button>
        </form>
    </dialog>


<!-- Phylogeny dialog -->
<dialog id="phylogeny-dialog" class="standard-dialog">
    <button class="dialog-close-button icon" aria-label="Close">×</button>
    <h3 class="dialog-title">Phylogenetic Relationship</h3>
    <div id="graph-hint" class="graph-hint">Tip: Click on a node to open its iNaturalist page</div>
    <div id="taxa-relationship-graph"></div>
</dialog>


<!-- Info dialog -->
<dialog id="info-dialog" class="info-dialog">

    <button class="dialog-close-button icon" id="info-close-button" aria-label="Close">×</button>
    <div class="info-dialog__header">
        <h2 id="info-dialog-taxon" class="info-dialog__taxon"></h2>
        <p id="info-dialog-vernacular" class="info-dialog__vernacular"></p>
    </div>
    <div id="info-dialog-facts" class="info-dialog__facts"></div>

<div class="info-dialog__buttons">
    <button id="hints-button" class="icon-button info-dialog__button info-dialog__button--hints" title="Hints" aria-label="Show identification hints (TODO)">
<!--    <svg class="icon info-dialog__button--inactive" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M9 21c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-1H9v1zm3-19C8.14 2 5 5.14 5 9c0 2.38 1.19 4.47 3 5.74V17c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-2.26c1.81-1.27 3-3.36 3-5.74 0-3.86-3.14-7-7-7zm2.85 11.1l-.85.6V16h-4v-2.3l-.85-.6C7.8 12.16 7 10.63 7 9c0-2.76 2.24-5 5-5s5 2.24 5 5c0 1.63-.8 3.16-2.15 4.1z"/>
        </svg>-->
<!--        <svg class="info-dialog__button-icon icon"><use href="./images/icons.svg#icon-info"/></svg>-->
    </button>
    <button id="photo-button" class="icon-button info-dialog__button info-dialog__button--photo" title="Photo Page" aria-label="Open iNat photo page">
        <svg class="info-dialog__button-icon icon"><use href="./images/icons.svg#icon-camera"/></svg>
    </button>
    <button id="observation-button" class="icon-button info-dialog__button info-dialog__button--observation" title="Observation page" aria-label="Open iNat observation (TODO)">
<!--        <svg class="info-dialog__button-icon icon info-dialog__button--inactive"><use href="./images/icons.svg#icon-microscope"/></svg>-->
    </button>
    <button id="taxon-button" class="icon-button info-dialog__button info-dialog__button--taxon" title="Taxon page" aria-label="Open taxon page">
        <svg class="info-dialog__button-icon icon"><use href="./images/icons.svg#icon-info"/></svg>
<!--        <svg class="info-dialog__button-icon icon"><use href="./images/icons.svg#icon-taxon"/></svg>-->
    </button>
    <button id="wiki-button" class="icon-button info-dialog__button info-dialog__button--wiki" title="Wikipedia page" aria-label="Open Wikipedia page">
        <svg class="info-dialog__button-icon icon"><use href="./images/icons.svg#icon-wiki"/></svg>
    </button>
    <button id="report-button" class="icon-button info-dialog__button info-dialog__button--report" title="Report problem" aria-label="Report problem">
<!--        <svg class="info-dialog__button-icon icon"><use href="./images/icons.svg#icon-report"/></svg>-->
    </button>
</div>

</dialog>


<!-- iNat down dialog -->
<dialog id="inat-down-dialog" class="standard-dialog">
    <button class="dialog-close-button icon" aria-label="Close">×</button>
  <h2 class="dialog-title">iNaturalist Unavailable</h2>
  <p>We're having trouble connecting to iNaturalist. This could be due to maintenance or temporary issues.</p>
  <button id="check-inat-status">Check iNaturalist Status</button>
  <button id="retry-connection">Retry Connection</button>
</dialog>

<div id="swipe-info-message" class="swipe-info-message">New random pair</div>

</body>
</html>



# code/game.js

import api from './api.js';
import config from './config.js';
import dialogManager from './dialogManager.js';
import { elements, gameState, updateGameState, GameState } from './state.js';
import logger from './logger.js';
import preloader from './preloader.js';
import taxaRelationshipViewer from './taxaRelationshipViewer.js';
import ui from './ui.js';
import utils from './utils.js';
import { createWorldMap } from './worldMap.js';

const game = {
    loadingMessage: "",
    //loadingMessage: "Loading...",
    nextSelectedPair: null,
    currentState: GameState.IDLE,
    currentGraphTaxa: null,
    preloadedPair: null,
    preloadedImages: {
        current: {
            taxon1: [],
            taxon2: []
        },
        next: {
            taxon1: [],
            taxon2: []
        }
    },

    currentObservationURLs: {
        imageOne: null,
        imageTwo: null
    },

    setState(newState) {
        this.currentState = newState;
    },

    showLoadingScreen: function () {
        document.getElementById('loading-screen').style.display = 'flex';
    },

    hideLoadingScreen: function () {
        setTimeout(() => {
            document.getElementById('loading-screen').style.display = 'none';
        }, 500); // 500ms delay, adjust as needed
    },

    async setupGame(newPair = false) {
        this.setState(GameState.LOADING);

        if (!await this.checkINaturalistReachability()) { return; }

        this.prepareUIForLoading();

        try {
            logger.debug("Setting up game with newPair:", newPair);
            logger.debug("Current nextSelectedPair:", this.nextSelectedPair);

            if (newPair || !gameState.currentTaxonImageCollection) {
                await this.initializeNewPair();
            } else {
                await this.setupRound();
            }

            this.finishSetup();

            this.setNamePairHeight();

            // Always preload for the next round
            await preloader.preloadForNextRound();
            logger.debug("Preloaded for next round");

            // Always preload for the next pair
            await preloader.preloadForNextPair();
            logger.debug("Preloaded for next pair");

            this.setState(GameState.PLAYING);
            this.hideLoadingScreen();

            if (gameState.isInitialLoad) {
                updateGameState({ isInitialLoad: false });
            }

            ui.hideOverlay();
            ui.resetUIState();
        } catch (error) {
            this.handleSetupError(error);
        }
    },

    async initializeNewPair() {
        let newPair, imageOneURL, imageTwoURL;

        logger.debug("Initializing new pair");
        logger.debug("Current nextSelectedPair:", this.nextSelectedPair);

        if (this.nextSelectedPair) {
            newPair = this.nextSelectedPair;
            logger.debug("Using nextSelectedPair:", newPair);
            this.nextSelectedPair = null;
            [imageOneURL, imageTwoURL] = await Promise.all([
                api.fetchRandomImageMetadata(newPair.taxon1),
                api.fetchRandomImageMetadata(newPair.taxon2)
            ]);
        } else {
            const preloadedPair = preloader.getPreloadedImagesForNextPair();
            if (preloadedPair && preloadedPair.pair) {
                logger.debug("Using preloaded pair:", preloadedPair.pair);
                newPair = preloadedPair.pair;
                imageOneURL = preloadedPair.taxon1;
                imageTwoURL = preloadedPair.taxon2;
            } else {
                logger.debug("No preloaded pair available, selecting random pair");
                newPair = await utils.selectTaxonPair();
                [imageOneURL, imageTwoURL] = await Promise.all([
                    api.fetchRandomImageMetadata(newPair.taxon1),
                    api.fetchRandomImageMetadata(newPair.taxon2)
                ]);
            }
        }

        updateGameState({
            currentTaxonImageCollection: {
                pair: newPair,
                imageOneURL,
                imageTwoURL
            },
            usedImages: {
                taxon1: new Set([imageOneURL]),
                taxon2: new Set([imageTwoURL])
            }
        });

        await this.setupRound(true);
    },

    async setupRound(isNewPair = false) {
        const { pair } = gameState.currentTaxonImageCollection;
        const randomized = Math.random() < 0.5;

        let imageOneURL, imageTwoURL;

        if (isNewPair) {
            imageOneURL = gameState.currentTaxonImageCollection.imageOneURL;
            imageTwoURL = gameState.currentTaxonImageCollection.imageTwoURL;
        } else {
            const preloadedImages = preloader.getPreloadedImagesForNextRound();
            if (preloadedImages && preloadedImages.taxon1 && preloadedImages.taxon2) {
                imageOneURL = preloadedImages.taxon1;
                imageTwoURL = preloadedImages.taxon2;
            } else {
                [imageOneURL, imageTwoURL] = await Promise.all([
                    preloader.fetchDifferentImage(pair.taxon1, gameState.currentRound.imageOneURL),
                    preloader.fetchDifferentImage(pair.taxon2, gameState.currentRound.imageTwoURL)
                ]);
            }
        }

        const leftImageSrc = randomized ? imageOneURL : imageTwoURL;
        const rightImageSrc = randomized ? imageTwoURL : imageOneURL;

        await this.loadImages(leftImageSrc, rightImageSrc);

        // Set the observation URLs
        this.currentObservationURLs.imageOne = this.getObservationURLFromImageURL(leftImageSrc);
        this.currentObservationURLs.imageTwo = this.getObservationURLFromImageURL(rightImageSrc);

        const [leftVernacular, rightVernacular] = await Promise.all([
            utils.capitalizeFirstLetter(await api.fetchVernacular(randomized ? pair.taxon1 : pair.taxon2)),
            utils.capitalizeFirstLetter(await api.fetchVernacular(randomized ? pair.taxon2 : pair.taxon1))
        ]);

        this.setupNameTilesUI(
            randomized ? pair.taxon1 : pair.taxon2,
            randomized ? pair.taxon2 : pair.taxon1,
            leftVernacular,
            rightVernacular
        );

        // Add world maps
        const leftContinents = await this.getContinentForTaxon(randomized ? pair.taxon1 : pair.taxon2);
        const rightContinents = await this.getContinentForTaxon(randomized ? pair.taxon2 : pair.taxon1);
        createWorldMap(elements.imageOneContainer, leftContinents);
        createWorldMap(elements.imageTwoContainer, rightContinents);

        updateGameState({
            taxonImageOne: randomized ? pair.taxon1 : pair.taxon2,
            taxonImageTwo: randomized ? pair.taxon2 : pair.taxon1,
            currentRound: {
                pair,
                imageOneURL,
                imageTwoURL,
                imageOneVernacular: leftVernacular,
                imageTwoVernacular: rightVernacular,
                randomized
            }
        });

    },

    async getContinentForTaxon(taxon) {
        const taxonInfo = await api.loadTaxonInfo();
        const taxonData = Object.values(taxonInfo).find(info => info.taxonName.toLowerCase() === taxon.toLowerCase());

        if (taxonData && taxonData.distribution && taxonData.distribution.length > 0) {
            // Convert the continent codes to full names
            const continentMap = {
                'NA': 'North America',
                'SA': 'South America',
                'EU': 'Europe',
                'AS': 'Asia',
                'AF': 'Africa',
                'OC': 'Oceania'
            };

            // Convert all continent codes to full names
            const fullContinents = taxonData.distribution.map(code => continentMap[code]);

            return fullContinents;
        } else {
            logger.debug(`No distribution data found for ${taxon}. Using placeholder.`);
            return ['North America', 'South America', 'Europe', 'Africa', 'Asia', 'Oceania'];
        }
    },

    async checkINaturalistReachability() {
        if (!await api.isINaturalistReachable()) {
            ui.showINatDownDialog();
            this.setState(GameState.IDLE);
            return false;
        }
        ui.hideINatDownDialog();
        return true;
    },

    async fetchTaxonImageCollection(newPair) {
        let attempts = 0;
        const maxAttempts = 3;

        while (attempts < maxAttempts) {
            try {
                return await this.attemptFetchTaxonImageCollection(newPair);
            } catch (error) {
                attempts++;
                if (this.shouldRetryFetch(error, attempts, maxAttempts)) {
                    await this.handleFetchError(error);
                } else {
                    throw error;
                }
            }
        }

        throw new Error("Failed to load images after multiple attempts");
    },

    async attemptFetchTaxonImageCollection(newPair) {
        if (newPair || !gameState.currentTaxonImageCollection) {
            if (this.nextSelectedPair) {
                const collection = await this.initializeNewTaxonPair(this.nextSelectedPair);
                this.nextSelectedPair = null;
                return collection;
            } else if (this.preloadedPair) {
                const collection = this.preloadedPair;
                this.preloadedPair = null;
                return collection;
            } else {
                return await this.initializeNewTaxonPair();
            }
        }
        return gameState.currentTaxonImageCollection;
    },

    shouldRetryFetch(error, attempts, maxAttempts) {
        return attempts < maxAttempts && error.message.includes("No images found");
    },

    async handleFetchError(error) {
        if (error.message.includes("No images found")) {
            const taxonName = error.message.split("No images found for ")[1];
            ui.showOverlay(`Warning: No images found for ${taxonName}. Trying another pair...`, config.overlayColors.red);
            await utils.sleep(2000);
            this.nextSelectedPair = null;
        }
    },

    handleSetupError(error) {
        logger.error("Error setting up game:", error);
        ui.showOverlay("Error loading game. Please try again.", config.overlayColors.red);
        this.setState(GameState.IDLE);
        if (gameState.isInitialLoad) {
            this.hideLoadingScreen();
            updateGameState({ isInitialLoad: false });
        }
    },

    async initializeNewTaxonPair(pair = null) {

        const newPair = pair || await utils.selectTaxonPair();
        const [imageOneURL, imageTwoURL] = await Promise.all([
            api.fetchRandomImage(newPair.taxon1),
            api.fetchRandomImage(newPair.taxon2)
        ]);

        return {
            pair: newPair,
            imageOneURL,
            imageTwoURL,
            imageOneVernacular: null,
            imageTwoVernacular: null
        };
    },

    async loadCurrentTaxonImageCollection() {
        if (!gameState.currentTaxonImageCollection || !gameState.currentTaxonImageCollection.pair) {
            logger.error("currentTaxonImageCollection or its pair is null");
            throw new Error("Invalid currentTaxonImageCollection");
        }

        const { taxon1, taxon2 } = gameState.currentTaxonImageCollection.pair;
        // TODO not sure if for one or both pairs? one taxon should not have more than 12 images
        const MAX_IMAGES = 24; // Adjust this number as needed

        const [imageOneURLs, imageTwoURLs, imageOneVernacular, imageTwoVernacular] = await Promise.all([
            api.fetchMultipleImages(taxon1),
            api.fetchMultipleImages(taxon2),
            api.fetchVernacular(taxon1),
            api.fetchVernacular(taxon2)
        ]);

        updateGameState({
            currentTaxonImageCollection: {
                ...gameState.currentTaxonImageCollection,
                imageOneURLs: imageOneURLs.slice(0, MAX_IMAGES),
                imageTwoURLs: imageTwoURLs.slice(0, MAX_IMAGES),
                imageOneVernacular,
                imageTwoVernacular
            }
        });

        await preloader.preloadImages(imageOneURLs.slice(0, MAX_IMAGES).concat(imageTwoURLs.slice(0, MAX_IMAGES)));
    },

    async preloadImagesForCurrentPair() {
        const { pair } = gameState.currentTaxonImageCollection;

        try {
            const [newImageOneURL, newImageTwoURL] = await Promise.all([
                api.fetchRandomImageMetadata(pair.taxon1),
                api.fetchRandomImageMetadata(pair.taxon2)
            ]);

            await Promise.all([
                this.preloadImage(newImageOneURL),
                this.preloadImage(newImageTwoURL)
            ]);

            this.preloadedImages.current.taxon1.push(newImageOneURL);
            this.preloadedImages.current.taxon2.push(newImageTwoURL);

        } catch (error) {
            logger.error("Error preloading images for current pair:", error);
        }
    },

    preloadImage(url) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                resolve(url);
            };
            img.onerror = () => {
                logger.error(`Failed to load image: ${url}`);
                reject(url);
            };
            img.src = url;
        });
    },

    loadImages: async function (leftImageSrc, rightImageSrc) {
        await Promise.all([
            this.loadImageAndRemoveLoadingClass(elements.imageOne, leftImageSrc),
            this.loadImageAndRemoveLoadingClass(elements.imageTwo, rightImageSrc)
        ]);
    },

    async loadImageAndRemoveLoadingClass(imgElement, src) {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
                imgElement.src = src;
                imgElement.classList.remove('image-container__image--loading');
                // Add a slight delay before adding the 'loaded' class
                setTimeout(() => {
                    imgElement.classList.add('image-container__image--loaded');
                    resolve();
                }, 50); // 50ms delay to ensure the browser has time to apply the new src
            };
            img.src = src;
        });
    },

    async showTaxaRelationship() {
        const { taxonImageOne, taxonImageTwo } = gameState;
        const container = document.getElementById('taxa-relationship-graph');
        const dialog = document.getElementById('phylogeny-dialog');

        if (!taxonImageOne || !taxonImageTwo) {
            logger.error('Taxon names not available');
            alert('Unable to show relationship. Please try again after starting a new game.');
            return;
        }

        // Show the dialog
        dialog.style.display = 'flex'; // Change to flex to match the CSS layout
        dialogManager.openDialog('phylogeny-dialog');

        try {
            await taxaRelationshipViewer.initialize(container);

            if (this.currentGraphTaxa &&
                this.currentGraphTaxa[0] === taxonImageOne &&
                this.currentGraphTaxa[1] === taxonImageTwo) {
                logger.debug("Showing existing graph for the same taxa pair");
                taxaRelationshipViewer.showExistingGraph();
            } else {
                logger.debug("Creating new graph for a different taxa pair");
                taxaRelationshipViewer.clearGraph();
                await taxaRelationshipViewer.findRelationship(taxonImageOne, taxonImageTwo);
                this.currentGraphTaxa = [taxonImageOne, taxonImageTwo];
            }
        } catch (error) {
            logger.error('Error showing taxa relationship:', error);
            alert('Failed to load the relationship graph. Please try again later.');
            dialog.style.display = 'none'; // Hide the dialog on error
            dialogManager.closeDialog();
        }
    },

    prepareUIForLoading: function () {
        utils.resetDraggables();
        elements.imageOne.classList.add('image-container__image--loading');
        elements.imageTwo.classList.add('image-container__image--loading');
        var startMessage = gameState.isFirstLoad ? "Drag the names!" : `${this.loadingMessage}`;
        ui.showOverlay(startMessage, config.overlayColors.green);
        // what does this do?
        gameState.isFirstLoad = false;
    },

    async loadNewRandomPair() {
        if (this.currentState === GameState.LOADING) {
            logger.debug("Already loading a new pair, ignoring request");
            return;
        }

        logger.debug("Loading new pair");
        this.setState(GameState.LOADING);
        ui.showOverlay(`${this.loadingMessage}`, config.overlayColors.green);
        elements.imageOne.classList.add('image-container__image--loading');
        elements.imageTwo.classList.add('image-container__image--loading');

        try {
            this.nextSelectedPair = null; // Ensure we're not using a previously selected pair
            await this.setupGame(true);
            ui.hideOverlay();
        } catch (error) {
            logger.error("Error loading new pair:", error);
            ui.showOverlay("Error loading new pair. Please try again.", config.overlayColors.red);
        } finally {
            this.setState(GameState.PLAYING);
        }
    },

    // Update this method to set the nextSelectedPair
    async loadNewTaxonPair(newPair) {
        this.nextSelectedPair = newPair;
        await this.setupGame(true);
    },

    checkAnswer(droppedZoneId) {
        logger.debug("Checking answer. Current state:", this.currentState);

        if (this.currentState !== GameState.PLAYING) {
            logger.debug("Cannot check answer when not in PLAYING state");
            return;
        }

        this.setState(GameState.CHECKING);

        const dropOne = document.getElementById('drop-1');
        const dropTwo = document.getElementById('drop-2');
        const colorCorrect = config.overlayColors.green;
        const colorWrong = config.overlayColors.red;

        const leftAnswer = dropOne.children[0]?.getAttribute('data-taxon');
        const rightAnswer = dropTwo.children[0]?.getAttribute('data-taxon');

        if (leftAnswer || rightAnswer) {
            let isCorrect = false;
            if (droppedZoneId === 'drop-1') {
                isCorrect = leftAnswer === gameState.taxonImageOne;
            } else {
                isCorrect = rightAnswer === gameState.taxonImageTwo;
            }

            if (isCorrect) {
                this.handleCorrectAnswer();
            } else {
                this.handleIncorrectAnswer();
            }
        } else {
            logger.debug("Incomplete answer. Returning to PLAYING state.");
            this.setState(GameState.PLAYING);
        }
    },

    async handleCorrectAnswer() {
        await ui.showOverlay('Correct!', config.overlayColors.green);
        elements.imageOne.classList.add('image-container__image--loading');
        elements.imageTwo.classList.add('image-container__image--loading');
        await utils.sleep(2000); // Show "Correct!" for a while
        ui.updateOverlayMessage(`${this.loadingMessage}`); // Update message without changing color
        await this.setupGame(false);  // Start a new round with the same taxon pair
    },

    async handleIncorrectAnswer() {
        utils.resetDraggables();
        await ui.showOverlay('Try again!', config.overlayColors.red);
        await utils.sleep(1200);
        ui.hideOverlay();
        this.setState(GameState.PLAYING);
    },

    // determine height of tallest name tile, to keep layout stable over multiple rounds
    setNamePairHeight: function () {
        const leftName = document.getElementById('left-name');
        const rightName = document.getElementById('right-name');
        const namePair = document.querySelector('.name-pair');

        // Reset the height to auto to get the natural height
        leftName.style.height = 'auto';
        rightName.style.height = 'auto';
        namePair.style.height = 'auto';

        // Use requestAnimationFrame to ensure the browser has rendered the auto heights
        requestAnimationFrame(() => {
            const maxHeight = Math.max(leftName.offsetHeight, rightName.offsetHeight);

            // Set the height of the name-pair container
            namePair.style.height = `${maxHeight}px`;

            // Set both name tiles to this height
            leftName.style.height = `${maxHeight}px`;
            rightName.style.height = `${maxHeight}px`;
        });
    },

    setupNameTilesUI: function (leftName, rightName, leftNameVernacular, rightNameVernacular) {
        // Randomize the position of the name tiles
        const shouldSwap = Math.random() < 0.5;

        const nameOne = shouldSwap ? rightName : leftName;
        const nameTwo = shouldSwap ? leftName : rightName;
        const vernacularOne = shouldSwap ? rightNameVernacular : leftNameVernacular;
        const vernacularTwo = shouldSwap ? leftNameVernacular : rightNameVernacular;

        elements.leftName.setAttribute('data-taxon', nameOne);
        elements.rightName.setAttribute('data-taxon', nameTwo);
        elements.leftName.style.zIndex = '10';
        elements.rightName.style.zIndex = '10';

        // Create a span for the taxon name and a span for the vernacular name
        elements.leftName.innerHTML = `
            <span class="name-pair__taxon-name">${nameOne}</span>
            ${vernacularOne ? `<span class="name-pair__vernacular-name">${vernacularOne}</span>` : ''}
        `;
        elements.rightName.innerHTML = `
            <span class="name-pair__taxon-name">${nameTwo}</span>
            ${vernacularTwo ? `<span class="name-pair__vernacular-name">${vernacularTwo}</span>` : ''}
        `;

        gameState.taxonLeftName = nameOne;
        gameState.taxonRightName = nameTwo;

    },

    finishSetup: function () {
        ui.hideOverlay();
    },

    // TODO for now only gives photo page
    getObservationURLFromImageURL(imageURL) {
        const match = imageURL.match(/\/photos\/(\d+)\//);
        if (match && match[1]) {
            return `https://www.inaturalist.org/photos/${match[1]}`;
        }
        return null;
    },

    initializeInfoButtons() {
        const infoButton1 = document.getElementById('info-button-1');
        const infoButton2 = document.getElementById('info-button-2');

        infoButton1.addEventListener('click', () => this.showInfoDialog(this.currentObservationURLs.imageOne, 1));
        infoButton2.addEventListener('click', () => this.showInfoDialog(this.currentObservationURLs.imageTwo, 2));
    },

    openObservationURL(url) {
        if (url) {
            this.showInfoDialog(url);
        } else {
            logger.error('Observation URL not available');
        }
    },

    showInfoDialog(url, imageIndex) {
        const dialog = document.getElementById('info-dialog');
        const taxonElement = document.getElementById('info-dialog-taxon');
        const vernacularElement = document.getElementById('info-dialog-vernacular');
        const factsElement = document.getElementById('info-dialog-facts');
        const photoButton = document.getElementById('photo-button');
        const observationButton = document.getElementById('observation-button');
        const taxonButton = document.getElementById('taxon-button');
        const hintsButton = document.getElementById('hints-button');
        const wikiButton = document.getElementById('wiki-button');
        const reportButton = document.getElementById('report-button');
        const closeButton = document.getElementById('info-close-button');

        // Get the image containers
        const topImageContainer = document.getElementById('image-container-1');
        const bottomImageContainer = document.getElementById('image-container-2');
        const namePairContainer = document.querySelector('.name-pair');

        // Position the dialog
        const positionDialog = () => {
            const dialogRect = dialog.getBoundingClientRect();
            const topContainerRect = topImageContainer.getBoundingClientRect();
            const bottomContainerRect = bottomImageContainer.getBoundingClientRect();
            const namePairRect = namePairContainer.getBoundingClientRect();

            if (imageIndex === 1) {
                // For the top image
                dialog.style.top = `${namePairRect.top}px`;
                dialog.style.bottom = `${window.innerHeight - bottomContainerRect.bottom}px`;
                dialog.style.height = 'auto'; // Let the height adjust automatically
            } else {
                // For the bottom image
                dialog.style.top = `${topContainerRect.top}px`;
                dialog.style.bottom = `${window.innerHeight - namePairRect.bottom}px`;
                dialog.style.height = 'auto'; // Let the height adjust automatically
            }

            // Center horizontally
            dialog.style.left = `${(window.innerWidth - dialogRect.width) / 2}px`;
        };

        // Frame the corresponding image if imageIndex is provided
        if (imageIndex) {
            const imageContainer = document.getElementById(`image-container-${imageIndex}`);
            if (imageContainer) {
                imageContainer.classList.add('image-container--framed');
            }
        }

        // Set taxon and vernacular name
        const currentTaxon = this.getCurrentTaxonName(url);
        taxonElement.textContent = currentTaxon;
        // TODO check why api.fetchVernacular() won't work here
        api.fetchVernacular(currentTaxon).then(vernacularName => {
            vernacularElement.textContent = vernacularName;

            // Add taxon facts (assuming they're still in taxonInfo.json)
            api.loadTaxonInfo().then(taxonInfo => {
                const taxonData = Object.values(taxonInfo).find(info => info.taxonName.toLowerCase() === currentTaxon.toLowerCase());
                if (taxonData && taxonData.taxonFacts && taxonData.taxonFacts.length > 0) {
                    factsElement.innerHTML = '<h3>Facts:</h3><ul>' +
                        taxonData.taxonFacts.map(fact => `<li>${fact}</li>`).join('') +
                        '</ul>';
                    factsElement.style.display = 'block';
                } else {
                    factsElement.style.display = 'none';
                }

                // Position the dialog after content is loaded
                dialog.setAttribute('open', ''); // Explicitly set the 'open' attribute
                positionDialog();
            });
        });

        photoButton.onclick = () => {
            window.open(url, '_blank');
            dialog.close();
        };

        observationButton.onclick = () => {
            logger.debug("Observation button clicked");
            // Implement observation functionality here
        };

        taxonButton.onclick = async () => {
            logger.debug("Taxon button clicked");
            try {
                const taxonName = this.getCurrentTaxonName(url);
                const taxonId = await api.fetchTaxonId(taxonName);
                window.open(`https://www.inaturalist.org/taxa/${taxonId}`, '_blank');
                dialog.close();
            } catch (error) {
                logger.error("Error opening taxon page:", error);
                alert("Unable to open taxon page. Please try again.");
            }
        };

        hintsButton.onclick = () => {
            logger.debug("Taxon hints button clicked");
            // Implement taxon hints functionality here
        };

        wikiButton.onclick = () => {
            logger.debug("Wiki button clicked");
            try {
                const taxonName = this.getCurrentTaxonName(url);
                //                    const taxonId = await api.fetchTaxonId(taxonName);
                window.open(`https://en.wikipedia.org/wiki/${taxonName}`, '_blank');
                dialog.close();
            } catch (error) {
                logger.error("Error opening taxon page:", error);
                alert("Unable to open Wikipedia page. Please try again.");
            }
        };

        reportButton.onclick = () => {
            logger.debug("Report button clicked");
            // Implement report functionality here
        };

        closeButton.onclick = () => {
            dialog.close();
            document.querySelectorAll('.image-container').forEach(container => {
                container.classList.remove('image-container--framed');
            });
        };

        dialog.addEventListener('close', () => {
            // Remove framing from all containers when dialog is closed
            document.querySelectorAll('.image-container').forEach(container => {
                container.classList.remove('image-container--framed');
            });
        });

        dialog.showModal();
        // Reposition on window resize
        window.addEventListener('resize', positionDialog);

    },

    getCurrentTaxonName(url) {
        if (url === this.currentObservationURLs.imageOne) {
            return gameState.taxonImageOne;
        } else if (url === this.currentObservationURLs.imageTwo) {
            return gameState.taxonImageTwo;
        } else {
            logger.error("Unable to determine current taxon name");
            return null;
        }
    },

};

// Initialize info buttons
game.initializeInfoButtons();

export default game;



# code/state.js

// Elements and game state

// DOM elements
export const elements = {
  imageOne: document.getElementById('image-1'),
  imageTwo: document.getElementById('image-2'),
  imageOneContainer: document.getElementById('image-container-1'),
  imageTwoContainer: document.getElementById('image-container-2'),
  namePair: document.querySelector('.name-pair'),
  leftName: document.getElementById('left-name'),
  rightName: document.getElementById('right-name'),
  overlay: document.getElementById('overlay'),
  overlayMessage: document.getElementById('overlay-message'),
  buttons: document.querySelectorAll('.bottom-button')
};

// Game State enum
export const GameState = {
  IDLE: 'IDLE',
  LOADING: 'LOADING',
  READY: 'READY',
  PLAYING: 'PLAYING',
  CHECKING: 'CHECKING',
  PRELOADING: 'PRELOADING',
  PRELOADING_BACKGROUND: 'PRELOADING_BACKGROUND'
};

export const gameState = {
  preloadState: {
    currentRound: {
      taxon1: null,
      taxon2: null
    },
    nextRound: {
      taxon1: null,
      taxon2: null
    },
    nextPair: {
      taxon1: null,
      taxon2: null
    },
  },
    selectedTags: [],

  // check which of these still used:
  isFirstLoad: true,
  isInitialLoad: true,
  isPreloading: false,
  preloadedPair: null,
  currentSession: 1,
  /*   currentRound: 1, */
  roundPreload: null,
  pairPreload: null,

  currentRound: {
    pair: null,
    imageOneURLs: [],
    imageTwoURLs: [],
    imageOneVernacular: null,
    imageTwoVernacular: null,
    randomized: false
  },

    usedImages: {
        taxon1: new Set(),
        taxon2: new Set()
    },

  preloadedTaxonImageCollection: null,
  currentTaxonImageCollection: null,
  taxonImageOne: null,
  taxonImageTwo: null,
  taxonLeftName: null,
  taxonRightName: null,
  currentState: GameState.IDLE  // track the current game state
};

// Function to update game state
export function updateGameState(newState) {
  Object.assign(gameState, newState);
}



# code/ui.js

import api from './api.js';
import config from './config.js';
import dialogManager from './dialogManager.js';
import { elements, gameState } from './state.js';
import game from './game.js';
import logger from './logger.js';
import tagCloud from './tagCloud.js';
import utils from './utils.js';

const vernacularNameCache = new Map();

async function getCachedVernacularName(taxonName) {
    if (!vernacularNameCache.has(taxonName)) {
        const vernacularName = await api.fetchVernacular(taxonName);
        vernacularNameCache.set(taxonName, vernacularName);
    }
    return vernacularNameCache.get(taxonName) || 'n/a';
}

const ui = {
    isMenuOpen: false,

    resetUIState: function () {
        this.closeMainMenu();
        // Add any other UI state resets here if needed
    },

    resetGameContainerStyle: function () {
        const gameContainer = document.querySelector('.game-container');
        if (gameContainer) {
            gameContainer.style.transform = '';
            gameContainer.style.opacity = '';
        }
        elements.imageOneContainer.style.transform = '';
        elements.imageOneContainer.style.opacity = '';
        elements.imageTwoContainer.style.transform = '';
        elements.imageTwoContainer.style.opacity = '';
    },

    // display pair list for selection
    showTaxonPairList: async function () {
        try {
            const taxonPairs = await api.fetchTaxonPairs();
            if (taxonPairs.length === 0) {
                logger.error("No taxon pairs available");
                return;
            }

            const list = document.getElementById('taxon-pair-list');
            list.innerHTML = ''; // Clear existing content

            // Filter pairs based on selected tags
            const selectedTags = tagCloud.getSelectedTags();
            let filteredPairs = taxonPairs;
            if (selectedTags.length > 0) {
                filteredPairs = taxonPairs.filter(pair =>
                    pair.tags.some(tag => selectedTags.includes(tag))
                );
            }

            // Render only visible pairs initially
            await this.renderVisibleTaxonPairs(filteredPairs);

            dialogManager.openDialog('select-pair-dialog');
        } catch (error) {
            logger.error("Error in showTaxonPairList:", error);
        }
    },

    renderTaxonPairList: async function (pairs) {
        const list = document.getElementById('taxon-pair-list');
        list.innerHTML = ''; // Clear existing content

        if (pairs.length === 0) {
            const noResultsMessage = document.createElement('p');
            noResultsMessage.textContent = 'No matching pairs found.';
            noResultsMessage.className = 'no-results-message';
            list.appendChild(noResultsMessage);
        } else {
            for (const pair of pairs) {
                const button = await this.createTaxonPairButton(pair);
                list.appendChild(button);
            }
        }
    },

    renderVisibleTaxonPairs: async function (pairs) {
        const list = document.getElementById('taxon-pair-list');
        const visiblePairs = pairs.slice(0, 20); // Render first 20 pairs

        for (const pair of visiblePairs) {
            const button = await this.createTaxonPairButton(pair);
            list.appendChild(button);
        }

        // Implement lazy loading for remaining pairs
        if (pairs.length > 20) {
            const loadMoreButton = document.createElement('button');
            loadMoreButton.textContent = 'Load More';
            loadMoreButton.addEventListener('click', () => this.loadMorePairs(pairs, 20));
            list.appendChild(loadMoreButton);
        }
    },

    loadMorePairs: async function (pairs, startIndex) {
        const list = document.getElementById('taxon-pair-list');
        const nextPairs = pairs.slice(startIndex, startIndex + 20);

        for (const pair of nextPairs) {
            const button = await this.createTaxonPairButton(pair);
            list.insertBefore(button, list.lastChild);
        }

        if (startIndex + 20 >= pairs.length) {
            list.removeChild(list.lastChild); // Remove "Load More" button
        } else {
            list.lastChild.addEventListener('click', () => this.loadMorePairs(pairs, startIndex + 20));
        }
    },

    updateTaxonPairList: async function (filteredPairs) {
        const list = document.getElementById('taxon-pair-list');
        list.innerHTML = ''; // Clear existing content

        if (filteredPairs.length === 0) {
            const noResultsMessage = document.createElement('p');
            noResultsMessage.textContent = 'No matching pairs found.';
            noResultsMessage.className = 'no-results-message';
            list.appendChild(noResultsMessage);
        } else {
            for (const pair of filteredPairs) {
                const button = await this.createTaxonPairButton(pair);
                list.appendChild(button);
            }
        }
    },

    createTaxonPairButton: async function (pair) {
        const button = document.createElement('button');
        button.className = 'taxon-set-button';

        let result = await getCachedVernacularName(pair.taxon1);
        const vernacular1 = result === "n/a" ? "" : result;

        result = await getCachedVernacularName(pair.taxon2);
        const vernacular2 = result === "n/a" ? "" : result;

        button.innerHTML = `
            <div class="taxon-set-container">
                <div class="taxon-set-info">
                    <div class="set-name">${pair.setName || 'Unnamed Set'}</div>
                    <div class="tags">${pair.tags.join(', ')}</div>
                </div>
                <div class="taxon-item">
                    <div class="taxon-name">${pair.taxon1}</div>
                    <div class="vernacular-name">${vernacular1}</div>
                </div>
                <div class="taxon-item">
                    <div class="taxon-name">${pair.taxon2}</div>
                    <div class="vernacular-name">${vernacular2}</div>
                </div>
            </div>
        `;

        button.onclick = () => {
            // Create a new object with the pair data to ensure we're not using a reference
            const selectedPair = {
                taxon1: pair.taxon1,
                taxon2: pair.taxon2,
                setName: pair.setName,
                tags: [...pair.tags],
                setID: pair.setID
            };

            game.nextSelectedPair = selectedPair;
            logger.debug('Selected pair:', selectedPair);

            setTimeout(() => {
                dialogManager.closeDialog('select-pair-dialog');
                game.setupGame(true);
            }, 300);
        };

        return button;
    },

    updateVernacularNames: async function (button, pair) {
        const vernacular1 = await getCachedVernacularName(pair.taxon1);
        const vernacular2 = await getCachedVernacularName(pair.taxon2);

        const vernacularElements = button.querySelectorAll('.vernacular-name');
        vernacularElements[0].textContent = vernacular1 || '';
        vernacularElements[1].textContent = vernacular2 || '';
    },

    showOverlay: function (message = "", color) {
        elements.overlayMessage.innerHTML = message;
        elements.overlay.style.backgroundColor = color;
        elements.overlay.classList.add('show');

        // Adjust font size for longer messages
        if (message.length > 20) {
            elements.overlayMessage.style.fontSize = '1.4em';
        } else {
            elements.overlayMessage.style.fontSize = '2.4em';
        }
    },

    // Update this method to change only the message, not the visibility
    updateOverlayMessage: function (message) {
        const overlayMessage = document.getElementById('overlay-message');
        overlayMessage.innerHTML = message;

        // Adjust font size for longer messages
        if (message.length > 20) {
            overlayMessage.style.fontSize = '1.6em';
        } else {
            overlayMessage.style.fontSize = '2.4em';
        }
    },

    hideOverlay: function () {
        elements.overlay.classList.remove('show');
    },

    showINatDownDialog: function () {
        const loadingScreen = document.getElementById('loading-screen');
        if (loadingScreen) {
            loadingScreen.style.display = 'none';
        }

        dialogManager.openDialog('inat-down-dialog');

        const checkStatusBtn = document.getElementById('check-inat-status');
        const retryConnectionBtn = document.getElementById('retry-connection');

        const checkStatusHandler = () => {
            window.open('https://inaturalist.org', '_blank');
        };

        const retryConnectionHandler = async () => {
            dialogManager.closeDialog();
            if (await api.isINaturalistReachable()) {
                game.setupGame(true);
            } else {
                this.showINatDownDialog();
            }
        };

        checkStatusBtn.addEventListener('click', checkStatusHandler);
        retryConnectionBtn.addEventListener('click', retryConnectionHandler);
    },

    hideINatDownDialog: function () {
        dialogManager.closeDialog();
    },

    showTutorial: function () {
        const steps = [
            { message: "Welcome to DuoNat!<br>Let's learn how to play.", highlight: null, duration: 4000 },
            { message: "You'll see two images of different taxa.", highlights: ['#image-container-1', '#image-container-2'], duration: 5000 },
            { message: "Drag a name to the correct image.", highlight: '.name-pair', duration: 5000 },
            { message: "If correct, you'll move to the next round.", highlight: null, duration: 4000 },
            {
                message: "Swipe left on an image for a new taxon set.",
                highlight: null,
                action: () => { this.tiltGameContainer(3200); },
                duration: 6000
            },
            { message: "Get more info about a taxon.", highlights: ['#info-button-1', '#info-button-2'], duration: 6000 },
            { message: "Tap the menu for more functions.", highlight: '#menu-toggle', action: () => this.temporarilyOpenMenu(6000), duration: 6000 },
            { message: "Ready to start?<br>Let's go!", highlight: null, duration: 2000 }
        ];

        let currentStep = 0;
        let highlightElements = [];

        const showStep = () => {
            if (currentStep < steps.length) {
                const step = steps[currentStep];
                this.updateOverlayMessage(step.message);

                highlightElements.forEach(el => el.remove());
                highlightElements = [];

                if (step.highlight) {
                    const highlight = this.createHighlight(step.highlight);
                    if (highlight) highlightElements.push(highlight);
                } else if (step.highlights) {
                    step.highlights.forEach(selector => {
                        const highlight = this.createHighlight(selector);
                        if (highlight) highlightElements.push(highlight);
                    });
                }

                if (step.action) {
                    step.action();
                }

                currentStep++;
                setTimeout(showStep, step.duration); // Use the step's duration
            } else {
                this.hideOverlay();
                highlightElements.forEach(el => el.remove());
            }
        };

        // Close the help dialog before starting the tutorial
        document.getElementById('help-dialog').close();

        // Show the overlay at the start of the tutorial
        this.showOverlay("", config.overlayColors.green);

        // Start the tutorial
        showStep();
    },

    temporarilyOpenMenu: function (duration) {
        this.toggleMainMenu(); // Open the menu
        setTimeout(() => {
            this.closeMainMenu(); // Close the menu after the specified duration
        }, duration);
    },

    // for tutorial demo
    tiltGameContainer: function (duration = 3200) {
        const gameContainer = document.querySelector('.game-container');
        const midpoint = duration / 2;

        // Initial tilt
        gameContainer.style.transition = `transform ${midpoint}ms ease-out, opacity ${midpoint}ms ease-out`;
        gameContainer.style.transform = 'rotate(-3deg) translateX(-50px)';
        gameContainer.style.opacity = '0.7';

        // Return to original position
        setTimeout(() => {
            gameContainer.style.transition = `transform ${midpoint}ms ease-in, opacity ${midpoint}ms ease-in`;
            gameContainer.style.transform = '';
            gameContainer.style.opacity = '';
        }, midpoint);

        // Clean up
        setTimeout(() => {
            gameContainer.style.transition = '';
        }, duration);
    },

    createHighlight: function (targetSelector) {
        const target = document.querySelector(targetSelector);
        if (!target) {
            logger.error(`Target element not found: ${targetSelector}`);
            return null;
        }

        const highlight = document.createElement('div');
        highlight.className = 'tutorial-highlight';
        document.body.appendChild(highlight);

        const targetRect = target.getBoundingClientRect();
        highlight.style.width = `${targetRect.width}px`;
        highlight.style.height = `${targetRect.height}px`;
        highlight.style.top = `${targetRect.top}px`;
        highlight.style.left = `${targetRect.left}px`;

        return highlight;
    },

    toggleKeyboardShortcuts: function () {
        const keyboardShortcutsSection = document.getElementById('keyboard-shortcuts');
        if (utils.hasKeyboard()) {
            keyboardShortcutsSection.style.display = 'block';
        } else {
            keyboardShortcutsSection.style.display = 'none';
        }
    },

    initializeHelpDialog: function () {
        document.getElementById('help-button').addEventListener('click', () => {
            this.toggleKeyboardShortcuts();
            dialogManager.openDialog('help-dialog');
        });
    },

    initializeInfoDialog: function () {
        const infoDialog = document.getElementById('info-dialog');

        // Check if the device has a keyboard
        if (utils.hasKeyboard()) {
            document.body.classList.add('has-keyboard');
        }

        const handleKeyPress = (event) => {
            if (!infoDialog.open) return; // Only handle keypresses when the dialog is open

            event.stopPropagation();
            const key = event.key.toLowerCase();
            const buttonMap = {
                'p': 'photo-button',
                'h': 'hints-button',
                'o': 'observation-button',
                't': 'taxon-button',
                'w': 'wiki-button',
                'r': 'report-button'
            };

            if (buttonMap[key]) {
                event.preventDefault();
                document.getElementById(buttonMap[key]).click();
            } else if (key === 'escape') {
                event.preventDefault();
                infoDialog.close();
            }
        };

        document.addEventListener('keydown', handleKeyPress);
    },

    // main menu code:
    initializeMainMenu: function () {
        const menuToggle = document.getElementById('menu-toggle');
        if (menuToggle) {
            menuToggle.addEventListener('click', (event) => {
                //                logger.debug('Menu toggle button or its child clicked');
                event.stopPropagation();
                this.toggleMainMenu();
            });
        } else {
            logger.error('Menu toggle button not found');
        }

        window.addEventListener('resize', this.positionBottomGroup.bind(this));

        // Call once to set initial position
        this.positionBottomGroup();

        // Close the dropdown when clicking outside of it
        document.addEventListener('click', (event) => {
            if (!event.target.closest('.main-menu')) {
                this.closeMainMenu();
            }
        });
    },

    toggleMainMenu: function () {
        this.isMenuOpen = !this.isMenuOpen;

        const topGroup = document.querySelector('.main-menu__dropdown--top');
        const bottomGroup = document.querySelector('.main-menu__dropdown--bottom');

        if (topGroup && bottomGroup) {
            topGroup.classList.toggle('show');
            bottomGroup.classList.toggle('show');
            //            logger.debug("Show classes toggled");

            if (this.isMenuOpen) {
                this.positionBottomGroup();
            }
        } else {
            logger.error('Dropdown groups not found');
        }
    },

    positionBottomGroup: function () {
        const bottomGroup = document.querySelector('.main-menu__dropdown--bottom');
        const lowerImageContainer = document.querySelector('#image-container-2');

        if (bottomGroup && lowerImageContainer) {
            const rect = lowerImageContainer.getBoundingClientRect();
            bottomGroup.style.top = `${rect.top}px`;
            bottomGroup.style.right = `0px`; // Adjust if needed
        }
    },

    closeMainMenu: function () {
        if (this.isMenuOpen) {
            const topGroup = document.querySelector('.main-menu__dropdown--top');
            const bottomGroup = document.querySelector('.main-menu__dropdown--bottom');
            if (topGroup && bottomGroup) {
                this.isMenuOpen = false;
                topGroup.classList.remove('show');
                bottomGroup.classList.remove('show');
            }
        }
    },

    initialize: function () {
        this.initializeHelpDialog();
        this.initializeInfoDialog();
        this.initializeMainMenu();
        this.closeMainMenu(); // Ensure menu is closed on initialization
        // Close the dropdown when clicking outside of it
        document.addEventListener('click', (event) => {
            if (!event.target.closest('.main-menu')) {
                this.closeMainMenu();
            }
        });
    },

};

export default ui;




# code/utils.js

// Utility functions

import api from './api.js';
import game from './game.js';
import { gameState, updateGameState } from './state.js';
import logger from './logger.js';
import tagCloud from './tagCloud.js';

const utils = {

    // optionally get pair of taxa from URL
    getURLParameters: function () {
        const params = new URLSearchParams(window.location.search);
        const taxon1 = params.get('taxon1');
        const taxon2 = params.get('taxon2');
        const tags = params.get('tags');

        return { taxon1, taxon2, tags };
    },

    debounce: function (func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const context = this;
            const later = () => {
                clearTimeout(timeout);
                func.apply(context, args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    },

    // trying out things button
    surprise: function () {
        logger.debug("Surprise!");
        //        game.showTaxaRelationship();
        //this.fart();
        this.randomAnimalSound();
    },

    randomAnimalSound: async function () {
        try {
            // Fetch random observations with sounds
            const url = "https://api.inaturalist.org/v1/observations?order_by=random&sounds=true";
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error('Failed to fetch observations');
            }
            const data = await response.json();

            // Filter observations with sounds
            const observationsWithSounds = data.results.filter(obs => obs.sounds && obs.sounds.length > 0);

            if (observationsWithSounds.length > 0) {
                // Choose a random observation
                const randomObservation = observationsWithSounds[Math.floor(Math.random() * observationsWithSounds.length)];

                // Extract the sound URL
                const soundUrl = randomObservation.sounds[0].file_url;

                if (soundUrl) {
                    // Create and play the audio
                    const audio = new Audio(soundUrl);
                    await audio.play();
                    logger.info(`Playing sound from observation: ${randomObservation.species_guess || 'Unknown species'}`);
                } else {
                    logger.warn("Sound URL not found in the selected observation.");
                }
            } else {
                logger.warn("No observations with sounds found.");
            }
        } catch (error) {
            logger.error('Could not play animal sound:', error);
        }
    },

    fart: function () {
        // placeholder
        const soundUrl = './sound/fart.mp3';
        // Create a new Audio object

        const audio = new Audio(soundUrl);
        audio.play({ playbackMode: 'background' })
            .then(() => { logger.info("Everybody plays their fart."); /* Audio started playing successfully*/ }).catch(error => { logger.error('Could not play my fart:', error); });
    },

    hasKeyboard: function () {
        // Check if the device is mobile
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // Check if it's a tablet
        const isTablet = /(tablet|ipad|playbook|silk)|(android(?!.*mobile))/i.test(navigator.userAgent);

        // If it's not mobile and not a tablet, assume it has a keyboard
        const result = !isMobile && !isTablet;

        //        logger.debug(`hasKeyboard detected: ${result}`);
        //        logger.debug(`UserAgent: ${navigator.userAgent}`);

        return result;
    },

    debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    },

    sleep: function (ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    },

    resetDraggables: function () {
        const leftNameContainer = document.getElementsByClassName('name-pair__container--left')[0];
        const rightNameContainer = document.getElementsByClassName('name-pair__container--right')[0];
        const dropOne = document.getElementById('drop-1');
        const dropTwo = document.getElementById('drop-2');

        // Move draggables back to the names container
        leftNameContainer.appendChild(document.getElementById('left-name'));
        rightNameContainer.appendChild(document.getElementById('right-name'));

        // Clear drop zones
        dropOne.innerHTML = ''; dropTwo.innerHTML = '';
    },

    capitalizeFirstLetter: function (string) {
        if (!string) {
            return '';
        } else { return string.charAt(0).toUpperCase() + string.slice(1); }
    },

    shortenSpeciesName: function (string) {
        if (!string) { return ''; }

        let parts = string.split(' ');
        if (parts.length < 2) {
            return string; // Return the original string if it doesn't contain at least two parts
        }

        let genusInitial = parts[0].charAt(0).toUpperCase() + '.';
        let species = parts.slice(1).join(' '); // Join the remaining parts in case the species name has multiple words

        return genusInitial + ' ' + species;
    },

    // Returns a taxon pair from the index, or a random one if none indicated
    selectTaxonPair: async function (index = null) {
        const taxonPairs = await api.fetchTaxonPairs();
        if (taxonPairs.length === 0) {
            logger.error("No taxon pairs available");
            return null;
        }

        let filteredPairs = taxonPairs;

        if (gameState.selectedTags.length > 0) {
            filteredPairs = taxonPairs.filter(pair =>
                pair.tags.some(tag => gameState.selectedTags.includes(tag))
            );
        }

        if (filteredPairs.length === 0) {
            logger.warn("No pairs match the selected tags. Using all pairs.");
            filteredPairs = taxonPairs;
        }

        return index !== null ? filteredPairs[index] : filteredPairs[Math.floor(Math.random() * filteredPairs.length)];
    },

}; // const utils

export default utils;



# code/dialogManager.js

import api from './api.js';
import eventHandlers from './eventHandlers.js';
import game from './game.js';
import logger from './logger.js';
import ui from './ui.js';

const dialogManager = {
    activeDialog: null,
    mainEventHandlers: {},
    eventListeners: {},
    openDialogs: new Set(),

    openDialog(dialogId) {
        const dialog = document.getElementById(dialogId);
        if (dialog && dialog.tagName.toLowerCase() === 'dialog') {
            dialog.showModal();
            this.openDialogs.add(dialogId);
            this.activeDialog = dialog;

            // Add event listener to handle keyboard events
            dialog.addEventListener('keydown', this.handleDialogKeydown);
        }
    },

    closeDialog(dialogId) {
        const dialog = document.getElementById(dialogId);
        if (dialog && dialog.tagName.toLowerCase() === 'dialog') {
            dialog.close();
            this.openDialogs.delete(dialogId);
            this.activeDialog = null;

            // Remove event listener
            dialog.removeEventListener('keydown', this.handleDialogKeydown);
        }
    },

    isAnyDialogOpen() {
        return this.openDialogs.size > 0;
    },
    /*
    isAnyDialogOpen() {
        return !!this.activeDialog;
    },
*/
    handleDialogKeydown(event) {
        // Allow default behavior for input fields
        if (event.target.tagName.toLowerCase() === 'input') {
            return;
        }

        // Prevent propagation for other elements
        event.stopPropagation();
    },

    closeAllDialogs() {
        this.openDialogs.forEach(dialogId => this.closeDialog(dialogId));
    },

    /*
        openDialog(dialogId) {
            ui.closeMainMenu();
            const dialog = document.getElementById(dialogId);
            if (!dialog) {
                console.error(`Dialog with id ${dialogId} not found`);
                return;
            }
    
            this.disableMainEventHandlers();
    
            if (dialog instanceof HTMLElement) {
                if (dialog.tagName.toLowerCase() === 'dialog') {
                    dialog.showModal();
                } else {
                    dialog.classList.remove('hidden');
                    if (dialogId === 'phylogeny-dialog') {
                        dialog.style.display = 'flex';
                    }
                }
            }
            this.activeDialog = dialog;
    
            document.addEventListener('keydown', this.handleEscapeKey.bind(this));
            if (dialog instanceof HTMLElement) {
                dialog.addEventListener('close', () => this.handleDialogClose(dialog));
                const closeButton = dialog.querySelector('.dialog-close-button');
                if (closeButton) {
                    closeButton.addEventListener('click', () => this.closeDialog());
                }
            }
        },
    
        closeDialog() {
            if (this.activeDialog) {
                const dialog = this.activeDialog;
                this.activeDialog = null;
    
                if (dialog instanceof HTMLElement) {
                    if (dialog.tagName.toLowerCase() === 'dialog') {
                        dialog.close();
                    } else {
                        dialog.classList.add('hidden');
                    }
    
                    if (dialog.id === 'phylogeny-dialog') {
                        dialog.style.display = 'none';
                    }
                }
                this.handleDialogClose(dialog);
                
                this.emit('dialogClose', dialog.id);
            }
        },
    */
    handleDialogClose(dialog) {
        if (!dialog) {
            logger.warn('handleDialogClose called with no dialog');
            return;
        }

        this.enableMainEventHandlers();

        document.removeEventListener('keydown', this.handleEscapeKey);

        if (dialog instanceof HTMLElement) {
            const closeButton = dialog.querySelector('.dialog-close-button');
            if (closeButton) {
                closeButton.removeEventListener('click', this.closeDialog);
            }
        }

        // Ensure main event handlers are re-enabled
        this.enableMainEventHandlers();

        this.activeDialog = null;

        ui.resetUIState();
    },

    on(eventName, callback) {
        if (!this.eventListeners[eventName]) {
            this.eventListeners[eventName] = [];
        }
        this.eventListeners[eventName].push(callback);
    },

    off(eventName, callback) {
        if (this.eventListeners[eventName]) {
            this.eventListeners[eventName] = this.eventListeners[eventName].filter(
                listener => listener !== callback
            );
        }
    },

    emit(eventName, data) {
        if (this.eventListeners[eventName]) {
            this.eventListeners[eventName].forEach(callback => callback(data));
        } else {
            logger.debug(`No listeners for event: ${eventName}`);
        }
    },

    handleDialogClose(dialog) {
        if (!dialog) {
            logger.warn('handleDialogClose called with no dialog');
            return;
        }

        // Re-enable main window event handlers
        this.enableMainEventHandlers();

        // Remove event listener
        document.removeEventListener('keydown', this.handleEscapeKey);

        // Remove close button event listener if dialog is an HTMLElement
        if (dialog instanceof HTMLElement) {
            const closeButton = dialog.querySelector('.dialog-close-button');
            if (closeButton) {
                closeButton.removeEventListener('click', this.closeDialog);
            }
        }

        // Ensure main event handlers are re-enabled
        this.enableMainEventHandlers();

        // Ensure the UI knows no dialog is open
        this.activeDialog = null;

        // Reset the UI state
        ui.resetUIState();
    },

    handleEscapeKey(event) {
        if (event.key === 'Escape' && this.activeDialog) {
            this.closeDialog();
        }
    },

    disableMainEventHandlers() {
        // Store and disable main window event handlers
        const mainElements = ['#random-pair-button', '#select-pair-button', '#enter-pair-button', '#share-button', '#help-button'];
        mainElements.forEach(selector => {
            const element = document.querySelector(selector);
            if (element) {
                this.mainEventHandlers[selector] = element.onclick;
                element.onclick = null;
            }
        });

        // Disable keyboard shortcuts
        document.removeEventListener('keydown', eventHandlers.handleKeyboardShortcuts);
    },

    enableMainEventHandlers() {
        // Re-enable main window event handlers
        Object.entries(this.mainEventHandlers).forEach(([selector, handler]) => {
            const element = document.querySelector(selector);
            if (element) {
                element.onclick = handler;
            }
        });

        // Re-enable keyboard shortcuts
        document.addEventListener('keydown', eventHandlers.handleKeyboardShortcuts);

        this.mainEventHandlers = {};
    },

    initializeDialogs() {
        const dialogs = ['select-pair-dialog', 'enter-pair-dialog', 'help-dialog', 'info-dialog', 'phylogeny-dialog', 'inat-down-dialog'];

        dialogs.forEach(dialogId => {
            const dialog = document.getElementById(dialogId);
            const closeButton = dialog.querySelector('.dialog-close-button');
            if (closeButton) {
                closeButton.addEventListener('click', () => this.closeDialog());
            }
        });

        // Initialize enter pair dialog elements
        this.enterPairDialog = document.getElementById('enter-pair-dialog');
        this.taxon1Input = document.getElementById('taxon1');
        this.taxon2Input = document.getElementById('taxon2');
        this.dialogMessage = document.getElementById('dialog-message');
        this.submitButton = document.getElementById('submit-dialog');

        // Add event listeners for enter pair dialog
        document.getElementById('enter-pair-button').addEventListener('click', () => this.openDialog('enter-pair-dialog'));
        document.querySelector('#enter-pair-dialog form').addEventListener('submit', this.handleNewPairSubmit.bind(this));

        this.on('dialogClose', (dialogId) => {
            // Add any specific actions you want to perform when a dialog is closed
        });

        // input validation
        this.taxon1Input.addEventListener('input', () => this.validateInputs());
        this.taxon2Input.addEventListener('input', () => this.validateInputs());
    },

    validateInputs() {
        const isValid = this.taxon1Input.value.trim() !== '' && this.taxon2Input.value.trim() !== '';
        this.submitButton.disabled = !isValid;
    },

    clearEnterPairInputs() {
        const taxon1Input = document.getElementById('taxon1');
        const taxon2Input = document.getElementById('taxon2');
        const dialogMessage = document.getElementById('dialog-message');
        taxon1Input.value = '';
        taxon2Input.value = '';
        dialogMessage.textContent = '';
        this.validateInputs();
    },

    async handleNewPairSubmit(event) {
        event.preventDefault();

        const taxon1 = this.taxon1Input.value.trim();
        const taxon2 = this.taxon2Input.value.trim();

        if (!taxon1 || !taxon2) {
            this.dialogMessage.textContent = 'Please enter both taxa.';
            return;
        }

        this.dialogMessage.textContent = 'Validating taxa...';
        this.submitButton.disabled = true;
        this.addLoadingSpinner();

        try {
            const [validatedTaxon1, validatedTaxon2] = await Promise.all([
                api.validateTaxon(taxon1),
                api.validateTaxon(taxon2)
            ]);

            if (validatedTaxon1 && validatedTaxon2) {
                const newPair = {
                    taxon1: validatedTaxon1.name,
                    taxon2: validatedTaxon2.name
                };

                this.dialogMessage.textContent = 'Saving new pair...';

                try {
                    const response = await fetch('./data/taxonPairs.json');
                    const taxonPairs = await response.json();
                    taxonPairs.push(newPair);

                    game.nextSelectedPair = newPair;
                    this.closeDialog();
                    game.setupGame(true);
                } catch (error) {
                    logger.error('Error updating taxonPairs.json:', error);
                    this.dialogMessage.textContent = 'Error saving new pair. Please try again.';
                }
            } else {
                this.dialogMessage.textContent = 'One or both taxa are invalid. Please check and try again.';
            }
        } catch (error) {
            logger.error('Error validating taxa:', error);
            this.dialogMessage.textContent = 'Error validating taxa. Please try again.';
        } finally {
            this.submitButton.disabled = false;
            this.removeLoadingSpinner();
        }
    },

    addLoadingSpinner() {
        const spinner = document.createElement('div');
        spinner.className = 'loading-spinner';
        this.dialogMessage.appendChild(spinner);
    },

    removeLoadingSpinner() {
        const spinner = this.dialogMessage.querySelector('.loading-spinner');
        if (spinner) {
            spinner.remove();
        }
    },

};

export default dialogManager;



# manifest.json

{
  "name": "DuoNat - iNaturalist Taxon Trainer",
  "short_name": "DuoNat",
  "start_url": "./",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#74ac00",
  "icons": [
    {
      "src": "images/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "images/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}



# code/api.js

// iNat API

import logger from './logger.js';
import utils from './utils.js';

let taxonInfo = null;
let ancestryInfo = null;

const handleApiError = (error, context) => {
    logger.error(`API Error in ${context}:`, error);
    throw new Error(`Error in ${context}: ${error.message}`);
};

const api = (() => {
    return {

        loadTaxonInfo: async function () {
            try {
                if (taxonInfo === null) {
                    const response = await fetch('./data/taxonInfo.json');
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    taxonInfo = await response.json();
                }
                return taxonInfo;
            } catch (error) {
                handleApiError(error, 'loadTaxonInfo');
            }
        },

        /*     getVernacularName: async function(taxonName) {
                 try {
                     const taxonInfo = await this.loadTaxonInfo();
                     const taxonData = Object.values(taxonInfo).find(info => info.taxonName.toLowerCase() === taxonName.toLowerCase());
                     return taxonData ? utils.capitalizeFirstLetter(taxonData.vernacularName) : '';
                 } catch (error) {
                     handleApiError(error, 'getVernacularName');
                 }
             },
     */
        // fetch from JSON file
        fetchTaxonPairs: async function () {
            try {
                const response = await fetch('./data/taxonSets.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const taxonSets = await response.json();
                // Convert the new format to an expanded version of the old format
                return taxonSets.map(set => ({
                    taxon1: set.taxonNames[0],
                    taxon2: set.taxonNames[1],
                    setName: set.setName,
                    tags: set.tags,
                    setID: set.setID
                }));
            } catch (error) {
                handleApiError(error, 'fetchTaxonPairs');
            }
        },

        // for user input of new taxon pairs
        validateTaxon: async function (taxonName) {
            try {
                const response = await fetch(`https://api.inaturalist.org/v1/taxa/autocomplete?q=${encodeURIComponent(taxonName)}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                return data.results.length > 0 ? data.results[0] : null;
            } catch (error) {
                handleApiError(error, 'validateTaxon');
            }
        },

        fetchRandomImage: async function (taxonName) {
            try {
                const images = await this.fetchMultipleImages(taxonName, 12);
                if (images.length === 0) {
                    throw new Error(`No images found for ${taxonName}`);
                }
                const randomIndex = Math.floor(Math.random() * images.length);
                const result = images[randomIndex];
                logger.debug(`Fetched random image for ${taxonName}: ${result}`);
                return result;
            } catch (error) {
                handleApiError(error, 'fetchRandomImage');
            }
        },

        fetchImageMetadata: async function (taxonName, count = 12) {
            //            logger.debug(`Fetching metadata for ${count} images of ${taxonName}`);
            try {
                const searchResponse = await fetch(`https://api.inaturalist.org/v1/taxa/autocomplete?q=${taxonName}`);
                const searchData = await searchResponse.json();
                if (searchData.results.length === 0) { throw new Error('Taxon not found'); }
                const taxonId = searchData.results[0].id;

                const taxonResponse = await fetch(`https://api.inaturalist.org/v1/taxa/${taxonId}`);
                const taxonData = await taxonResponse.json();
                if (taxonData.results.length === 0) { throw new Error('No details found for the taxon'); }
                const taxon = taxonData.results[0];

                let images = taxon.taxon_photos.map(photo => photo.photo.url.replace('square', 'medium'));

                const result = images.slice(0, Math.min(count, images.length));
                //                logger.debug(`Fetched metadata for ${result.length} images of ${taxonName}`);
                return result;
            } catch (error) {
                logger.error(`Error fetching image metadata for ${taxonName}:`, error);
                return [];
            }
        },

        fetchRandomImageMetadata: async function (taxonName) {
            //            logger.debug(`Fetching random image metadata for ${taxonName}`);
            const images = await this.fetchImageMetadata(taxonName, 12); // Fetch metadata for 12 images
            if (images.length === 0) {
                logger.error(`No image metadata found for ${taxonName}`);
                return null;
            }
            const randomIndex = Math.floor(Math.random() * images.length);
            const result = images[randomIndex];
            //            logger.debug(`Selected random image metadata for ${taxonName}: ${result}`);
            return result;
        },

        async fetchMultipleImages(taxonName, count = 12) {
            try {
                const searchResponse = await fetch(`https://api.inaturalist.org/v1/taxa/autocomplete?q=${taxonName}`);
                if (!searchResponse.ok) throw new Error(`HTTP error! status: ${searchResponse.status}`);
                const searchData = await searchResponse.json();
                if (searchData.results.length === 0) throw new Error('Taxon not found');
                const taxonId = searchData.results[0].id;

                const taxonResponse = await fetch(`https://api.inaturalist.org/v1/taxa/${taxonId}?photos=true`);
                if (!taxonResponse.ok) throw new Error(`HTTP error! status: ${taxonResponse.status}`);
                const taxonData = await taxonResponse.json();
                if (taxonData.results.length === 0) throw new Error('No details found for the taxon');
                const taxon = taxonData.results[0];

                let images = taxon.taxon_photos.map(photo => photo.photo.url.replace('square', 'medium'));

                images = [...new Set(images)];
                images = images.sort(() => Math.random() - 0.5);

                return images.slice(0, Math.min(count, images.length));

            } catch (error) {
                handleApiError(error, 'fetchMultipleImages');
            }
        },

        // fetch vernacular name of taxon from local file or iNat
        fetchVernacular: async function (taxonName) {
            const taxonInfo = await this.loadTaxonInfo();

            // Find the entry with matching taxonName
            const entry = Object.values(taxonInfo).find(info => info.taxonName.toLowerCase() === taxonName.toLowerCase());

            if (entry) {
                // Return the vernacularName even if it's an empty string
                return entry.vernacularName;
            } else {
                logger.warn(`Taxon not found in local data: ${taxonName}`);
                // Only fetch from API if the taxon is not in our local data at all
                return this.fetchVernacularFromAPI(taxonName);
            }
        },

        fetchVernacularFromAPI: async function (taxonName) {
            logger.debug("Fetching vernacular from iNat API for: " + taxonName);
            try {
                const baseUrl = 'https://api.inaturalist.org/v1/taxa/autocomplete';
                const response = await fetch(`${baseUrl}?q=${encodeURIComponent(taxonName)}`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                if (data.results && data.results.length > 0) {
                    const taxon = data.results[0];
                    return taxon.preferred_common_name || "";
                } else {
                    return "";
                }
            } catch (error) {
                handleApiError(error, 'fetchVernacularFromAPI');
                return "";
            }
        },

        // function to check if iNaturalist API is reachable
        isINaturalistReachable: async function () {
            try {
                const response = await fetch('https://api.inaturalist.org/v1/taxa?q=test');
                return response.ok;
            } catch (error) {
                logger.error('Error pinging iNaturalist API:', error);
                return false;
            }
        },

        fetchTaxonId: async function (taxonName) {
            try {
                logger.debug(`Fetching taxon ID for ${taxonName}`);
                const response = await fetch(`https://api.inaturalist.org/v1/taxa/autocomplete?q=${encodeURIComponent(taxonName)}&per_page=1`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                if (data.results.length === 0) throw new Error(`Taxon not found: ${taxonName}`);
                logger.debug(`Taxon ID for ${taxonName}:`, data.results[0].id);
                return data.results[0].id;
            } catch (error) {
                handleApiError(error, 'fetchTaxonId');
            }
        },

        fetchTaxonDetails: async function (name) {
            try {
                const response = await fetch(`https://api.inaturalist.org/v1/taxa/autocomplete?q=${encodeURIComponent(name)}&per_page=1&all_names=true`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                if (data.results.length === 0) throw new Error(`Taxon not found: ${name}`);
                logger.debug('Fetched taxon details:', data.results[0]);
                return data.results[0];
            } catch (error) {
                handleApiError(error, 'fetchTaxonDetails');
            }
        },

        loadAncestryInfo: async function () {
            try {
                if (ancestryInfo === null) {
                    const response = await fetch('./data/ancestryInfo.json');
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    ancestryInfo = await response.json();
                }
                return ancestryInfo;
            } catch (error) {
                handleApiError(error, 'loadAncestryInfo');
            }
        },

        async getAncestryFromLocalData(taxonName) {
            const taxonInfo = await this.loadTaxonInfo();
            const taxonData = Object.values(taxonInfo).find(info => info.taxonName.toLowerCase() === taxonName.toLowerCase());
            return taxonData ? taxonData.ancestryIds.map(id => parseInt(id)) : [];
        },

        fetchAncestorDetails: async function (ancestorIds) {
            try {
                const ancestorDetails = new Map();
                const localAncestryInfo = await this.loadAncestryInfo();

                for (const id of ancestorIds) {
                    const localData = localAncestryInfo[id];
                    if (localData) {
                        ancestorDetails.set(id, {
                            id: parseInt(id),
                            name: localData.taxonName,
                            rank: localData.rank,
                            preferred_common_name: localData.vernacularName
                        });
                        logger.debug(`Using local ancestry data for ID ${id}:`, localData);
                    } else {
                        const response = await fetch(`https://api.inaturalist.org/v1/taxa/${id}`);
                        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                        const data = await response.json();
                        if (data.results.length > 0) {
                            ancestorDetails.set(id, data.results[0]);
                            logger.debug(`Fetched ancestry data from iNat for ID ${id}:`, data.results[0]);
                        }
                    }
                }
                return ancestorDetails;
            } catch (error) {
                handleApiError(error, 'fetchAncestorDetails');
            }
        },

    };

})();

export default api;



# code/config.js

// Configuration

const config = {

    // overlay colors
    overlayColors: {
        green: "rgba(116, 172, 0, 1.0)", /* iNat green */
        red: "rgba(172, 0, 40, 1.0)",
        gray: "rgba(100, 100, 100, 0.8)"
    },
    debug: true, // set to false for less console output
    enablePreloading: false // Set to false to disable preloading
};

export default config;



# styles/base.css

/* Mostly styles for main page */

/* CSS reset */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

/* Custom properties */
:root {
    --primary-color: #74ac00; /* iNat green rgb(116, 172, 0) */
    --primary-counter-color: #ac0028; /* red rgb(172, 0, 40) */
    --light-green: rgba(116, 172, 0, 0.1);
    --dark-neutral-color: #444;
    --background-color: #ffffff;
    --text-color: #ffffff;
    --counter-text-color: #444;
    --shadow-color: rgba(0, 0, 0, 0.1);
    --overlay-color: rgba(0, 0, 0, 0.3);

    --normal-font-size: 18px;
    --border-radius: 8px;
    --max-image-width: 500px;
    --transition-speed: 0.3s;
    /* images wobble when <80px */
    --center-min-height: 80px; /* consider relative to screen */
}

body {
    display: flex;
    flex-direction: column;
    height: 100vh;
    margin: 0;
    padding: 0;
    overflow: auto;
    box-sizing: border-box;
    font-family: 'Open Sans', Arial, sans-serif;
    background-color: var(--light-green);
}

body * {
    text-align: center;
} /* percolate to child elements */

/* Other general styles */

button {
    outline: none;
    box-shadow: none;
    -webkit-tap-highlight-color: transparent;
}

/* remove black border when active */
.no-outline {
    outline: none;
    box-shadow: none;
    -webkit-tap-highlight-color: transparent;
}

.game-container {
    flex: none;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    height: 100vh;
    padding: 0;
    overflow: hidden;
    box-sizing: border-box;
    transition: transform 0.1s ease-out, opacity 0.1s ease-out;
}

.underline {
    text-decoration: underline;
}

/* Styles common to all main containers */
.image-container,
.name-pair,
#overlay {
    width: 98vw;
    max-width: var(--max-image-width);
}

/* Animation keyframes etc. */
@keyframes dropAnimation {
    0% {
        transform: scale(1.1);
    }
    100% {
        transform: scale(1);
    }
}

.drop-animation {
    animation: dropAnimation 0.3s ease-out forwards;
}

@keyframes swipeOutLeft {
    to {
        transform: rotate(-5deg) translateX(-100%);
        opacity: 0;
    }
}

.swipe-out-left {
    animation: swipeOutLeft 0.5s ease-out forwards;
}

.swipe-info-message {
    position: absolute;
    top: 40px;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(255, 255, 255, 0.8);
    color: var(--dark-neutral-color);
    height: fit-content;
    width: auto;
    max-width: 80%;
    padding: 6px 15px;
    border-radius: 15px;
    font-size: larger;
    white-space: nowrap;
    opacity: 0;
    transition: opacity 0.3s, transform 0.3s;
    pointer-events: none;
    z-index: 1000;
}




# styles/components.css





# styles/main.css

@import 'base.css';
@import 'components/loading.css';
@import 'components/menu.css';
@import 'components/buttons.css';
@import 'components/dialogs.css';

@import 'layout/image-container.css';
@import 'layout/name-pair.css';

@import 'components/tooltips.css';

/*
@import 'components/forms.css';
@import 'components/icons.css';
*/



# styles/components/buttons.css

/* For icons in general */
.icon {
  width: 24px;
  height: 24px;
  fill: var(--dark-neutral-color);
  transition: transform 0.2s ease, fill 0.2s ease;
}

.icon:hover, .icon-button:hover {
  transform: scale(1.1);
}

.icon:active, .icon-button:active {
  transform: scale(0.95);
}

/* For buttons containing icons */
.icon-button {
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: rgba(255, 255, 255, 0.6);
  border: none;
  border-radius: 50%;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  cursor: pointer;
  width: 40px;
  height: 40px;
  transition: background-color var(--transition-speed) ease, transform 0.2s ease;
}

.icon-button:hover {
  background: rgba(255, 255, 255, 0.8);
}


#help-button {
    position: fixed;
    top: 10px;
    right: 60px;
    z-index: 1000;
}

#like-button {
    fill: var(--primary-color);
}
#trash-button {
    fill: var(--primary-counter-color);
}

/* Styles for image button containers */

.image-container__buttons {
    position: absolute;
    left: 10px;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
}

#image-buttons-1,
#image-buttons-2 {
    bottom: 10px;
}

.image-container__button {
    margin-bottom: 10px;
    width: 36px;
    height: 36px;
}

/* Responsive adjustments */
@media (max-width: 480px) {
    .image-container__button {
        width: 32px;
        height: 32px;
    }

    .image-container__button-icon {
        width: 20px;
        height: 20px;
    }
}




# styles/components/dialogs.css

/* Generic dialog style */

dialog {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  margin: 0;
}

.standard-dialog {
    background-color: white;
    border-radius: 12px;
    border: none;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    width: 95%;
    max-width: 500px;
    max-height: 95vh;
    padding: 40px 20px 20px;
z-index: 5000; /* debug */
}

.dialog-title {
    color: var(--primary-counter-color);
    text-align: center;
    margin: 0 0 20px 0;
    font-size: 1.5em;
}

.dialog-close-button {
    position: absolute;
    top: 10px;
    right: 10px;
    background: none;
    font-size: 2em;
    color: var(--primary-counter-color);                
    outline: none;
    border: none;
    box-shadow: none;
    -webkit-tap-highlight-color: transparent; /* Removes tap highlight on iOS */
    cursor: pointer;
    padding: 5px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.3s ease;
    border-radius: 50%;
    z-index: 10;
}

/*.dialog-close-button:focus-visible {
    background-color: rgba(0, 0, 0, 0.1);
    box-shadow: 0 0 0 2px var(--primary-counter-color);
}*/

/* Hover styles */
.dialog-close-button:hover {
    background-color: rgba(0, 0, 0, 0.1);
}

/* Active styles */
.dialog-close-button:active {
    background-color: rgba(0, 0, 0, 0.2);
}

.dialog-close-button svg {
    stroke: var(--primary-counter-color);
}

/* Styles for button column on left main screen */

/* Styles for enter pair dialog */
#enter-pair-dialog {
    position: relative;
    border-radius: var(--border-radius);
    border: none;
    box-shadow: 0 0 10px var(--shadow-color);
    padding: 40px 20px 20px;
    max-width: 400px;
    width: 80%;
}
#enter-pair-dialog form {
    display: flex;
    flex-direction: column;
    gap: 15px;
}
#enter-pair-dialog label {
    display: inline-block;
    width: 80px;
    text-align: right;
    margin-right: 10px;
    font-weight: bold;
    font-size: 1.2em; /*var(--normal-font-size);*/
    color: var(--counter-text-color);
}
#enter-pair-dialog input {
    width: calc(100% - 90px);
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: var(--normal-font-size);
    color: var(--counter-text-color);
}
#enter-pair-dialog #submit-dialog {
    background-color: var(--primary-color);
    color: var(--text-color);
    border: none;
    padding: 10px 15px;
    border-radius: var(--border-radius);
    cursor: pointer;
    font-size: var(--normal-font-size);
    font-weight: bold;
    transition: background-color var(--transition-speed) ease;
}
#enter-pair-dialog button:hover {
    background-color: #5c8a00;
}

#dialog-message {
    color: var(--counter-text-color);
    font-style: italic;
    margin-top: 10px;
}
.dialog-buttons {
    display: flex;
    justify-content: space-between;
    margin-top: 20px;
}

/* Styles for select taxon pair list dialog */
#select-pair-dialog {
    width: 95%;
    max-width: var(--max-image-width);
    height: 90vh;
    max-height: 90vh;
    padding: 10px;
}

#select-pair-dialog .dialog-inner {
    display: flex;
    flex-direction: column;
    height: 100%;
    max-height: calc(90vh - 40px); /* Adjust for dialog padding */
}

.dialog-title {
    flex-shrink: 0;
    margin-bottom: 15px;
}

.taxon-pair-list {
    flex-grow: 1;
    width: 100%;
    max-height: calc(80vh - 150px);
    overflow-y: auto;
    overflow-x: hidden; /* Prevent horizontal scrolling */
    padding-bottom: 10px; /* This creates the gap at the bottom */
    margin-bottom: 0;
}

/* Adjust the scrollable area to leave space at the bottom */
#select-pair-dialog .taxon-pair-list {
    max-height: calc(90vh - 140px); /* Adjust this value as needed */
    padding-right: 5px; /* Add some padding for the scrollbar */
}

/* Style for webkit browsers */
#select-pair-dialog .taxon-pair-list::-webkit-scrollbar {
    width: 6px;
}

#select-pair-dialog .taxon-pair-list::-webkit-scrollbar-thumb {
    background-color: rgba(0,0,0,0.2);
    border-radius: 3px;
}

/* Style for Firefox */
#select-pair-dialog .taxon-pair-list {
    scrollbar-width: thin;
    scrollbar-color: rgba(0,0,0,0.2) transparent;
}

.taxon-set-button {
    display: block;
    width: 100%;
    padding: 5px;
    margin: 2px 0;
    background-color: rgba(116, 172, 0, 0.3); /* Light green background */
    border: none;
    border-radius: 10px;
    cursor: pointer;
    transition: background-color 0.3s ease;
    box-sizing: border-box; /* Include padding in width calculation */
}

.taxon-set-button:focus {
    outline: none;
    background-color: rgba(116, 172, 0, 0.5);
    box-shadow: 0 0 0 2px var(--primary-color);
}

.taxon-set-button:focus .taxon-item {
    background-color: #5c8a00;
}

.taxon-set-button--selected {
    background-color: rgba(116, 172, 0, 0.5); /* Darker green background */
    box-shadow: 0 0 0 2px var(--primary-color); /* Green outline */
}

.taxon-set-button--selected .taxon-item {
    background-color: #5c8a00; /* Darker green for the taxon items */
}

.taxon-set-button--selected:hover {
    background-color: rgba(116, 172, 0, 0.6); /* Even darker on hover */
}

.taxon-set-container {
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    align-items: stretch;
    gap: 5px; /* Small gap between the two "buttons" */
    width: 100%;
}

.set-name {
    font-size: 1.2em;
    font-weight: bold;
}

.tags {
    font-size: 1em;
    color: #666;
}

.taxon-item {
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 10px;
    background-color: var(--primary-color);
    color: var(--text-color);
    border-radius: 5px;
}

.taxon-set-button:hover .taxon-item {
    background-color: #5c8a00;
}

.taxon-name {
    font-style: italic;
    font-weight: bold;
    font-size: 1.3em;
    margin-bottom: 3px;
    text-align: center;
}

.vernacular-name {
    font-size: 1.2em;
    color: rgba(255, 255, 255, 0.8);
    text-align: center;
}

.taxon-pair-content {
    background-color: white;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    width: 90%;
    max-width: 500px;
    max-height: 80vh;
    position: relative;
    display: flex;
    flex-direction: column;
    padding: 40px 20px 20px;
}

.taxon-pair-title {
    color: var(--primary-color);
    text-align: center;
    margin: 0 0 20px 0;
    font-size: 1.5em;
}

.taxon-pair-modal {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}

.select-tags-button {
    background-color: var(--primary-color);
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: var(--border-radius);
    cursor: pointer;
    margin-bottom: 10px;
    font-size: 16px;
}

.select-tags-button:hover {
    background-color: #5c8a00;
}

.search-container {
  position: relative;
  margin-bottom: 15px;
  flex-shrink: 0;
}

#taxon-search {
  width: 100%;
  padding: 10px 15px;
  padding-left: 40px;
  border: 1px solid #ddd;
  border-radius: var(--border-radius);
  font-size: 16px;
  transition: border-color 0.3s ease;
}

#taxon-search:focus {
  outline: none;
  border-color: var(--primary-color);
}

.search-icon {
  position: absolute;
  left: 12px;
  top: 50%;
  transform: translateY(-50%);
  width: 20px;
  height: 20px;
  color: #888;
}

#clear-search {
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  cursor: pointer;
  padding: 0;
  width: 20px;
  height: 20px;
  color: #888;
  display: none;
}

#clear-search:hover {
  color: var(--primary-color);
}

/* Active tags functionality */
.active-tags-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    display: none; /* Initially hidden */
}

.active-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
}

.active-tag {
    background-color: var(--primary-color);
    color: white;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 0.9em;
}

.clear-all-tags {
    background-color: var(--primary-counter-color);
    color: white;
    border: none;
    padding: 5px 10px;
    border-radius: var(--border-radius);
    cursor: pointer;
    font-size: 0.9em;
}

.clear-all-tags:hover {
    background-color: #8a0020;
}

/* Tag cloud dialog */

#tag-cloud-dialog {
    width: 95%;
    max-width: var(--max-image-width);
    height: 90vh;
    display: none; /* Hide the dialog by default */
}

#tag-cloud-dialog[open] {
    display: flex;
    flex-direction: column;
}

#tag-cloud-container {
    flex-grow: 1;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    padding: 20px;
    overflow-y: auto;
}

.tag-cloud-item {
    margin: 5px;
    padding: 5px 10px;
    background-color: #f0f0f0;
    border-radius: 15px;
    cursor: pointer;
    transition: background-color 0.3s, color 0.3s;
}

.tag-cloud-item.active {
    background-color: var(--primary-color);
    color: white;
}

.done-button {
    background-color: var(--primary-color);
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: var(--border-radius);
    cursor: pointer;
    margin-top: 10px;
    font-size: 16px;
}

.done-button:hover {
    background-color: #5c8a00;
}

/* Help dialog */

#help-dialog {
    position: relative;
    padding: 40px 24px 24px;
    padding: 24px;
    border-radius: 12px;
    border: none;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    max-width: 400px;
    width: 80%;
    background-color: #f9f9f9;
}
.help-dialog-content {
    position: relative;
    padding-top: 60px; /* Space for the logo */
}

.help-dialog-header {
    text-align: center;
    margin-bottom: 24px;
}

.help-dialog-logo {
    position: absolute;
    top: -20px;
    left: 50%;
    transform: translateX(-50%);
    width: 80px;
    height: 80px;
    opacity: 0.8;
}

#help-dialog h2 {
    color: var(--primary-color);
    margin-top: 0;
    font-size: 24px;
    line-height: 1.5;
}

#help-dialog h2 .duo {
    color: var(--primary-counter-color);
}

#help-dialog h2 .nat {
    color: var(--primary-color);
}

#help-dialog h2 .subtitle {
    color: var(--dark-neutral-color);
    font-size: 0.8em;
}

.help-content {
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.help-item {
    display: flex;
    align-items: center;
    gap: 16px;
    background-color: white;
    padding: 16px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
}

.help-item svg {
    flex-shrink: 0;
}

.help-item p {
    margin: 0;
    font-size: 18px;
    line-height: 1.4;
    color: var(--dark-neutral-color);
    text-align: left; /* TODO doesn't work */
}

#keyboard-shortcuts {
    margin-top: 20px;
}

#keyboard-shortcuts h3 {
    margin-bottom: 10px;
    color: var(--primary-color);
}

#keyboard-shortcuts ul {
    list-style-type: none;
    padding-left: 0;
}

#keyboard-shortcuts li {
    margin-bottom: 5px;
    text-align: left;
}

#keyboard-shortcuts strong, #shortcut-key {
    display: inline-block;
    width: 20px;
    text-align: center;
    margin-right: 10px;
    background-color: var(--primary-color);
    color: white;
    border-radius: 3px;
    padding: 2px;
}

#start-tutorial-button, #discord-help-dialog {
    background-color: var(--primary-color);
    color: var(--text-color);
    border: none;
    padding: 12px 24px;
    border-radius: 12px;
    cursor: pointer;
    text-align: center;
    font-size: 20px;
    font-weight: bold;
    transition: background-color var(--transition-speed) ease, transform 0.1s ease;
    width: 100%;
}

#version-id {
    padding-top: 8px;
    font-size: 14px;
    color: var(--counter-text-color);
}

/* Styles for tutorial */
.tutorial-highlight {
    position: absolute;
    border-radius: 8px;
    box-shadow: 0 0 0 4px rgba(172, 0, 40, 0.5); /* var(--primary-counter-color); */
    pointer-events: none;
    z-index: 10000;
    animation: pulse 1s infinite;
}

@keyframes pulse {
    0% {
        box-shadow: 0 0 0 0 rgba(172, 0, 40, 0.7);
    }
    70% {
        box-shadow: 0 0 0 10px rgba(172, 0, 40, 0);
    }
    100% {
        box-shadow: 0 0 0 0 rgba(172, 0, 40, 0);
    }
}

.shortcut-key {
    display: none;
    font-weight: bold;
    background-color: rgba(255, 255, 255, 0.2);
    padding: 2px 5px;
    border-radius: 3px;
    margin-right: 5px;
}

body.has-keyboard .shortcut-key {
    display: inline-block;
}
body.has-keyboard button {
    text-align: left;
}

/* Info dialog */

.info-dialog {
    position: fixed;
    transform: translate(0, 0); /* override system-wide centering of dialogs */
    padding: 20px;
    display: none;
    flex-direction: column;
    box-sizing: border-box;
    padding: 20px;
    background-color: #f1f7e5;
    border-radius: var(--border-radius);
    border-color: var(--primary-color);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    max-width: var(--max-image-width);
    width: 100%;
    overflow-y: auto;
    transition: top 0.3s ease-out, bottom 0.3s ease-out, height 0.3s ease-out;
}

.info-dialog[open] {
    display: flex;
}

.info-dialog__header {
    text-align: center;
    margin-bottom: 15px;
}

.info-dialog__taxon {
    font-size: 1.4em;
    margin: 0;
    color: var(--primary-counter-color);
    font-style: italic;
    text-shadow: 1px 1px 2px var(--shadow-color);
}

.info-dialog__vernacular {
    font-size: 1.2em;
    margin: 5px 0 0;
    color: var(--dark-neutral-color);
    text-shadow: 1px 1px 2px var(--shadow-color);
}

.info-dialog__facts {
    flex-grow: 1;
    margin: 15px 0;
    padding: 15px;
    background-color: var(--light-green);
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    overflow-y: auto;

}

.info-dialog__facts h3 {
    color: var(--primary-color);
    font-size: 1.2em;
    margin-bottom: 10px;
    padding-bottom: 8px;
    border-bottom: 2px solid var(--primary-color);
}

.info-dialog__facts ul {
    list-style-type: none;
    padding-left: 0;
    margin: 0;
}

.info-dialog__facts li {
    position: relative;
    padding-left: 24px;
    margin-bottom: 8px;
    text-align: left;
    font-size: 1.3em;
    line-height: 1.4;
    color: var(--dark-neutral-color);
    word-break: normal;
    overflow-wrap: break-word;
    hyphens: auto;
/*    text-shadow: 1px 1px 2px var(--shadow-color);*/
}

.info-dialog__facts li::before {
    content: "•";
    position: absolute;
    left: 8px;
    color: var(--primary-color);
    font-size: 1.3em;
}

.info-dialog__buttons {
    display: flex;
    justify-content: space-around;
    margin-top: 15px;
}

.info-dialog__button {
    padding: 10px;
}

@media (max-width: 480px) {
    .info-dialog {
        padding: 12px;
    }

    .info-dialog__header {
        margin-bottom: 5px;
    }

    .info-dialog__taxon {
        font-size: 1.4em;
    }

    .info-dialog__vernacular {
        font-size: 1.1em;
    }

    .info-dialog__facts {
        margin: 4px 0 0 0;
        padding: 10px;
    }

    .info-dialog__facts li {
        font-size: 1.2em;
        line-height: 1.2;
    }

    .info-dialog__buttons {
        margin-top: 15px;
    }

    .info-dialog__button-icon {
        width: 20px;
        height: 20px;
    }
}

/* Relationship graph dialog */

#phylogeny-dialog {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90%;
    height: 90%;
    max-width: 1800px;
    padding: 20px;
    display: flex;
    flex-direction: column;
    /*visibility: hidden;*/
    display: none;
    opacity: 0.92;
}

.graph-hint {
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(255, 255, 255, 0.8);
    color: var(--dark-neutral-color);
    padding: 5px 10px;
    border-radius: 15px;
    font-size: 0.9em;
    opacity: 0.8;
    transition: opacity 0.3s ease;
}

.graph-hint:hover {
    opacity: 0;
}

#taxa-relationship-graph {
    flex-grow: 1;
    overflow: hidden;
}

/* hide when dialog is hidden */
#phylogeny-dialog.hidden #taxa-relationship-graph {
    display: none;
    visibility: hidden;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    #phylogeny-dialog {
        width: 95%;
        height: 95%;
    }
}

#taxa-relationship-graph {
    flex-grow: 1;
    overflow: hidden;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .graph-dialog-content {
        width: 95%;
        height: 95%;
    }

    .graph-title {
        font-size: 1.2em;
        padding: 10px 0;
    }
}

.clickable-network .vis-network:hover {
    /* TODO: gives pointer not only over nodes*/
   /* cursor: pointer; */
}


/* Styles for iNaturalist Down Dialog */
#inat-down-dialog {
    position: relative;
    padding: 40px 2rem 2rem;
    width:100%; height:100%;
    z-index: 10000;
    background-color: white;
    padding: 0px;
    border-radius: 00px;
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
}

#inat-down-dialog {
  background-color: white;
  padding: 2rem;
  border-radius: var(--border-radius);
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
  max-width: 90%;
  width: 400px;
  text-align: center;
}

#inat-down-dialog h2 {
  color: var(--primary-counter-color);
  margin-bottom: 1rem;
}

#inat-down-dialog p {
  margin-bottom: 1rem;
  color: var(--counter-text-color);
}

#inat-down-dialog button {
  background-color: var(--primary-color);
  color: var(--text-color);
  border: none;
  padding: 0.75rem 1.5rem;
  border-radius: var(--border-radius);
  cursor: pointer;
  font-size: 1rem;
  margin: 0.5rem;
  transition: background-color var(--transition-speed) ease;
}

#inat-down-dialog button:hover {
  background-color: #5c8a00;
}

#check-inat-status {
  background-color: var(--primary-color);
}

#check-inat-status:hover {
  background-color: #8a0020;
}





# styles/components/loading.css

/* Styles for loading screen */

.loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #f9f9f9;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9000;
}

.loading-screen__content {
    text-align: center;
}

.loading-screen__logo {
    width: 100px;
    height: 100px;
    margin-bottom: 20px;
}

.loading-screen__title {
    font-size: 2.5em;
    margin-bottom: 10px;
}

.loading-screen__title-duo {
    color: var(--primary-counter-color);
}

.loading-screen__title-nat {
    color: var(--primary-color);
}

.loading-screen__message {
    font-size: 1.2em;
    color: #666;
    margin-bottom: 20px;
}

.loading-screen__spinner {
    border: 5px solid #f3f3f3;
    border-top: 5px solid var(--primary-color);
    border-radius: 50%;
    width: 50px;
    height: 50px;
    animation: spin 1s linear infinite;
    margin: 0 auto;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Phylogeny graph dialog */

.loading-indicator {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(255, 255, 255, 1);
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    text-align: center;
    z-index: 1000;
}

.loading-indicator-logo {
    width: 80px;
    height: 80px;
    margin-bottom: 15px;
}

.loading-indicator .loading-spinner {
    border: 5px solid #f3f3f3;
    border-top: 5px solid var(--primary-color);
    border-radius: 50%;
    width: 50px;
    height: 50px;
    animation: spin 1s linear infinite;
    margin: 0 auto 15px;
}

.loading-indicator p {
    margin: 0;
    color: var(--primary-color);
    font-size: 18px;
    font-weight: bold;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}





# styles/components/menu.css

/* Styles for main menu (to replace button column above) */

.main-menu {
    position: fixed;
    top: 10px;
    right: 10px;
    z-index: 1000;
}
/*
.main-menu button,
.main-menu__dropdown button {
    background-color: rgba(255, 255, 255, 0.6);
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    transition: background-color 0.3s ease;
    margin-bottom: 10px;
}

.main-menu button:hover,
.main-menu__dropdown button:hover {
    background-color: rgba(255, 255, 255, 0.8);
    transform: scale(1.1);
}
*/
.main-menu__dropdown {
    display: none;
    position: absolute;
    right: 0;
    top: 40px;
}

.main-menu__dropdown.show {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
}

.main-menu__item {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    margin-bottom: 10px;
}

.main-menu__label {
    display: flex;
    align-items: center;
    background-color: rgba(255, 255, 255, 0.9);
    height: fit-content; /* Adjust height to content */
    padding: 4px 10px;
    border-radius: 15px;
    font-size: 14px;
    margin-right: 10px;
    margin-top: -8px;
    opacity: 0;
    transition: opacity 0.3s ease;
    white-space: nowrap;
}

.main-menu__dropdown.show .main-menu__label {
    opacity: .8;
}

.main-menu__dropdown--top {
    top: 60px;
}

.main-menu__dropdown--bottom {
    position: absolute;
    top: 0; /* Will be set dynamically in JavaScript */
    right: 0;
}

/* Media query for larger screens */
@media (min-width: 768px) {
    .main-menu__dropdown--bottom {
        bottom: auto;
        top: 50px;
        right: 0;
    }
}




# styles/components/tooltips.css

/* not currently used */

.tooltip {
    position: absolute;
    background-color: var(--primary-color);
    color: white;
    padding: 5px 10px;
    border-radius: 8px;
    font-size: 14px;
    z-index: 1000;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.4s;
}

.tooltip.visible {
    opacity: 1;
}




# styles/layout/image-container.css

/* Image container and components */

.image-container {
    position: relative;
    flex: 1 1 300px;
    margin: 0px 0px;
    padding: 4px;
    aspect-ratio: 1/1;
    position: relative;
    background-color: var(--counter-text-color);
    box-shadow: 0 0 10px var(--shadow-color);
    border-radius: var(--border-radius);
    box-sizing: border-box;
    overflow: hidden;
    z-index: 1;
    cursor: default;
}
.image-container--drag-over {
    cursor: copy;
}

/* TODO this will be a problem when switching to side-by-side on desktop, keep in mind */
#image-container-1 {
    margin-top: 4px;
}
#image-container-2 {
    margin-bottom: 4px;
}
.image-container__image {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center;
    background-color: #f0f0f0;
    color: var(--primary-color);
    font-size: 36px;
    font-weight: bold;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: var(--border-radius);
    pointer-events: none; /* Prevents the image from interfering with dragging */
    transition: opacity var(--transition-speed) ease-in-out;
}

.image-container__image--loading {
    opacity: 0.5;
    transition: opacity var(--transition-speed) ease-in-out;    
}

/* World map overlays on images */

.image-container__world-map {
    position: absolute;
    left: 60px;
    width: 100px; /* Adjust as needed */
    height: 60px; /* Adjust as needed */
    border-radius: var(--border-radius);
    opacity: 0.6;
    z-index: 10;
}
.image-container__world-map svg {
    border-radius: var(--border-radius);
}

#world-map-1 {
    bottom: 5px;
}

#world-map-2 {
    bottom: 5px;
}

/* Drop zone for taxon tiles */
.image-container__drop-zone {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    opacity: 0.9;
    z-index: 10;
    width: 300px;
    max-width: calc(var(--max-image-width)-50px);
    height: 80px; /* Add a fixed height */
    transition: all 0.3s ease-out;
    pointer-events: none;
}

/* Used for marking the active image when showing the info dialog */

.image-container--framed {
    box-shadow: 0 0 0 4px rgba(116, 172, 0, 0.5);
    transition: box-shadow 0.3s ease;
    z-index: 1000;
}




# styles/layout/name-pair.css

/* Name pair container and components */

.name-pair {
    position: relative;
    display: flex;
    flex-wrap: nowrap;
    justify-content: center;
    align-items: stretch;
    background-color: rgb(0,0,0,0);
    margin: 4px auto;
    gap: 4px;
    width: 98%;
    max-width: var(--max-image-width);
    min-height: var(--center-min-height);
}

.name-pair__container--left, .name-pair__container--right {
    display: flex;
    flex: 1;
    min-width: 0;
    max-width: 300px;
    margin: 0px;
    min-height: var(--center-min-height);
}

/* Styles for draggable name tiles */
.name-pair__item--draggable {
    position: relative;
    box-sizing: border-box;
    z-index: 10;
    border-radius: var(--border-radius);

    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;

    padding: 6px;
    width: 300px;
    min-height: var(--center-min-height);

    color: var(--text-color);
    background-color: var(--primary-color);
    opacity: 1;
    font-size: 22px;

    text-shadow: 1px 1px 2px var(--shadow-color);

    touch-action: none;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    word-break: break-word;
    hyphens: auto;

    box-shadow: 0 0 0 2px white;
    cursor: grab;
    transition: box-shadow var(--transition-speed) ease;
}

.name-pair__taxon-name,
.name-pair__vernacular-name {
    width: 100%;
    display: block;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: wrap; /* TODO claude says no-wrap */
}

.name-pair__taxon-name {
    font-style: italic;
    font-weight: bold;
    margin-bottom: 2px;
    font-size: 0.95em;
}

.name-pair__vernacular-name {
    font-size: 0.85em;
    color: rgba(255, 255, 255, 0.8);
}

.name-pair__item--draggable:hover {
    transform: scale(1.02);
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

/*.name-pair__item--draggable,
.name-pair__item--draggable.dragging {
    max-width: 300px;
}
*/

.name-pair__item--dragging {
    /* Ensure the element is rendered as its own layer */
    transform: translateZ(0) !important;
    -webkit-transform: translateZ(0) !important;
}

.name-pair__item--draggable {
    -khtml-user-select: none !important;
    -moz-user-select: none !important;
    -ms-user-select: none !important;
}

/* Message overlay */

.name-pair__overlay {
    position: absolute;
    border-radius: var(--border-radius);
    height: 100%;
    background-color: var(--overlay-color);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    opacity: 0;
    pointer-events: none;
    transition: opacity var(--transition-speed) ease, background-color var(--transition-speed) ease;
}

.name-pair__overlay.show { opacity: 1; }

.name-pair__overlay-message {
    font-size: 2.4em;
    font-weight: bold;
    color: var(--text-color);
    text-shadow: 1px 1px 2px var(--shadow-color);
    padding: 15px;
    max-width: 95%;
    line-height: 1.4;
}

/*new*/
.name-pair__item--draggable {
    position: relative;
    box-sizing: border-box;
    z-index: 10;
    border-radius: var(--border-radius);
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 6px;
    width: 300px;
    min-height: var(--center-min-height);
    color: var(--text-color);
    background-color: var(--primary-color);
    opacity: 1;
    font-size: 22px;
    text-shadow: 1px 1px 2px var(--shadow-color);
    touch-action: none;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    word-break: break-word;
    hyphens: auto;
    box-shadow: 0 0 0 2px white;
    cursor: grab;
    transition: all 0.3s ease-out;
    -webkit-touch-callout: none !important;
    -webkit-user-select: none !important;
    user-select: none !important;
    -webkit-tap-highlight-color: rgba(0,0,0,0) !important;
}

.name-pair__item--landing {
    transition: all 0.3s ease-out !important;
}

.name-pair__item--draggable:active,
.name-pair__item--dragging {
    width: 300px !important;
    opacity: 0.9 !important;
    border: 2px solid white !important;
    box-shadow: 0 0 0 2px white, 0 0 10px 3px rgba(255, 255, 255, 0.7);
    box-shadow: 0 0 10px 3px rgba(255, 255, 255, 0.7) !important;
    -webkit-box-shadow: 0 0 10px 3px rgba(255, 255, 255, 0.7) !important;
    transition: all 0.1s ease-out !important;
    z-index: 1000 !important;
    transform: translateZ(0) !important;
    -webkit-transform: scale(1.05) translateZ(0) !important;
    -webkit-backface-visibility: hidden !important;
    -webkit-perspective: 1000 !important;
    cursor: grabbing !important;
}

/*
@keyframes correctAnswer {
    0%, 100% { background-color: var(--primary-color); }
    50% { background-color: #4CAF50; } 
}
*/

@keyframes incorrectAnswer {
    0%, 100% { background-color: var(--primary-color); }
    50% { background-color: #F44336; } /* Red */
}

.name-pair__item--correct {
    animation: correctAnswer 0.6s ease-in-out;
}

.name-pair__item--incorrect {
    animation: incorrectAnswer 0.6s ease-in-out;
}


