\n==> index.html <==\n
<!DOCTYPE html>
<html lang="en">
<head>
    <title>DuoNat â€¢ iNat Taxonomy Trainer</title>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta http-equiv="Cache-Control" content="no-cache">

    <!-- For iOS devices -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- For Android devices -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#74ac00">

    <!-- cache busting by appending version code. change code in script!-->
    <script src="./code/version.js" defer></script>

    <link rel="manifest" href="./manifest.json">
    <script type="module" src="./code/functions.js" defer></script>
    <link rel="stylesheet" href="./css/styles.css">
    <link rel="icon" href="./images/favicon.png" type="image/png">
  <!--  <link rel="preload" href="./images/icons.svg" as="image" type="image/svg+xml"> -->
</head>

<body>

<button id="share-button" title="Share this pair">
<!-- no idea why some svg don't load, temporary workaround -->
         <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
             <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"/>
         </svg>
<!--    <svg class="icon"><use href="./images/icons.svg#icon-share"/></svg>-->
</button>

<button id="help-button" title="Help">
    <svg class="icon"> <use href="./images/icons.svg#icon-help"/></svg>
</button>

<dialog id="help-dialog">
    <img src="./images/icon-512x512.png" alt="DuoNat logo" class="background-logo">
    <h2>DuoNat<br>iNat Taxonomy Trainer</h2>
    <div class="help-content">

        <div class="help-item">
<!--            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M9 11.24V7.5C9 6.12 10.12 5 11.5 5S14 6.12 14 7.5v3.74c1.21-.81 2-2.18 2-3.74C16 5.01 13.99 3 11.5 3S7 5.01 7 7.5c0 1.56.79 2.93 2 3.74zm9.84 4.63l-4.54-2.26c-.17-.07-.35-.11-.54-.11H13v-6c0-.83-.67-1.5-1.5-1.5S10 6.67 10 7.5v10.74l-3.43-.72c-.08-.01-.15-.03-.23-.03-.31 0-.59.13-.79.33l-.79.8 4.94 4.94c.27.27.65.44 1.06.44h6.79c.75 0 1.33-.55 1.44-1.28l.75-5.27c.01-.07.02-.14.02-.2 0-.62-.38-1.16-.91-1.38z"></path> </svg>-->
            <svg class="icon"><use href="./images/icons.svg#icon-drag"/></svg>
            <p>Drag name to image</p>
        </div>

        <div class="help-item">
            <svg class="icon"> <use href="./images/icons.svg#icon-left"/></svg>
            <p>Swipe left for new taxon pair</p>
        </div>

        <div class="help-item">
         <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z"/>
         </svg>
         <!--   <svg class="icon"> <use href="./images/icons.svg#icon-up"/></svg>-->
            <p>Scroll down for more</p>
        </div>

        <div class="help-item">
         <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
             <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"/>
         </svg>
         <!--   <svg class="icon"> <use href="./images/icons.svg#icon-share"/></svg>-->
            <p>Share current taxon pair</p>
        </div>
        <button id="discord-help-dialog">Join us on Discord</button>

    </div>
<!-- enable 'more-help-dialog' event listener when activated! 
<button id="more-help-dialog">Tell me more!</button> -->
    <button id="close-help-dialog">I'm good!</button>
</dialog>

<div class="game-container">

    <div class="image-container" id="image-container-1">
        <img src="" alt="Taxon 1" id="image-1">
        <div id="drop-1" class="droppable"></div>
        <button class="info-button" id="info-button-1" title="View on iNaturalist">
            <svg class="icon"><use href="./images/icons.svg#icon-info"/></svg>
        </button>
    </div>

    <div class="name-pair">

        <div id="left-name-container">
            <div id="left-name" class="draggable" draggable="true" title=""></div>
        </div>

        <div id="right-name-container">
            <div id="right-name" class="draggable" draggable="true" title=""></div>
        </div>

        <div id="overlay">
            <div id="overlay-message"></div>
        </div>
  
    </div>

    <div class="image-container" id="image-container-2">
        <img src="" alt="Taxon 2" id="image-2">
        <div id="drop-2" class="droppable"></div>
        <button class="info-button" id="info-button-2" title="View on iNaturalist">
            <svg class="icon"><use href="./images/icons.svg#icon-info"/></svg>
        </button>
    </div>

</div> <!-- game-container -->

    <div class="scrollable-content">

        <div class="button-container">
            <div class="button-row">
                <button class="bottom-button" id="random-pair-button">Random pair</button>
                <button class="bottom-button" id="select-pair-button">Select pair</button>
            </div>
            <div class="button-row">
                <button class="bottom-button" id="enter-pair-button">Enter pair</button>
                <button class="bottom-button" id="surprise-button">Surprise</button>
            </div>
        </div>

      <!--  <div><a id="home-link" href="../index.html">Home</a></div> -->
        <div id="version-id"></div>

    </div>

    <!-- only visible when opened in app-->
    <dialog id="enter-pair-dialog">
        <form method="dialog">
            <h2>Enter New Taxon Pair</h2>
            <div>
                <label for="taxon1">Taxon 1:</label>
                <input type="text" id="taxon1" required>
            </div>
            <div>
                <label for="taxon2">Taxon 2:</label>
                <input type="text" id="taxon2" required>
            </div>
            <div id="dialog-message"></div>
            <div class="dialog-buttons">
                <button type="button" id="close-dialog">Cancel</button>
                <button type="submit">Submit</button>
            </div>
        </form>
    </dialog>

    <!--
<dialog id="inat-down-dialog" class="fullscreen-dialog">
  <div class="dialog-content">
    <h2>iNaturalist Unavailable</h2>
    <p>We're having trouble connecting to iNaturalist. This could be due to maintenance or temporary issues.</p>
    <p>Please try again later or check the iNaturalist status page for updates.</p>
    <button id="check-inat-status">Check iNaturalist Status</button>
    <button id="retry-connection">Retry Connection</button>
  </div>
  -->

</body>
</html>
\n==> CSS <==\n
/* custom properties */
:root {
    --primary-color: #74ac00; /* iNat green */
    --primary-counter-color: #ac0028; /* red */
    --background-color: #ffffff;
    --text-color: #ffffff;
    --counter-text-color: #444;
    --shadow-color: rgba(0, 0, 0, 0.1);
    --overlay-color: rgba(0, 0, 0, 0.3);
    --border-radius: 8px;
    --max-image-width: 500px;
/*    --transition-speed: 0.3s;*/
    --transition-speed: 0.3s;
    /* images wobble when <80px */
    --center-min-height: 80px; /* consider relative to screen */
}

body {
    display: flex;
    flex-direction: column;
    height: 100vh;
    margin: 0; padding: 0;
    overflow: auto;
    box-sizing: border-box;
    font-family: 'Open Sans', Arial, sans-serif;
}
body * { text-align: center; } /* percolate to child elements */

#share-button {
    position: fixed;
    top: 10px;
    right: 10px;
    background: rgba(255, 255, 255, 0.4);
    border: none;
    cursor: pointer;
    z-index: 1000;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    transition: background-color var(--transition-speed) ease;
}

#share-button svg {
    width: 24px;
    height: 24px;
    fill: var(--primary-counter-color);
    transition: fill var(--transition-speed) ease;
}

.game-container {
    flex: none;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    height:100vh;
    padding: 0;
    overflow: hidden;
    padding: 0px;
    box-sizing: border-box;
    transition: transform 0.1 ease-out, opacity 0.1 ease-out;
}

.image-pair {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-around;
    align-items: center;
    width: 100%;
}

.image-container {
    position: relative;
    flex: 1 1 300px;
    margin: 4px;
    padding: 4px;
    aspect-ratio: 1/1;
    position: relative;
    background-color: var(--counter-text-color);
    box-shadow: 0 0 10px var(--shadow-color);
    border-radius: var(--border-radius);
    box-sizing: border-box;
    overflow: hidden;
    z-index: 1;
    cursor: default;
}
.image-container.drag-over {
    cursor: copy;
}
.image-container img {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center;
    background-color: #f0f0f0;
    color: var(--primary-color);
    font-size: 36px;
    font-weight: bold;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: var(--border-radius);
    pointer-events: none; /* Prevents the image from interfering with dragging */
    transition: opacity var(--transition-speed) ease-in-out;
}
.image-container img.loading {
    opacity: 0.5;
    transition: opacity var(--transition-speed) ease-in-out;    
}

.info-button {
    position: absolute;
    bottom: 10px;
    right: 10px;
    background: rgba(255, 255, 255, 0.7);
    border: none;
    border-radius: 50%;
    width: 30px;
    height: 30px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    transition: background-color 0.3s ease;
    z-index: 10;
}

.info-button:hover {
    background: rgba(255, 255, 255, 0.9);
}

.info-button .icon {
    width: 20px;
    height: 20px;
    fill: var(--primary-color);
}

.image-container,
.name-pair,
#overlay {
    width: 98vw;
    max-width: var(--max-image-width);
    /*width: calc(100% - 8px);*/
    }

.name-pair {
    position: relative;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: stretch;
    margin: 4px auto;
    gap: 4px;
    min-height: var(--center-min-height);
}

#left-name-container, #right-name-container {
    display: flex;
    flex-basis: 100%;
    flex: 1 1 calc(50% - 4px);
    min-width: 200px; /*adjust as needed for horizontal/vertical flip*/
/*    width: var(--max-image-width);*/
    margin: 0px;
    min-height: var(--center-min-height);
}

/* what is this? */
/* .droppable .draggable {
    background-color: var(--primary-color);
    opacity: 0.8;
    color: var(--text-color);
    padding: 10px;
    border-radius: var(--border-radius);
    width: 100%;
    box-sizing: border-box; } */

.draggable {
    flex: 1;
    flex-direction: column;
    display: flex;
    justify-content: center;
    align-items: center;
    box-sizing: border-box;
    padding: 10px;
    border-radius: var(--border-radius);
    width: 100%;
    max-width: var(--max-image-width);
    min-height: var(--center-min-height);
    color: var(--text-color);
    background-color: var(--primary-color);
    opacity: 0.8;
    font-size: 22px;
    position: relative;
    z-index: 10;
    touch-action: none;
    box-sizing: border-box;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    word-break: break-word;
    hyphens: auto;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    cursor: grab;
    /* transition: all var(--transition-speed) ease;
    max-width: calc(var(--max-image-width) - 50px); */
}

.draggable .taxon-name,
.draggable .vernacular-name {
    width: 100%;
    display: block;
    overflow: hidden;
    text-overflow: ellipsis;
}

.draggable .taxon-name {
    font-style: italic;
    font-weight: bold;
    margin-bottom: 4px;
}

.draggable .taxon-name {
    font-size: 1em;
}
.draggable .vernacular-name {
    font-size: 20px;
    font-size: 0.8em;
    color: rgba(255, 255, 255, 0.8);
}

.draggable:active {
    cursor: grabbing;
    transform: scale(1.05);
/*    max-width: calc(var(--max-image-width)-50px);
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);*/
}

.draggable.dragging {
    position: absolute;
    pointer-events: none;
    width: 60%;
/*    z-index: 1000;*/
}

.droppable .draggable,
.draggable.dragging {
    box-shadow: 0 0 0 2px white;/*, 0 0 10px 3px rgba(255, 255, 255, 0.7);*/
    transition: box-shadow var(--transition-speed) ease;
    max-width: var(--max-image-width);
}

.droppable {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    width: 60%;
    max-width: calc(var(--max-image-width)-50px);
    height: 60px; /* Add a fixed height */
    pointer-events: none;
}
#image-container-1 .droppable { bottom: 10%; }
#image-container-2 .droppable { top: 10%; }

@keyframes dropAnimation {
    0% { transform: scale(1.1); }
    100% { transform: scale(1); }
}
.drop-animation { animation: dropAnimation 0.3s ease-out forwards; }

.swipe-out-left { animation: swipeOutLeft 0.5s ease-out forwards; }

@keyframes swipeOutLeft {
    to {
        transform: rotate(-5deg) translateX(-100%);
        opacity: 0;
    }
}

#overlay {
    position: absolute;
    border-radius: var(--border-radius);
    height: 100%;
    background-color: var(--overlay-color);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    opacity: 0;
    pointer-events: none;
    /*transition: opacity var(--transition-speed) ease;*/
    transition: opacity var(--transition-speed) ease, background-color var(--transition-speed) ease;
}

#overlay.show { opacity: 1; }

#overlay-message {
    font-size: 3em;
/*    font-size: clamp(14px, 5vw, 36px);  not sure this is functional */
    font-weight: bold;
    color: var(--text-color);
    text-shadow: 2px 2px 4px var(--shadow-color);
    padding: 20px;
    transition: opacity var(--transition-speed) ease;
}

.bottom-button {
    background-color: var(--primary-color);
    color: var(--text-color);
    font-size: 20px;
    border: none;
    padding: 15px 32px;
    border-radius: var(--border-radius);
    margin: 4px 0;
    width: 100%;
    max-width: 200px;
    cursor: pointer;
    transition: background-color var(--transition-speed) ease;
    outline: none;
}

#home-link {
    font-size: 14px;
    color: var(--counter-text-color);
    text-decoration: none;
}

#version-id {
    padding-top: 8px;
    font-size: 14px;
    color: var(--counter-text-color);
}

/* for enter pair dialog */
#enter-pair-dialog {
    padding: 20px;
    border-radius: var(--border-radius);
    border: none;
    box-shadow: 0 0 10px var(--shadow-color);
    max-width: 400px;
    width: 80%;
}
#enter-pair-dialog h2 {
    color: var(--primary-color);
    margin-bottom: 20px;
}
#enter-pair-dialog form {
    display: flex;
    flex-direction: column;
    gap: 15px;
}
#enter-pair-dialog label {
    display: inline-block;
    width: 80px;
    text-align: right;
    margin-right: 10px;
    font-weight: bold;
    font-size: 18px;
    color: var(--counter-text-color);
}
#enter-pair-dialog input {
    width: calc(100% - 90px);
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 18px;
    color: var(--counter-text-color);
}
#enter-pair-dialog button {
    background-color: var(--primary-color);
    color: var(--text-color);
    border: none;
    padding: 10px 15px;
    border-radius: var(--border-radius);
    cursor: pointer;
    font-size: 18px;
    font-weight: bold;
    transition: background-color var(--transition-speed) ease;
}
#enter-pair-dialog button:hover {
    background-color: #5c8a00;
}
#enter-pair-dialog #close-dialog {
    background-color: var(--primary-counter-color)
}

#dialog-message {
    color: var(--text-color);
    font-style: italic;
    margin-top: 10px;
}
.dialog-buttons {
    display: flex;
    justify-content: space-between;
    margin-top: 20px;
}

/* Styles for the select taxon pair list dialog */
.taxon-pair-modal {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}
.taxon-pair-list {
    background-color: var(--background-color);
    padding: 8px;
    border-radius: var(--border-radius);
    max-width: 90%;
    max-height: 95%;
    overflow-y: auto;
}
.taxon-pair-button {
    display: block;
    width: 100%;
    padding: 8px;
    margin: 4px 0;
    color: var(--text-color);
    background-color: var(--primary-color);
    border: none;
    border-radius: 5px;
    cursor: pointer;
            font-size: 20px;
}
.taxon-pair-versus {
    color: #666;
}
.taxon-pair-cancel-button {
    display: block;
    width: 100%;
    padding: 10px;
    margin: 10px 0;
    color: var(--text-color);
    background-color: var(--primary-counter-color);
    border: none;
    border-radius: 5px;
    font-size:22px;
    font-weight: bold;
    cursor: pointer;
}

#help-dialog {
    padding: 80px 24px 24px;
    border-radius: 12px;
    border: none;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    max-width: 400px;
    width: 80%;
    background-color: #f9f9f9;
}

#help-dialog .background-logo {
  position: absolute;
  top: -18px;
  left: 50%;
  transform: translateX(-50%);
  width: 20%;
  height: 20%;
  opacity: 0.8;
  z-index: 0;
}

#help-dialog h2 {
    color: var(--primary-color);
    margin-top: 0;
    margin-bottom: 24px;
    font-size: 24px;
    text-align: center;
    line-height: 1.5;
}

.help-content {
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.help-item {
    display: flex;
    align-items: center;
    gap: 16px;
    background-color: white;
    padding: 16px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
}

.help-item svg {
    width: 24px;
    height: 24px;
    fill: var(--primary-color);
    flex-shrink: 0;
}

.help-item p {
    margin: 0;
    font-size: 18px;
    line-height: 1.4;
    color: #333;
    text-align: left;
}

#more-help-dialog, #discord-help-dialog, #close-help-dialog {
    background-color: var(--primary-color);
    color: var(--text-color);
    border: none;
    padding: 12px 24px;
    border-radius: 24px;
    cursor: pointer;
    font-size: 20px;
    font-weight: bold;
    transition: background-color var(--transition-speed) ease, transform 0.1s ease;
    margin-top: 24px;
    width: 100%;
}
#close-help-dialog {
    background-color: var(--primary-counter-color);
}

#more-help-dialog:hover {
    background-color: #5c8a00;
}

#more-help-dialog:active, #close-help-dialog:active {
    transform: scale(0.98);
    margin-top: 12px;
}

#help-button {
    position: fixed;
    top: 10px;
    left: 10px;
    background: rgba(255, 255, 255, 0.4);
    border: none;
    cursor: pointer;
    z-index: 1000;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    transition: background-color var(--transition-speed) ease;
}

#help-button svg {
    width: 24px;
    height: 24px;
    fill: var(--primary-counter-color);
    transition: fill var(--transition-speed) ease;
}

#tell-me-more-button {
    background-color: var(--primary-counter-color);
    color: var(--text-color);
    border: none;
    padding: 12px 24px;
    border-radius: 24px;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
    transition: background-color --var(--transition-speed) ease, transform 0.1s ease;
    margin-top: 24px;
    width: 100%;
    text-align: center;
    text-decoration: none;
    display: block;
}

#tell-me-more-button:hover {
    background-color: #8a0020;
}

#tell-me-more-button:active {
    transform: scale(0.98);
}

/* Styles for iNaturalist Down Dialog */
.fullscreen-dialog {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(255, 255, 255, 0.95);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 2000;
  border: none;
}

.fullscreen-dialog::backdrop {
  background-color: rgba(0, 0, 0, 0.5);
}

.dialog-content {
  background-color: white;
  padding: 2rem;
  border-radius: var(--border-radius);
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
  max-width: 90%;
  width: 400px;
  text-align: center;
}

.dialog-content h2 {
  color: var(--primary-counter-color);
  margin-bottom: 1rem;
}

.dialog-content p {
  margin-bottom: 1rem;
  color: var(--counter-text-color);
}

.dialog-content button {
  background-color: var(--primary-color);
  color: var(--text-color);
  border: none;
  padding: 0.75rem 1.5rem;
  border-radius: var(--border-radius);
  cursor: pointer;
  font-size: 1rem;
  margin: 0.5rem;
  transition: background-color var(--transition-speed) ease;
}

.dialog-content button:hover {
  background-color: #5c8a00;
}

#check-inat-status {
  background-color: var(--primary-color);
}

#check-inat-status:hover {
  background-color: #8a0020;
}

==> ./api.js <==
// iNat API

const api = (() => {
    return {

        // fetch from JSON file
        fetchTaxonPairs: async function () {
            try {
                const response = await fetch('./data/taxonPairs.json');
                if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); }
                return await response.json();
            } catch (error) { console.error("Could not fetch taxon pairs:", error); return []; }
        },

        // for user input of new taxon pairs
        validateTaxon: async function (taxonName) {
            try {
                const response = await fetch(`https://api.inaturalist.org/v1/taxa?q=${encodeURIComponent(taxonName)}`);
                const data = await response.json();
                return data.results.length > 0 ? data.results[0] : null;
            } catch (error) {
                console.error('Error validating taxon:', error);
                return null;
            }
        },

        // fetch random image of taxon from iNat
        fetchRandomImage: async function (taxonName) {
            const images = await this.fetchMultipleImages(taxonName, 1);
            return images.length > 0 ? images[0] : null;
        },

        fetchMultipleImages: async function (taxonName, count = 12) {
            try {
                const searchResponse = await fetch(`https://api.inaturalist.org/v1/taxa?q=${taxonName}`);
                const searchData = await searchResponse.json();
                if (searchData.results.length === 0) { throw new Error('Taxon not found'); }
                const taxonId = searchData.results[0].id;
                
                const taxonResponse = await fetch(`https://api.inaturalist.org/v1/taxa/${taxonId}`);
                const taxonData = await taxonResponse.json();
                if (taxonData.results.length === 0) { throw new Error('No details found for the taxon'); }
                const taxon = taxonData.results[0];
                
                let images = taxon.taxon_photos.map(photo => photo.photo.url.replace('square', 'medium'));
                
                // If we don't have enough images, we'll just return what we have
                return images.slice(0, Math.min(count, images.length));
            } catch (error) {
                console.error(error);
                return [];
            }
        },

        // fetch vernacular name of taxon from iNat
        fetchVernacular: async function (taxonName) {
            const baseUrl = 'https://api.inaturalist.org/v1/taxa';
            try {
                const response = await fetch(`${baseUrl}?q=${encodeURIComponent(taxonName)}`);
                const data = await response.json();
                if (data.results && data.results.length > 0) {
                    const taxon = data.results[0];
                    return taxon.preferred_common_name || null;
                } else {
                    return null;
                }
            } catch (error) {
                console.error('Error fetching vernacular name:', error);
                return null;
            }
        },

        // function to check if iNaturalist API is reachable
        isINaturalistReachable: async function () {
          try {
            const response = await fetch('https://api.inaturalist.org/v1/taxa?q=test');
            return response.ok;
          } catch (error) {
            console.error('Error pinging iNaturalist API:', error);
            return false;
          }
        },

    }; 

})();

export default api;

==> ./config.js <==
// Configuration

const config = {

    // overlay colors
    overlayColors: {
        green: "rgba(116,172,0,1.0)", /* iNat green */
        red: "rgba(172, 0, 40, 1.0)",
        gray: "rgba(100, 100, 100, 0.8"
    },
    debug: false,
    enablePreloading: false // Set to false to disable preloading
    };

export default config;

==> ./dragAndDrop.js <==
// Drag and drop functionality

import game from './game.js';

const dragAndDrop = {

    // tile dragging stuff
    draggedElement: null,
    touchOffset: { x: 0, y: 0 },

    initialize() {
        this.addEventListeners();
    },

    addEventListeners() {
        document.querySelectorAll('.draggable').forEach(element => {
            element.addEventListener('dragstart', this.dragStart.bind(this));
            element.addEventListener('touchstart', this.touchStart.bind(this), { passive: false });
            element.addEventListener('touchmove', this.touchMove.bind(this), { passive: false });
            element.addEventListener('touchend', this.touchEnd.bind(this), { passive: false });
        });

        document.querySelectorAll('.image-container').forEach(element => {
            element.addEventListener('dragover', this.dragOver.bind(this));
            element.addEventListener('dragleave', this.dragLeave.bind(this));
            element.addEventListener('drop', this.drop.bind(this));
        });
    },

    dragStart(e) {
        e.dataTransfer.setData('text/plain', e.target.id);
    },

    touchStart(e) {
        e.preventDefault();
        this.draggedElement = e.target.closest('.draggable');
        if (!this.draggedElement) return;
        
        const touch = e.touches[0];
        const rect = this.draggedElement.getBoundingClientRect();
        this.touchOffset.x = touch.clientX - rect.left;
        this.touchOffset.y = touch.clientY - rect.top;
        
        this.draggedElement.style.zIndex = '1000';
        this.draggedElement.style.position = 'fixed';
        this.updateElementPosition(touch);
    },

    touchMove(e) {
        e.preventDefault();
        if (this.draggedElement) {
            const touch = e.touches[0];
            this.updateElementPosition(touch);
        }
    },

    touchEnd(e) {
        e.preventDefault();
        if (this.draggedElement) {
            const dropZone = this.getDropZone(e);
            if (dropZone) {
                this.handleDrop(dropZone);
            } else {
                this.resetDraggedElement();
            }
            this.draggedElement.style.zIndex = '';
            this.draggedElement.style.position = '';
            this.draggedElement = null;
        }
    },

    updateElementPosition(touch) {
        this.draggedElement.style.left = `${touch.clientX - this.touchOffset.x}px`;
        this.draggedElement.style.top = `${touch.clientY - this.touchOffset.y}px`;
    },

    dragOver(e) {
        e.preventDefault();
        if (e.target.classList.contains('image-container')) {
            e.target.classList.add('drag-over');
        }
    },

    dragLeave(e) {
        if (e.target.classList.contains('image-container')) {
            e.target.classList.remove('drag-over');
        }
    },

    drop(e) {
        e.preventDefault();
        const data = e.dataTransfer.getData('text');
        const draggedElement = document.getElementById(data);
        
        let dropZone;
        if (e.target.classList.contains('image-container')) {
            e.target.classList.remove('drag-over');
            dropZone = e.target.querySelector('div[id^="drop-"]');
        } else if (e.target.tagName === 'IMG') {
            e.target.parentElement.classList.remove('drag-over');
            dropZone = e.target.nextElementSibling;
        } else { 
            return; // Drop on an invalid target
        }

        this.handleDrop(dropZone, draggedElement);
    },

    handleDrop(dropZone, draggedElement = this.draggedElement) {
        if (!draggedElement) return;
        
        dropZone.innerHTML = '';
        dropZone.appendChild(draggedElement);
        draggedElement.style.position = 'static'; // Reset position to static
        draggedElement.style.left = '';
        draggedElement.style.top = '';
        draggedElement.style.width = '100%'; // Ensure the dragged element fills the drop zone width
        
        const otherNameId = draggedElement.id === 'left-name' ? 'right-name' : 'left-name';
        const otherName = document.getElementById(otherNameId);
        const otherDropZone = document.getElementById(dropZone.id === 'drop-1' ? 'drop-2' : 'drop-1');
        otherDropZone.innerHTML = '';
        otherDropZone.appendChild(otherName);
        
        game.checkAnswer(dropZone.id);
    },

    getDropZone(e) {
        const touch = e.changedTouches ? e.changedTouches[0] : e;
        const imageContainers = document.querySelectorAll('.image-container');
        for (let container of imageContainers) {
            const rect = container.getBoundingClientRect();
            if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
                touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
                return container.querySelector('div[id^="drop-"]');
            }
        }
        return null;
    },

    resetDraggedElement() {
        const originalContainer = this.draggedElement.id === 'left-name' ? 'left-name-container' : 'right-name-container';
        document.getElementById(originalContainer).appendChild(this.draggedElement);
        this.draggedElement.style.position = '';
        this.draggedElement.style.left = '';
        this.draggedElement.style.top = '';
    }
};

export default dragAndDrop;

==> ./eventHandlers.js <==
// Event handlers

import api from './api.js';
import game from './game.js';
import ui from './ui.js';
import utils from './utils.js';
import dragAndDrop from './dragAndDrop.js';
import { elements, gameState } from './state.js';

const eventHandlers = {

    // global variables for swiping left
    startX: 0,
    endX: 0,
    isDragging: false,
    gameContainer: null,
    touchStartX: 0,
    touchStartY: 0,
    touchEndX: 0,
    touchEndY: 0,

    swipeThreshold: 50, // minimum distance to trigger a swipe
    swipeRestraint: 100, // maximum vertical distance allowed during a swipe

    initialize() {
        this.initializeSwipeFunctionality();
        this.initializeAllEventListeners();
    },

    initializeSwipeFunctionality() {
        this.gameContainer = document.querySelector('.game-container');
        if (!this.gameContainer) {
            console.error('Game container not found');
            return;
        }
        
        const namePairElement = document.querySelector('.name-pair');

        // Add event listeners only to image containers
        [elements.imageOneContainer, elements.imageTwoContainer].forEach(container => {
            container.addEventListener('mousedown', this.handleMouseDown.bind(this));
            container.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: true });
            container.addEventListener('mousemove', this.handleDragMove.bind(this));
            container.addEventListener('touchmove', this.handleDragMove.bind(this), { passive: true });
            container.addEventListener('mouseup', this.handleSwipeOrDrag.bind(this));
            container.addEventListener('touchend', this.handleSwipeOrDrag.bind(this));
        });
    },

    initializeAllEventListeners() {
        dragAndDrop.initialize();
        
        // button listeners
        document.getElementById('share-button').addEventListener('click', this.shareCurrentPair);
        document.getElementById('random-pair-button').addEventListener('click', async () => { await game.setupGame(true); });
        document.getElementById('select-pair-button').addEventListener('click', this.showTaxonPairList);
    
        // touch events
        [elements.imageOneContainer, elements.imageTwoContainer].forEach(container => {
            container.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: true });
            container.addEventListener('touchend', this.handleImageInteraction.bind(this));
            container.addEventListener('mousedown', this.handleMouseDown.bind(this));
            container.addEventListener('mouseup', this.handleImageInteraction.bind(this));
        });

        // dialog events
        document.getElementById('enter-pair-button').addEventListener('click', () => {
            ui.clearDialogInputs();
            document.getElementById('enter-pair-dialog').showModal();
        });
        document.getElementById('close-dialog').addEventListener('click', () => {
            document.getElementById('enter-pair-dialog').close();
        });
        document.querySelector('#enter-pair-dialog form').addEventListener('submit', this.handleNewPairSubmit);
        document.getElementById('surprise-button').addEventListener('click', () => {
            ui.clearDialogInputs();
            utils.surprise();
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', this.handleKeyboardShortcuts.bind(this));

        // Help button functionality
        document.getElementById('help-button').addEventListener('click', () => {
            document.getElementById('help-dialog').showModal();
        });
        document.getElementById('discord-help-dialog').addEventListener('click', () => {
            window.open('https://discord.gg/DcWrhYHmeM', '_blank');
        });
        document.getElementById('close-help-dialog').addEventListener('click', () => {
            document.getElementById('help-dialog').close();
        });

        // Prevent scrolling in the name-pair area
        elements.namePair.addEventListener('touchmove', (event) => { event.preventDefault(); }, { passive: false });
        elements.namePair.addEventListener('wheel', (event) => { event.preventDefault(); }, { passive: false });

        // Scroll to top when a button is clicked
        elements.buttons.forEach(button => { button.addEventListener('click', () => { ui.scrollToTop(); }); });
    },

    handleMouseDown(e) {
        if (!e.target.closest('.image-container') || e.target.closest('.info-button')) return;
        if (e.target.closest('.draggable')) return; // Ignore draggable elements
        this.startX = e.clientX;
        this.startY = e.clientY;
        this.isDragging = true;
    },

    handleTouchStart(e) {
        if (!e.target.closest('.image-container') || e.target.closest('.info-button')) return;
        this.startX = e.touches[0].clientX;
        this.startY = e.touches[0].clientY;
        this.isDragging = true;
    },

    handleSwipeOrDrag(e) {
        if (!this.isDragging) return;
        
        let endX, endY;
        if (e.type.includes('touch')) {
            endX = e.changedTouches[0].clientX;
            endY = e.changedTouches[0].clientY;
        } else {
            endX = e.clientX;
            endY = e.clientY;
        }
        
        const deltaX = this.startX - endX;
        const deltaY = Math.abs(this.startY - endY);
        
        if (deltaX > this.swipeThreshold && deltaY < this.swipeRestraint) {
            // Swipe left detected
            document.querySelector('.game-container').classList.add('swipe-out-left');
            
            setTimeout(() => {
                document.querySelector('.game-container').classList.remove('swiping-left', 'swipe-out-left');
                ui.resetGameContainerStyle();
                game.setupGame(true);
            }, 500); // Match this with the animation duration
        } else {
            // Reset if not swiped far enough or swiped vertically
            ui.resetGameContainerStyle();
        }
        
        this.isDragging = false;
    },

    handleDragMove(e) {
        if (!this.isDragging) return;
        
        let currentX, currentY;
        if (e.type.includes('touch')) {
            currentX = e.touches[0].clientX;
            currentY = e.touches[0].clientY;
        } else {
            currentX = e.clientX;
            currentY = e.clientY;
        }
        
        const deltaX = this.startX - currentX;
        const deltaY = Math.abs(this.startY - currentY);
        
        if (deltaX > 0 && deltaY < this.swipeRestraint) {
            const progress = Math.min(deltaX / 100, 1);
            const rotation = progress * -5;
            const opacity = 1 - progress * 0.5;
            
            this.gameContainer.style.transform = `rotate(${rotation}deg) translateX(${-deltaX}px)`;
            this.gameContainer.style.opacity = opacity;
        }
    },

    handleImageInteraction(event) {
        if (!event) return;  // handle cases where event is undefined
        const diffX = Math.abs(this.touchStartX - (event.clientX || event.changedTouches[0].clientX));
        const diffY = Math.abs(this.touchStartY - (event.clientY || event.changedTouches[0].clientY));
        // Add any specific image interaction logic here
    },

    async handleNewPairSubmit(event) {
        event.preventDefault();
        const taxon1 = document.getElementById('taxon1').value;
        const taxon2 = document.getElementById('taxon2').value;
        const dialogMessage = document.getElementById('dialog-message');
        
        dialogMessage.textContent = 'Validating taxa...';
        
        const [validatedTaxon1, validatedTaxon2] = await Promise.all([
            api.validateTaxon(taxon1),
            api.validateTaxon(taxon2)
        ]);
        
        if (validatedTaxon1 && validatedTaxon2) {
            const newPair = {
                taxon1: validatedTaxon1.name,
                taxon2: validatedTaxon2.name
            };
        
            try {
                const response = await fetch('./data/taxonPairs.json');
                const taxonPairs = await response.json();
                taxonPairs.push(newPair);
        
                // Set the new pair as the next pair to be used
                game.nextSelectedPair = newPair;
                
                // Close the dialog
                document.getElementById('enter-pair-dialog').close();
                
                // Set up the game with the new pair
                game.setupGame(true);
            } catch (error) {
                console.error('Error updating taxonPairs.json:', error);
                dialogMessage.textContent = 'Error saving new pair. Please try again.';
            }
        } else {
            dialogMessage.textContent = 'One or both taxa are invalid. Please check and try again.';
        }
    },

    showTaxonPairList() {
        api.fetchTaxonPairs().then(taxonPairs => {
            ui.showTaxonPairList(taxonPairs, (selectedPair) => {
                game.nextSelectedPair = selectedPair;
                game.setupGame(true);
            });
        });
    },

    // move to other module, utils?
    shareCurrentPair() {
        let currentUrl = new URL(window.location.href);
        currentUrl.searchParams.delete('taxon1');
        currentUrl.searchParams.delete('taxon2');
        currentUrl.searchParams.set('taxon1', gameState.taxonImageOne);
        currentUrl.searchParams.set('taxon2', gameState.taxonImageTwo);
        let shareUrl = currentUrl.toString();
        
        navigator.clipboard.writeText(shareUrl).then(() => { }).catch(err => {
            console.error('Failed to copy: ', err);
            alert('Failed to copy link. Please try again.');
        });
    },

    handleKeyboardShortcuts(event) {
        const isDialogOpen = document.getElementById('enter-pair-dialog').open;
        
        if (!isDialogOpen) {
            if (event.key === 'r' || event.key === 'R' || event.key === 'ArrowLeft') {
                document.getElementById('random-pair-button').click();
            }
            if (event.key === 's' || event.key === 'S') {
                document.getElementById('select-pair-button').click();
            }
            if (event.key === 'h' || event.key === 'H') {
                document.getElementById('help-button').click();
            }
            if (event.key === 'e' || event.key === 'E') {
                document.getElementById('enter-pair-button').click();
                setTimeout(() => {
                    document.getElementById('taxon1').value = '';
                    document.getElementById('taxon1').focus();
                }, 0);
            }
            if (event.key === 'p' || event.key === 'P' || event.key === 'f' || event.key === 'F') {
                document.getElementById('surprise-button').click();
            }
        }
    }
};

export default eventHandlers;

==> ./functions.js <==
// snapshot 20240712 2247 > stable, but tooo many preload requests
import api from './api.js';
import config from './config.js';
import dragAndDrop from './dragAndDrop.js';
import {elements, gameState} from './state.js';
import eventHandlers from './eventHandlers.js';
import game from './game.js';
import ui from './ui.js';
import utils from './utils.js';

(function() {

    document.getElementById('version-id').textContent = `Modified: ${document.lastModified}`;

    function initializeApp() {
        console.log("Initializing app");
        
        // Check for URL parameters
        const urlParams = utils.getURLParameters();
        if (urlParams) {
            console.log("URL parameters found:", urlParams);
            game.nextSelectedPair = urlParams;
        }
        
        game.setupGame(true);
        eventHandlers.initialize();
        console.log("App initialization complete");
    }

    // Expose initializeApp to the global scope
    window.initializeApp = initializeApp;

    // Call initialization function
    window.addEventListener('DOMContentLoaded', (event) => {
        window.initializeApp();
    });
})();

==> ./game.js <==
// Game functions

import api from './api.js';
import config from './config.js';
import {elements, gameState, updateGameState, GameState} from './state.js';
import ui from './ui.js';
import utils from './utils.js';

const game = {
    nextSelectedPair: null,
    currentState: GameState.IDLE,

    currentObservationURLs: {
        imageOne: null,
        imageTwo: null
    },

    setState(newState) {
        console.log(`Game state changing from ${this.currentState} to ${newState}`);
        this.currentState = newState;
    },

    async quickLoadInitialImages() {
        try {
            console.log("Starting quick load of initial images");
            const initialPair = await this.selectTaxonPair();
            const [imageOneURL, imageTwoURL] = await Promise.all([
                api.fetchRandomImage(initialPair.taxon1),
                api.fetchRandomImage(initialPair.taxon2)
            ]);
            console.log("Quick load completed successfully");
            return { initialPair, imageOneURL, imageTwoURL };
        } catch (error) {
            console.error("Error during quick load of initial images:", error);
            throw error;
        }
    },

    async setupGame(newSession = false) {
        if (newSession) {
            console.log("Starting new session, resetting state");
            this.setState(GameState.IDLE);
        }

        if (this.currentState !== GameState.IDLE && 
            this.currentState !== GameState.READY && 
            this.currentState !== GameState.CHECKING) {
            console.log("Game is not in a state to start a new session");
            return;
        }

        this.setState(GameState.LOADING);

        if (!await this.checkINaturalistReachability()) {
            this.setState(GameState.IDLE);
            return;
        }

        this.prepareUIForLoading();

        try {
            await this.initializeOrUpdateTaxonImageCollection(newSession);
            
            await this.setupRound();
            this.finishSetup();
            ui.initializeDraggables(); // for dragging name tiles
            this.setState(GameState.PLAYING);
            console.log("Game setup complete. Current state:", this.currentState);

            ui.hideOverlay();  // Hide overlay when setup is complete

            // Start preloading the next pair in the background only for new sessions
            if (newSession) {
                this.preloadNextTaxonPairInBackground();
            }
        } catch (error) {
            console.error("Error setting up game:", error);
            ui.showOverlay("Error loading game. Please try again.", config.overlayColors.red);
            this.setState(GameState.IDLE);
        }
    },

    async initializeOrUpdateTaxonImageCollection(newSession) {
        if (newSession || !gameState.currentTaxonImageCollection) {
            if (this.nextSelectedPair) {
                console.log("Using selected pair:", this.nextSelectedPair);
                updateGameState({
                    currentTaxonImageCollection: {
                        pair: this.nextSelectedPair,
                        imageOneURLs: [],
                        imageTwoURLs: [],
                        imageOneVernacular: null,
                        imageTwoVernacular: null
                    }
                });
                this.nextSelectedPair = null; // Clear the selected pair
            } else if (gameState.isInitialLoad) {
                console.log("Performing quick load for initial session");
                const quickLoadData = await this.quickLoadInitialImages();
                updateGameState({
                    currentTaxonImageCollection: {
                        pair: quickLoadData.initialPair,
                        imageOneURLs: [quickLoadData.imageOneURL],
                        imageTwoURLs: [quickLoadData.imageTwoURL],
                        imageOneVernacular: null,
                        imageTwoVernacular: null
                    },
                    isInitialLoad: false
                });
            } else if (gameState.preloadedTaxonImageCollection) {
                updateGameState({
                    currentTaxonImageCollection: gameState.preloadedTaxonImageCollection,
                    preloadedTaxonImageCollection: null
                });
            } else {
                await this.loadNewTaxonPair();
            }

            if (!gameState.currentTaxonImageCollection) {
                console.error("Failed to initialize currentTaxonImageCollection");
                throw new Error("Failed to initialize currentTaxonImageCollection");
            }
            await this.loadCurrentTaxonImageCollection();
        }
    },

    async preloadNextTaxonPairInBackground() {
        if (this.currentState !== GameState.PLAYING) {
            console.log("Not in correct state to preload");
            return;
        }

        if (gameState.isPreloading) return;
        
        updateGameState({ isPreloading: true });
        console.log("Starting to preload next pair in the background");

        try {
            const newPair = await this.selectTaxonPair();
            console.log(`Preloading images for taxon pair: ${newPair.taxon1} and ${newPair.taxon2}`);
            const [imageOneURLs, imageTwoURLs, imageOneVernacular, imageTwoVernacular] = await Promise.all([
                api.fetchMultipleImages(newPair.taxon1),
                api.fetchMultipleImages(newPair.taxon2),
                api.fetchVernacular(newPair.taxon1),
                api.fetchVernacular(newPair.taxon2)
            ]);

            updateGameState({
                preloadedTaxonImageCollection: {
                    pair: newPair,
                    imageOneURLs,
                    imageTwoURLs,
                    imageOneVernacular,
                    imageTwoVernacular
                }
            });

            await this.preloadImages(imageOneURLs.concat(imageTwoURLs));
            console.log("Finished preloading next pair");
        } catch (error) {
            console.error("Error preloading next pair:", error);
        } finally {
            updateGameState({ isPreloading: false });
        }
    },

    async loadCurrentTaxonImageCollection() {
        if (!gameState.currentTaxonImageCollection || !gameState.currentTaxonImageCollection.pair) {
            console.error("currentTaxonImageCollection or its pair is null");
            throw new Error("Invalid currentTaxonImageCollection");
        }

        const { taxon1, taxon2 } = gameState.currentTaxonImageCollection.pair;
        // TODO not sure if for one or both pairs? one taxon should not have more than 12 images
        const MAX_IMAGES = 24; // Adjust this number as needed

        const [imageOneURLs, imageTwoURLs, imageOneVernacular, imageTwoVernacular] = await Promise.all([
            api.fetchMultipleImages(taxon1),
            api.fetchMultipleImages(taxon2),
            api.fetchVernacular(taxon1),
            api.fetchVernacular(taxon2)
        ]);

        updateGameState({
            currentTaxonImageCollection: {
                ...gameState.currentTaxonImageCollection,
                imageOneURLs: imageOneURLs.slice(0, MAX_IMAGES),
                imageTwoURLs: imageTwoURLs.slice(0, MAX_IMAGES),
                imageOneVernacular,
                imageTwoVernacular
            }
        });

        await this.preloadImages(imageOneURLs.slice(0, MAX_IMAGES).concat(imageTwoURLs.slice(0, MAX_IMAGES)));
    },

    async setupRound() {
        const { pair, imageOneURLs, imageTwoURLs, imageOneVernacular, imageTwoVernacular } = gameState.currentTaxonImageCollection;
        const randomized = Math.random() < 0.5;

        const leftImageSrc = randomized ? 
            imageOneURLs[Math.floor(Math.random() * imageOneURLs.length)] :
            imageTwoURLs[Math.floor(Math.random() * imageTwoURLs.length)];
        const rightImageSrc = randomized ?
            imageTwoURLs[Math.floor(Math.random() * imageTwoURLs.length)] :
            imageOneURLs[Math.floor(Math.random() * imageOneURLs.length)];

        await this.loadImages(leftImageSrc, rightImageSrc);

        // Set the observation URLs
        this.currentObservationURLs.imageOne = this.getObservationURLFromImageURL(leftImageSrc);
        this.currentObservationURLs.imageTwo = this.getObservationURLFromImageURL(rightImageSrc);

        const leftName = randomized ? pair.taxon1 : pair.taxon2;
        const rightName = randomized ? pair.taxon2 : pair.taxon1;
        const leftVernacular = randomized ? imageOneVernacular : imageTwoVernacular;
        const rightVernacular = randomized ? imageTwoVernacular : imageOneVernacular;

        this.setupNameTilesUI(leftName, rightName, leftVernacular, rightVernacular);

        updateGameState({
            taxonImageOne: randomized ? pair.taxon1 : pair.taxon2,
            taxonImageTwo: randomized ? pair.taxon2 : pair.taxon1,
            currentRound: {
                pair,
                imageOneURLs,
                imageTwoURLs,
                imageOneVernacular,
                imageTwoVernacular,
                randomized
            }
        });
    },

    async preloadNextTaxonPair() {
        if (this.currentState !== GameState.PRELOADING_BACKGROUND) {
            console.log("Not in correct state to preload");
            return;
        }

        if (gameState.isPreloading) return;
        
        updateGameState({ isPreloading: true });
        console.log("Starting to preload next pair in the background");

        try {
            const newPair = await this.selectTaxonPair();
            console.log(`Preloading images for taxon pair: ${newPair.taxon1} and ${newPair.taxon2}`);
            const [imageOneURLs, imageTwoURLs, imageOneVernacular, imageTwoVernacular] = await Promise.all([
                api.fetchMultipleImages(newPair.taxon1),
                api.fetchMultipleImages(newPair.taxon2),
                api.fetchVernacular(newPair.taxon1),
                api.fetchVernacular(newPair.taxon2)
            ]);

            updateGameState({
                preloadedTaxonImageCollection: {
                    pair: newPair,
                    imageOneURLs,
                    imageTwoURLs,
                    imageOneVernacular,
                    imageTwoVernacular
                }
            });

            await this.preloadImages(imageOneURLs.concat(imageTwoURLs));
            console.log("Finished preloading next pair");
        } catch (error) {
            console.error("Error preloading next pair:", error);
        } finally {
            updateGameState({ isPreloading: false });
        }
        if (this.currentState === GameState.PRELOADING_BACKGROUND) {
            this.setState(GameState.PLAYING);
        }
    },

    prepareRound: async function(newPair) {
        console.log("Preparing new round, newPair:", newPair);
        if (newPair || !this.currentRound.pair) {
            if (gameState.preloadedPair) {
                console.log("Using preloaded pair");
                this.currentRound = gameState.preloadedPair;
                this.currentRound.randomized = Math.random() < 0.5;
            } else {
                console.log("No preloaded pair available, fetching new pair");
                await this.fetchNewPair();
            }

            // Fetch vernacular names if they're not already preloaded
            if (!this.currentRound.imageOneVernacular || !this.currentRound.imageTwoVernacular) {
                console.log("Fetching vernacular names for current pair");
                [this.currentRound.imageOneVernacular, this.currentRound.imageTwoVernacular] = await Promise.all([
                    api.fetchVernacular(this.currentRound.pair.taxon1),
                    api.fetchVernacular(this.currentRound.pair.taxon2)
                ]);
            }
        } else {
            console.log("Reusing current pair with new randomization");
            this.currentRound.randomized = Math.random() < 0.5;
        }
        console.log("Round preparation complete", this.currentRound);
    },

    fetchNewPair: async function() {
        const newPair = await this.selectTaxonPair();
        this.currentRound = {
            pair: newPair,
            imageOneURLs: [],
            imageTwoURLs: [],
            imageOneVernacular: null,
            imageTwoVernacular: null,
            randomized: Math.random() < 0.5
        };
        
        console.log("Fetching images for new pair");
        await this.fetchRoundData();
    },

    fetchRoundData: async function () {
        if (this.currentRound.imageOneURLs.length === 0 || this.currentRound.imageTwoURLs.length === 0) {
            const { taxon1, taxon2 } = this.currentRound.pair;
            const [imageOneURLs, imageTwoURLs, imageOneVernacular, imageTwoVernacular] = await Promise.all([
                api.fetchMultipleImages(taxon1),
                api.fetchMultipleImages(taxon2),
                api.fetchVernacular(taxon1),
                api.fetchVernacular(taxon2)
            ]);

            this.currentRound.imageOneURLs = imageOneURLs;
            this.currentRound.imageTwoURLs = imageTwoURLs;
            this.currentRound.imageOneVernacular = imageOneVernacular;
            this.currentRound.imageTwoVernacular = imageTwoVernacular;

            await this.preloadImages(imageOneURLs.concat(imageTwoURLs));
        }
    },

    preloadImages: async function(urls) {
        console.log(`Starting to preload ${urls.length} images`);
        const preloadPromises = urls.map(url => {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    console.log(`Preloaded image: ${url}`);
                    resolve();
                };
                img.onerror = () => {
                    console.error(`Failed to preload image: ${url}`);
                    reject();
                };
                img.src = url;
            });
        });
        await Promise.all(preloadPromises);
        console.log("Finished preloading all images");
    },

    renderCurrentRound: async function () {
        console.log("Rendering current round");
        const { pair, imageOneURLs, imageTwoURLs, imageOneVernacular, imageTwoVernacular, randomized } = this.currentRound;

        // Select random images from preloaded arrays
        let leftImageSrc = randomized ? 
            imageOneURLs[Math.floor(Math.random() * imageOneURLs.length)] :
            imageTwoURLs[Math.floor(Math.random() * imageTwoURLs.length)];
        let rightImageSrc = randomized ?
            imageTwoURLs[Math.floor(Math.random() * imageTwoURLs.length)] :
            imageOneURLs[Math.floor(Math.random() * imageOneURLs.length)];

        console.log("Selected images:", { leftImageSrc, rightImageSrc });

        // Set image sources without displaying them yet
        elements.imageOne.src = '';
        elements.imageTwo.src = '';

        const leftName = randomized ? pair.taxon1 : pair.taxon2;
        const rightName = randomized ? pair.taxon2 : pair.taxon1;
        const leftVernacular = randomized ? imageOneVernacular : imageTwoVernacular;
        const rightVernacular = randomized ? imageTwoVernacular : imageOneVernacular;

        this.setupNameTilesUI(leftName, rightName, leftVernacular, rightVernacular);

        gameState.taxonImageOne = randomized ? pair.taxon1 : pair.taxon2;
        gameState.taxonImageTwo = randomized ? pair.taxon2 : pair.taxon1;
        gameState.taxonLeftName = leftName;
        gameState.taxonRightName = rightName;

        // Load images without changing their positions
        await this.loadImages(leftImageSrc, rightImageSrc);
        console.log("Finished rendering current round");
    },

    preloadPair: async function () {
        const pair = await this.selectTaxonPair();
        console.log("in preloadPair: Selected next pair for preloading:", pair);
        const [imageOneURLs, imageTwoURLs, imageOneVernacular, imageTwoVernacular] = await Promise.all([
            api.fetchMultipleImages(pair.taxon1),
            api.fetchMultipleImages(pair.taxon2),
            api.fetchVernacular(pair.taxon1),
            api.fetchVernacular(pair.taxon2)
        ]);
        console.log(`Fetched ${imageOneURLs.length} images for ${pair.taxon1} and ${imageTwoURLs.length} images for ${pair.taxon2}`);

        // Preload all fetched images
        await this.preloadImages(imageOneURLs.concat(imageTwoURLs));
        console.log("in preloadPair: Finished preloading images for next pair");

        return { pair, imageOneURLs, imageTwoURLs, imageOneVernacular, imageTwoVernacular, randomized: Math.random() < 0.5 };
    },

    loadNewRound: async function () {
        if (gameState.preloadedPair) {
            this.currentRound = {
                pair: gameState.preloadedPair.pair,
                imageOneURL: gameState.preloadedPair.imageOneURL,
                imageTwoURL: gameState.preloadedPair.imageTwoURL,
                imageOneVernacular: null,
                imageTwoVernacular: null,
                randomized: Math.random() < 0.5
            };
        } else {
            const newPair = await this.selectTaxonPair();
            this.currentRound = {
                pair: newPair,
                imageOneURL: null,
                imageTwoURL: null,
                imageOneVernacular: null,
                imageTwoVernacular: null,
                randomized: Math.random() < 0.5
            };
            await this.fetchRoundData();
        }

        // Fetch vernacular names
        [this.currentRound.imageOneVernacular, this.currentRound.imageTwoVernacular] = await Promise.all([
            api.fetchVernacular(this.currentRound.pair.taxon1),
            api.fetchVernacular(this.currentRound.pair.taxon2)
        ]);

        // Start preloading the next pair
        gameState.preloadedPair = await this.preloadPair();
    },

    refreshCurrentRound: async function () {
        this.currentRound.randomized = Math.random() < 0.5;
        await this.fetchRoundData();
    },

    loadImages: async function(leftImageSrc, rightImageSrc) {
        console.log("Loading images:", { leftImageSrc, rightImageSrc });
        await Promise.all([
            this.loadImageAndRemoveLoadingClass(elements.imageOne, leftImageSrc),
            this.loadImageAndRemoveLoadingClass(elements.imageTwo, rightImageSrc)
        ]);
        console.log("Finished loading images");
    },

    async loadImageAndRemoveLoadingClass(imgElement, src) {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
                imgElement.src = src;
                imgElement.classList.remove('loading');
                // Add a slight delay before adding the 'loaded' class
                setTimeout(() => {
                    imgElement.classList.add('loaded');
                    resolve();
                }, 50); // 50ms delay to ensure the browser has time to apply the new src
            };
            img.src = src;
        });
    },

    checkINaturalistReachability: async function() {
        if (!await api.isINaturalistReachable()) {
            ui.showINatDownDialog();
            return false;
        }
        return true;
    },

    prepareUIForLoading: function() {
        utils.resetDraggables();
        ui.scrollToTop();
        elements.imageOne.classList.add('loading');
        elements.imageTwo.classList.add('loading');
        var startMessage = gameState.isFirstLoad ? "Drag the names!" : "Loading...";
        ui.showOverlay(startMessage, config.overlayColors.green);
        gameState.isFirstLoad = false;
    },

    async loadNewTaxonPair() {
        const newPair = await this.selectTaxonPair();
        updateGameState({
            currentTaxonImageCollection: {
                pair: newPair,
                imageOneURLs: [],
                imageTwoURLs: [],
                imageOneVernacular: null,
                imageTwoVernacular: null
            }
        });
    },

    // Core gameplay functions
    setupImages: async function() {
        let randomizeImages = Math.random() < 0.5;
        gameState.taxonImageOne = randomizeImages ? gameState.currentPair.taxon1 : gameState.currentPair.taxon2;
        gameState.taxonImageTwo = randomizeImages ? gameState.currentPair.taxon2 : gameState.currentPair.taxon1;

        const [imageOneVernacular, imageTwoVernacular] = await Promise.all([
            api.fetchVernacular(gameState.taxonImageOne),
            api.fetchVernacular(gameState.taxonImageTwo)
        ]);

        const [imageOneURL, imageTwoURL] = await Promise.all([
            api.fetchRandomImage(gameState.taxonImageOne),
            api.fetchRandomImage(gameState.taxonImageTwo)
        ]);

        await this.loadImages(imageOneURL, imageTwoURL);

        return {
            imageData: {
                imageOneVernacular,
                imageTwoVernacular,
                imageOneURL,
                imageTwoURL
            },
            randomizeImages
        };
    },

    setupNameTiles: function(imageData, randomizeImages) {
        const { taxon1, taxon2 } = gameState.currentPair;
        
        gameState.taxonImageOne = randomizeImages ? taxon1 : taxon2;
        gameState.taxonImageTwo = randomizeImages ? taxon2 : taxon1;
        
        gameState.taxonLeftName = randomizeImages ? taxon1 : taxon2;
        gameState.taxonRightName = randomizeImages ? taxon2 : taxon1;

        let leftNameVernacular = randomizeImages ? imageData.imageOneVernacular : imageData.imageTwoVernacular;
        let rightNameVernacular = randomizeImages ? imageData.imageTwoVernacular : imageData.imageOneVernacular;

        this.setupNameTilesUI(gameState.taxonLeftName, gameState.taxonRightName, leftNameVernacular, rightNameVernacular);
    },

    async checkAnswer(droppedZoneId) {
        console.log("Checking answer. Current state:", this.currentState);
        
        if (this.currentState !== GameState.PLAYING) {
            console.log("Cannot check answer when not in PLAYING state");
            return;
        }

        this.setState(GameState.CHECKING);

        const dropOne = document.getElementById('drop-1');
        const dropTwo = document.getElementById('drop-2');
        const colorCorrect = config.overlayColors.green;
        const colorWrong = config.overlayColors.red;

        const leftAnswer = dropOne.children[0]?.getAttribute('data-taxon');
        const rightAnswer = dropTwo.children[0]?.getAttribute('data-taxon');

        ui.scrollToTop();

        if (leftAnswer && rightAnswer) {
            let isCorrect = false;
            if (droppedZoneId === 'drop-1') {
                isCorrect = leftAnswer === gameState.taxonImageOne;
            } else {
                isCorrect = rightAnswer === gameState.taxonImageTwo;
            }

            if (isCorrect) {
                await ui.showOverlay('Correct!', colorCorrect);
                elements.imageOne.classList.add('loading');
                elements.imageTwo.classList.add('loading');
                await utils.sleep(1000); // Show "Correct!" for 1 second
                ui.updateOverlayMessage('Loading...'); // Update message without changing color
                await this.setupGame(false);  // Start a new round with the same taxon pair
            } else {
                // Immediately reset draggables before showing the "Try again!" message
                utils.resetDraggables();
                await ui.showOverlay('Try again!', colorWrong);
                await utils.sleep(800);
                ui.hideOverlay();
                this.setState(GameState.PLAYING);
            }
        } else {
            console.log("Incomplete answer. Returning to PLAYING state.");
            this.setState(GameState.PLAYING);
        }
    },

    async waitForPreloadingComplete() {
        while (this.currentState === GameState.PRELOADING_BACKGROUND) {
            await utils.sleep(100);
        }
    },

    setupNameTilesUI: function(leftName, rightName, leftNameVernacular, rightNameVernacular) {
        // Randomize the position of the name tiles
        const shouldSwap = Math.random() < 0.5;
        
        const nameOne = shouldSwap ? rightName : leftName;
        const nameTwo = shouldSwap ? leftName : rightName;
        const vernacularOne = shouldSwap ? rightNameVernacular : leftNameVernacular;
        const vernacularTwo = shouldSwap ? leftNameVernacular : rightNameVernacular;

        elements.leftName.setAttribute('data-taxon', nameOne);
        elements.rightName.setAttribute('data-taxon', nameTwo);
        elements.leftName.style.zIndex = '10';
        elements.rightName.style.zIndex = '10';

        // Create a span for the taxon name and a span for the vernacular name
        elements.leftName.innerHTML = `
            <span class="taxon-name">${nameOne}</span>
            ${vernacularOne ? `<span class="vernacular-name">${vernacularOne}</span>` : ''}
        `;
        elements.rightName.innerHTML = `
            <span class="taxon-name">${nameTwo}</span>
            ${vernacularTwo ? `<span class="vernacular-name">${vernacularTwo}</span>` : ''}
        `;

        gameState.taxonLeftName = nameOne;
        gameState.taxonRightName = nameTwo;
    },

    finishSetup: function() {
        ui.hideOverlay();
        console.log('Setup complete:', {
            taxonImageOne: gameState.taxonImageOne,
            taxonImageTwo: gameState.taxonImageTwo,
            taxonLeftName: gameState.taxonLeftName,
            taxonRightName: gameState.taxonRightName
        });
    },

    selectTaxonPair: async function (index = null) {
        const taxonPairs = await api.fetchTaxonPairs();
        if (taxonPairs.length === 0) {
            console.error("No taxon pairs available");
            return null;
        }
        return index !== null ? taxonPairs[index] : taxonPairs[Math.floor(Math.random() * taxonPairs.length)];
    },

// TODO for now only gives photo page
    getObservationURLFromImageURL(imageURL) {
        const match = imageURL.match(/\/photos\/(\d+)\//);
        if (match && match[1]) {
            return `https://www.inaturalist.org/photos/${match[1]}`;
        }
        return null;
    },

    initializeInfoButtons() {
        const infoButton1 = document.getElementById('info-button-1');
        const infoButton2 = document.getElementById('info-button-2');

        infoButton1.addEventListener('click', () => this.openObservationURL(this.currentObservationURLs.imageOne));
        infoButton2.addEventListener('click', () => this.openObservationURL(this.currentObservationURLs.imageTwo));
    },

    openObservationURL(url) {
        if (url) {
            window.open(url, '_blank');
        } else {
            console.error('Observation URL not available');
        }
    },

};

// Initialize info buttons
game.initializeInfoButtons();

export default game;

==> ./state.js <==
// Elements and game state

// DOM elements
export const elements = {
    imageOne: document.getElementById('image-1'),
    imageTwo: document.getElementById('image-2'),
    imageOneContainer: document.getElementById('image-container-1'),
    imageTwoContainer: document.getElementById('image-container-2'),
    namePair: document.querySelector('.name-pair'),
    leftName: document.getElementById('left-name'),
    rightName: document.getElementById('right-name'),
    overlay: document.getElementById('overlay'),
    overlayMessage: document.getElementById('overlay-message'),
    buttons: document.querySelectorAll('.bottom-button')
};

// Game State enum
export const GameState = {
    IDLE: 'IDLE',
    LOADING: 'LOADING',
    READY: 'READY',
    PLAYING: 'PLAYING',
    CHECKING: 'CHECKING',
    PRELOADING: 'PRELOADING',
    PRELOADING_BACKGROUND: 'PRELOADING_BACKGROUND'
};

export const gameState = {
    isFirstLoad: true,
    isInitialLoad: true,
    hasLoadedFullSet: false,
    isPreloading: false,
    preloadedPair: null,
    currentRound: {
        pair: null,
        imageOneURLs: [],
        imageTwoURLs: [],
        imageOneVernacular: null,
        imageTwoVernacular: null,
        randomized: false
    },
    preloadedTaxonImageCollection: null,
    currentTaxonImageCollection: null,
    taxonImageOne: null,
    taxonImageTwo: null,
    taxonLeftName: null,
    taxonRightName: null,
    currentState: GameState.IDLE  // track the current game state
};

// Function to update game state
export function updateGameState(newState) {
    Object.assign(gameState, newState);
}

==> ./ui.js <==
// UI functions

import api from './api.js';
import {elements, gameState} from './state.js';
import game from './game.js';

const ui = {

    // Enter pair dialog 
    clearDialogInputs: function () {
            document.getElementById('taxon1').value = '';
            document.getElementById('taxon2').value = '';
            document.getElementById('dialog-message').textContent = '';
        },

    resetGameContainerStyle: function () {
        const gameContainer = document.querySelector('.game-container');
        if (gameContainer) {
            gameContainer.style.transform = '';
            gameContainer.style.opacity = '';
        }
        elements.imageOneContainer.style.transform = '';
        elements.imageOneContainer.style.opacity = '';
        elements.imageTwoContainer.style.transform = '';
        elements.imageTwoContainer.style.opacity = '';
    },

    // display pair list for selection
    showTaxonPairList: function () {
        api.fetchTaxonPairs().then(taxonPairs => {
            if (taxonPairs.length === 0) {
                console.error("No taxon pairs available");
                return;
            }
            const modal = document.createElement('div');
            modal.className = 'taxon-pair-modal';
            
            const list = document.createElement('div');
            list.className = 'taxon-pair-list';
            
            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Cancel';
            cancelButton.className = 'taxon-pair-cancel-button';
            cancelButton.onclick = closeModal;
            
            taxonPairs.forEach((pair, index) => {
                const button = document.createElement('button');
                button.innerHTML = `<i>${pair.taxon1}</i> <span class="taxon-pair-versus">vs</span> <i>${pair.taxon2}</i>`;
                button.className = 'taxon-pair-button';
                button.onclick = () => {
                    // Set the selected pair as the next pair to be used
                    game.nextSelectedPair = pair;
                    
                    // Close the modal
                    closeModal();
                    
                    // Set up the game with the new pair
                    game.setupGame(true);
                };
                list.appendChild(button);
            });
            
            list.insertBefore(cancelButton, list.firstChild);
            
            modal.appendChild(list);
            document.body.appendChild(modal);
            
            modal.onclick = (e) => {
                if (e.target === modal) {
                    closeModal();
                }
            };

            // Add event listener for the Escape key
            const handleEscapeKey = (e) => {
                if (e.key === 'Escape') {
                    closeModal();
                }
            };

            document.addEventListener('keydown', handleEscapeKey);

            // Function to close the modal
            function closeModal() {
                document.body.removeChild(modal);
                document.removeEventListener('keydown', handleEscapeKey);
            }
        });
    },

    showOverlay: function (message="", color) {
        elements.overlayMessage.innerHTML = message;
        elements.overlay.style.backgroundColor = color;
        elements.overlay.classList.add('show');
    },

    updateOverlayMessage: function (message) {
        elements.overlayMessage.innerHTML = message;
    },

    hideOverlay: function () {
        elements.overlay.classList.remove('show');
    },

    scrollToTop: function () {
        window.scrollTo({ top: 0, behavior: 'smooth' });
    },

    showINatDownDialog: function () {
        const dialog = document.getElementById('inat-down-dialog');
        dialog.showModal();
        
        document.getElementById('check-inat-status').addEventListener('click', () => {
            window.open('https://inaturalist.org', '_blank');
        });
        
        document.getElementById('retry-connection').addEventListener('click', async () => {
            dialog.close();
            if (await api.isINaturalistReachable()) {
                game.setupGame(true);
            } else {
                showINatDownDialog();
            }
        });
    },

    initializeDraggables: function() {
        const draggables = document.querySelectorAll('.draggable');
        let draggedElement = null;

        draggables.forEach(draggable => {
            draggable.addEventListener('mousedown', startDragging);
            draggable.addEventListener('touchstart', startDragging);
        });

        document.addEventListener('mousemove', drag);
        document.addEventListener('touchmove', drag);
        document.addEventListener('mouseup', stopDragging);
        document.addEventListener('touchend', stopDragging);

        function startDragging(e) {
            draggedElement = this;
            draggedElement.classList.add('dragging');
            
            // Calculate offset
            const rect = draggedElement.getBoundingClientRect();
            const offsetX = (e.clientX || e.touches[0].clientX) - rect.left;
            const offsetY = (e.clientY || e.touches[0].clientY) - rect.top;
            draggedElement.dataset.offsetX = offsetX;
            draggedElement.dataset.offsetY = offsetY;

            // Prevent default to disable text selection
            e.preventDefault();
        }

        function drag(e) {
            if (!draggedElement) return;

            const x = (e.clientX || e.touches[0].clientX) - draggedElement.dataset.offsetX;
            const y = (e.clientY || e.touches[0].clientY) - draggedElement.dataset.offsetY;

            draggedElement.style.left = `${x}px`;
            draggedElement.style.top = `${y}px`;
        }

        function stopDragging() {
            if (!draggedElement) return;

            draggedElement.classList.remove('dragging');
            draggedElement.style.left = '';
            draggedElement.style.top = '';
            draggedElement = null;
        }
    },

}; // const ui

export default ui;

==> ./utils.js <==
// Utility functions

const utils = {

    // optionally get pair of taxa from URL
    getURLParameters: function () {
        const params = new URLSearchParams(window.location.search);
        const taxon1 = params.get('taxon1');
        const taxon2 = params.get('taxon2');
        if (taxon1 && taxon2) {
            return { taxon1, taxon2 };
        }
        return null;
    },

    surprise: function () {
        // placeholder
        const soundUrl = './sound/fart.mp3';
        // Create a new Audio object

    const audio = new Audio(soundUrl);
        audio.play({ playbackMode: 'background' })
          .then(() => { /* Audio started playing successfully*/ }).catch(error => { console.error('Error playing the fart:', error); });
    },

    debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    },

    sleep: function(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    },

    resetDraggables: function () {
        const leftNameContainer = document.getElementById('left-name-container');
        const rightNameContainer = document.getElementById('right-name-container');
        const dropOne = document.getElementById('drop-1');
        const dropTwo = document.getElementById('drop-2');
        
        // Move draggables back to the names container
        leftNameContainer.appendChild(document.getElementById('left-name'));
        rightNameContainer.appendChild(document.getElementById('right-name'));
        
        // Clear drop zones
        dropOne.innerHTML = ''; dropTwo.innerHTML = '';
    },

}; // const utils

export default utils;

==> ./version.js <==
// version.js
const version = '1.3.27';

function updateVersion() {
    const noCacheFiles = document.querySelectorAll('link[rel="stylesheet"], link[rel="preload"], script[src], link[rel="manifest"]');
    noCacheFiles.forEach(element => {
        const url = new URL(element.href || element.src);
        url.searchParams.set('v', version);
        if (element.href) {
            element.href = url.toString();
        } else {
            element.src = url.toString();
        }
    });
}

document.addEventListener('DOMContentLoaded', updateVersion);
